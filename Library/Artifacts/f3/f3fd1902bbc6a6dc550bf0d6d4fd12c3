e na vyÅ¡Å¡Ã­ pozici v Å™etÄ›zu dÄ›diÄnosti.GPouÅ¾Ã­vÃ¡ se mÃ­sto let pro hodnoty, kterÃ© implementujÃ­ IDisposable.~PouÅ¾Ã­vÃ¡ se mÃ­sto let! ve vÃ½poÄetnÃ­ch vÃ½razech pro vÃ½sledky vÃ½poÄetnÃ­ch vÃ½razÅ¯, kterÃ© implementujÃ­ IDisposable.mSlouÅ¾Ã­ k oznaÄenÃ­ hodnoty v signatuÅ™e nebo v urÄitÃ½ch situacÃ­ch k deklarovÃ¡nÃ­ Älena v danÃ©m typu.^OznaÄuje prÃ¡zdnÃ½ typ .NET. PouÅ¾Ã­vÃ¡ se pÅ™i vzÃ¡jemnÃ© spoluprÃ¡ci s jinÃ½mi jazyky .NET.…PouÅ¾Ã­vÃ¡ se pro logickÃ© podmÃ­nky (klauzule when) u porovnÃ¡vÃ¡nÃ­ vzorÅ¯ a k uvozenÃ­ klauzule omezenÃ­ parametru obecnÃ©ho typu.Uvozuje konstruktor cyklu.‡PouÅ¾Ã­vÃ¡ se ve vÃ½poÄtovÃ½ch vÃ½razech pro zavedenÃ­ konstrukce smyÄky, kde podmÃ­nka je vÃ½sledkem jinÃ©ho vÃ½poÄtovÃ©ho vÃ½razu.ñPouÅ¾Ã­vÃ¡ se spoleÄnÄ› s klÃ­ÄovÃ½m slovem match ve vÃ½razech porovnÃ¡vÃ¡nÃ­ vzorÅ¯. Ve vÃ½razech objektÅ¯, vÃ½razech kopÃ­rovÃ¡nÃ­ zÃ¡znamÅ¯ a rozÅ¡Ã­Å™enÃ­ch typÅ¯ slouÅ¾Ã­ takÃ© k uvozenÃ­ definice Älena a obsluÅ¾nÃ½ch rutin vÃ½jimek.APouÅ¾Ã­vÃ¡ se ve vÃ½razu poÅ™adÃ­ k vytvoÅ™enÃ­ hodnoty poÅ™adÃ­.‘PouÅ¾Ã­vÃ¡ se ve vÃ½razu vÃ½poÄtu k pÅ™ipojenÃ­ vÃ½sledku danÃ©ho vÃ½poÄetnÃ­ho vÃ½razu ke kolekci vÃ½sledkÅ¯ obsahujÃ­cÃ­ho vÃ½razu vÃ½poÄtu.SThis byte array literal contains {0} characters that do not encode as a single byte[This byte array literal contains {0} non-ASCII characters. All characters should be < 128y.)BajtovÃ½ Å™etÄ›zec se nedÃ¡ interpolovat.VZnak {0} nenÃ­ v nÃ¡zvech operÃ¡torÅ¯ povolenÃ½: je vyhrazenÃ½ pro budoucÃ­ pouÅ¾itÃ­.PRozÅ¡Ã­Å™enÃ¡ interpolace Å™etÄ›zcÅ¯ nenÃ­ v tÃ©to verzi jazyka F# podporovÃ¡na.F#! by se mÄ›lo objevit jenom jako prvnÃ­ Å™Ã¡dek na zaÄÃ¡tku souboru.LDirektiva #else musÃ­ bÃ½t uvedenÃ¡ jako prvnÃ­ neprÃ¡zdnÃ½ znak na Å™Ã¡dku.5DirektivÄ› #else neodpovÃ­dÃ¡ Å¾Ã¡dnÃ¡ direktiva #if.MDirektiva #endif musÃ­ bÃ½t uvedenÃ¡ jako prvnÃ­ neprÃ¡zdnÃ½ znak na Å™Ã¡dku.2Pro direktivu #else se vyÅ¾aduje direktiva #endif.6DirektivÄ› #endif neodpovÃ­dÃ¡ Å¾Ã¡dnÃ¡ direktiva #if.JDirektiva #if musÃ­ bÃ½t uvedenÃ¡ jako prvnÃ­ neprÃ¡zdnÃ½ znak na Å™Ã¡dku.EZa direktivou #if by mÄ›l bezprostÅ™ednÄ› nÃ¡sledovat identifikÃ¡tor.TIdentifikÃ¡tory, po kterÃ½ch nÃ¡sleduje {0}, jsou vyhrazenÃ© pro budoucÃ­ pouÅ¾itÃ­.2Oblasti IF-FSHARP/IF-CAML uÅ¾ nejsou podporovÃ¡ny.HZvaÅ¾te moÅ¾nost pouÅ¾Ã­t mÃ­sto toho soubor s pÅ™Ã­ponou .ml nebo .mli.\This is not a valid byte character literal. The value must be less than or equal to '\127'B.%Toto nenÃ­ platnÃ½ znakovÃ½ literÃ¡l.«'{0}' is not a valid character literal.\nNote: Currently the value is wrapped around byte range to '{1}'. In a future F# version this warning will be promoted to an error.1NeplatnÃ© ÄÃ­slo s plovoucÃ­ desetinnou ÄÃ¡rkou!Toto nenÃ­ platnÃ½ identifikÃ¡torNeplatnÃ© ÄÃ­slo Å™Ã¡dku: {0}©Toto nenÃ­ platnÃ½ ÄÃ­selnÃ½ literÃ¡l. PlatnÃ© ÄÃ­selnÃ© literÃ¡ly zahrnujÃ­ hodnoty 1, 0x1, 0o1, 0b1, 1l (int/int32), 1u (uint/uint32), 1L (int64), 1UL (uint64), 1s (int16), 1us (uint16), 1y (int8/sbyte), 1uy (uint8/byte), 1.0 (float/double), 1.0f (float32/single), 1.0m (decimal), 1I (bigint).¥This is not a valid byte character literal. The value must be less than or equal to '\127'B.\nNote: In a future F# version this warning will be promoted to an error.8\U{0} nenÃ­ platnÃ¡ znakovÃ¡ Å™Ã­dicÃ­ sekvence Unicode.@Toto ÄÃ­slo je mimo povolenÃ½ rozsah pro desÃ­tkovÃ© literÃ¡ly.OToto ÄÃ­slo je mimo povolenÃ½ rozsah pro 8bitovÃ¡ celÃ¡ ÄÃ­sla se znamÃ©nkem._Toto ÄÃ­slo je mimo povolenÃ½ rozsah pro Å¡estnÃ¡ctkovÃ¡ 8bitovÃ¡ celÃ¡ ÄÃ­sla se znamÃ©nkem.OToto ÄÃ­slo je mimo povolenÃ½ rozsah pro 8bitovÃ¡ celÃ¡ ÄÃ­sla bez znamÃ©nka.CToto ÄÃ­slo je mimo povolenÃ½ rozsah pro tento celoÄÃ­selnÃ½ typ.OToto ÄÃ­slo je mimo povolenÃ½ rozsah pro nativnÃ­ celÃ¡ ÄÃ­sla se znamÃ©nkem.OToto ÄÃ­slo je mimo povolenÃ½ rozsah pro nativnÃ­ celÃ¡ ÄÃ­sla bez znamÃ©nka.PToto ÄÃ­slo je mimo povolenÃ½ rozsah pro 16bitovÃ¡ celÃ¡ ÄÃ­sla se znamÃ©nkem.PToto ÄÃ­slo je mimo povolenÃ½ rozsah pro 16bitovÃ¡ celÃ¡ ÄÃ­sla bez znamÃ©nka.PToto ÄÃ­slo je mimo povolenÃ½ rozsah pro 64bitovÃ¡ celÃ¡ ÄÃ­sla se znamÃ©nkem.PToto ÄÃ­slo je mimo povolenÃ½ rozsah pro 64bitovÃ¡ celÃ¡ ÄÃ­sla bez znamÃ©nka.\Toto ÄÃ­slo je mimo povolenÃ½ rozsah pro 32bitovÃ© ÄÃ­slo s plovoucÃ­ desetinnou ÄÃ¡rkou.PToto ÄÃ­slo je mimo povolenÃ½ rozsah pro 32bitovÃ¡ celÃ¡ ÄÃ­sla se znamÃ©nkem.PToto ÄÃ­slo je mimo povolenÃ½ rozsah pro 32bitovÃ¡ celÃ¡ ÄÃ­sla bez znamÃ©nka.LZnak }} musÃ­ bÃ½t v interpolovanÃ©m Å™etÄ›zci uvozenÃ½ (zdvojenÃ½m znakem).øNeplatnÃ½ interpolovanÃ½ Å™etÄ›zec. LiterÃ¡ly s jednoduchou uvozovkou nebo doslovnÃ© Å™etÄ›zcovÃ© literÃ¡ly se nedajÃ­ pouÅ¾Ã­t v interpolovanÃ½ch vÃ½razech v Å™etÄ›zcÃ­ch s jednoduchou uvozovkou nebo v doslovnÃ½ch Å™etÄ›zcÃ­ch. ZvaÅ¾te moÅ¾nost pouÅ¾Ã­t pro vÃ½raz interpolace explicitnÃ­ vazbu let nebo Å™etÄ›zec s trojitÃ½mi uvozovkami jako vnÄ›jÅ¡Ã­ Å™etÄ›zcovÃ½ literÃ¡l.\VÃ½raz tabulÃ¡toru nenÃ­ v kÃ³du F# povolenÃ½, pokud se nepouÅ¾ije moÅ¾nost #indent \"off\".FToto kÃ³dovÃ¡nÃ­ Unicode je platnÃ© jenom u Å™etÄ›zcovÃ½ch literÃ¡lÅ¯.1Tento token je vyhrazenÃ½ pro budoucÃ­ pouÅ¾itÃ­.ÄInterpolovanÃ½ Å™etÄ›zcovÃ½ literÃ¡l s trojitÃ½mi uvozovkami nezaÄÃ­nÃ¡ dostateÄnÃ½m poÄtem znakÅ¯ â€$â€œ, aby bylo moÅ¾nÃ© jako obsah pouÅ¾Ã­t tolik po sobÄ› jdoucÃ­ch otevÃ­racÃ­ch zÃ¡vorek.±InterpolovanÃ½ Å™etÄ›zcovÃ½ literÃ¡l s trojitÃ½mi uvozovkami nezaÄÃ­nÃ¡ dostateÄnÃ½m poÄtem znakÅ¯ â€$â€œ, aby bylo moÅ¾nÃ© pouÅ¾Ã­t tolik po sobÄ› jdoucÃ­ch znakÅ¯ â€%â€œ.ÏNeplatnÃ½ interpolovanÃ½ Å™etÄ›zec. V interpolovanÃ½ch vÃ½razech se nedajÃ­ pouÅ¾Ã­t Å™etÄ›zcovÃ© literÃ¡ly s trojitÃ½mi uvozovkami. ZvaÅ¾te moÅ¾nost pouÅ¾Ã­t pro interpolovanÃ½ vÃ½raz explicitnÃ­ vazbu let.NeoÄekÃ¡vanÃ½ znak {0}CInterpolovanÃ½ Å™etÄ›zec obsahuje nespÃ¡rovanÃ© sloÅ¾enÃ© zÃ¡vorky.`Chyba syntaxe. ChybnÄ› vnoÅ™enÃ¡ direktiva #endif. PÅ™ed vÃ½razem it jsou neoÄekÃ¡vanÃ© tokeny.TOdsazenÃ­ tohoto tokenu in nenÃ­ ve vztahu k odpovÃ­dajÃ­cÃ­ klauzuli let sprÃ¡vnÃ©.¦Tokeny | oddÄ›lujÃ­cÃ­ pravidla tohoto porovnÃ¡vacÃ­ho vzoru nejsou zarovnanÃ© o jeden sloupec. ZvaÅ¾te Ãºpravu zarovnÃ¡nÃ­ kÃ³du nebo pouÅ¾itÃ­ vÄ›tÅ¡Ã­ho odsazenÃ­.¹NeoÄekÃ¡vanÃ¡ syntaxe nebo moÅ¾nÃ© nesprÃ¡vnÃ© odsazenÃ­: Tento token je mimo kontext spuÅ¡tÄ›nÃ½ na pozici {0}. Zkuste toto odsazenÃ­ jeÅ¡tÄ› vÃ­ce odsadit.\nPokud chcete dÃ¡l pouÅ¾Ã­vat neodpovÃ­dajÃ­cÃ­ odsazenÃ­, pÅ™edejte kompilÃ¡toru pÅ™Ã­znak '--strict-indentation-' nebo nastavte jazykovou verzi na F# 7.DIdentifikÃ¡tor {0} je vyhrazenÃ½ pro budoucÃ­ pouÅ¾itÃ­ v jazyce F#.]IdentifikÃ¡tory obsahujÃ­cÃ­ znak @ jsou vyhrazenÃ© pro pouÅ¾itÃ­ pÅ™i generovÃ¡nÃ­ kÃ³du F#.¸VÅ¡echny elementy vÃ½razu konstruktoru seznamu musÃ­ bÃ½t implicitnÄ› pÅ™evoditelnÃ© na typ prvnÃ­ho elementu. OÄekÃ¡valo se, Å¾e tento vÃ½raz bude mÃ­t typ {0}, ale tady je typu {1}.ßVÅ¡echny prvky seznamu musÃ­ bÃ½t implicitnÄ› pÅ™evoditelnÃ© na typ prvnÃ­ho prvku, coÅ¾ je Å™azenÃ¡ kolekce ÄlenÅ¯ o dÃ©lce {0} typu\n    {1}    \nTento element je Å™azenÃ¡ kolekce ÄlenÅ¯ o dÃ©lce {2} typu\n    {3}    \n(NaÄÃ­tÃ¡ se popis...)[Pro pÅ™Ã­pad sjednocenÃ­, kterÃ½ nepÅ™ijÃ­mÃ¡ Å¾Ã¡dnÃ¡ data, se zahozenÃ­ vzoru nepovoluje.£ÄŒlen operÃ¡toru vpony {0} mÃ¡ curryfikovanÃ© argumenty navÃ­c. OÄekÃ¡vala se Å™azenÃ¡ kolekce ÄlenÅ¯ se dvÄ›ma argumenty, tÅ™eba statickÃ½ Älen (+) (x,y) = ...˜ÄŒlen operÃ¡toru vpony {0} nemÃ¡ Å¾Ã¡dnÃ© argumenty. OÄekÃ¡vala se Å™azenÃ¡ kolekce ÄlenÅ¯ se dvÄ›ma argumenty, tÅ™eba statickÃ½ Älen (+) (x,y) = ...¨ÄŒlen operÃ¡toru vpony {0} mÃ¡ poÄÃ¡teÄnÃ­ argumenty v poÄtu {1}. OÄekÃ¡vala se Å™azenÃ¡ kolekce ÄlenÅ¯ se dvÄ›ma argumenty, tÅ™eba statickÃ½ Älen (+) (x,y) = ...ÄŒlen operÃ¡toru vpony {0} mÃ¡ poÄÃ¡teÄnÃ­ argumenty v poÄtu {1}. OÄekÃ¡vala se Å™azenÃ¡ kolekce ÄlenÅ¯ se tÅ™emi argumenty.5Metoda nebo konstruktor objektu {0} nejsou statickÃ©.Ve vÃ½razu if chybÃ­ vÄ›tev else. VÄ›tev then je typu {0}. ProtoÅ¾e if je vÃ½raz a ne pÅ™Ã­kaz, pÅ™idejte vÄ›tev else, kterÃ¡ vrÃ¡tÃ­ hodnotu stejnÃ©ho typu.|Tento konstruktor je zastaralÃ½. {0}. Tuto funkci mÅ¯Å¾ete povolit pomocÃ­ parametrÅ¯ --langversion:5.0 a --mlcompatibility.ŠV pÅ™edchozÃ­ch verzÃ­ch jazyka F# bylo {0} rezervovanÃ½m klÃ­ÄovÃ½m slovem, ale pouÅ¾itÃ­ tohoto klÃ­ÄovÃ©ho slova je nynÃ­ zastaralÃ©.ePouÅ¾itÃ­ #light \"off\" nebo #indent \"off\" je ve verzi F# 2.0 zastaralÃ© a uÅ¾ nenÃ­ podporovÃ¡no.‡Tento konstruktor je urÄenÃ½ pro kompatibilitu ML. {0}. Toto upozornÄ›nÃ­ mÅ¯Å¾ete pomocÃ­ --mlcompatibility nebo --nowarn:62 vypnout.£PouÅ¾itÃ­ nÄ›kolika parametrÅ¯ typu v zÃ¡vorkÃ¡ch pÅ™ed nÃ¡zvem obecnÃ©ho typu, napÅ™Ã­klad (int, int) Map, je ve verzi F# 2.0 zastaralÃ© a uÅ¾ nenÃ­ podporovÃ¡no.œPouÅ¾itÃ­ modulu M: sig ... end je ve verzi F# 2.0 zastaralÃ© a uÅ¾ nenÃ­ podporovÃ¡no. ZmÄ›Åˆte : na =, odeberte sig a end pouÅ¾ijte mÃ­sto toho odsazenÃ­.‹PouÅ¾itÃ­ modulu M: sig ... end je ve verzi F# 2.0 zastaralÃ© a uÅ¾ nenÃ­ podporovÃ¡no. Odeberte sig a end pouÅ¾ijte mÃ­sto toho odsazenÃ­.‘PouÅ¾itÃ­ modulu M: struct ... end je ve verzi F# 2.0 zastaralÃ© a uÅ¾ nenÃ­ podporovÃ¡no. Odeberte struct a end pouÅ¾ijte mÃ­sto toho odsazenÃ­.:Pro typ delegÃ¡ta se naÅ¡la vÃ­c neÅ¾ jedna metoda Invoke.DStream nezaÄÃ­nÃ¡ zdrojem s hodnotou null a nenÃ­ ve formÃ¡tu .RES.BHlaviÄka zdroje zaÄÃ­najÃ­cÃ­ na posunu {0} mÃ¡ chybnÃ½ formÃ¡t.+ 1 pÅ™etÃ­Å¾enÃ­+ {0} pÅ™etÃ­Å¾enÃ­›Soubory v knihovnÃ¡ch nebo aplikacÃ­ch s vÃ­c soubory musÃ­ zaÄÃ­nat deklaracÃ­ oboru nÃ¡zvÅ¯ nebo modulu. Pokud na zaÄÃ¡tku souboru pouÅ¾ijete deklaraci modulu, nenÃ­ povolenÃ½ znak =. Pokud to je modul nejvyÅ¡Å¡Ã­ ÃºrovnÄ›, zvaÅ¾te odebrÃ¡nÃ­ znaku = pro vyÅ™eÅ¡enÃ­ tÃ©to chyby.5Pro typ delegÃ¡ta se nenaÅ¡ly Å¾Ã¡dnÃ© metody Invoke./Tato hodnota nenÃ­ funkcÃ­ a nedÃ¡ se pouÅ¾Ã­t.TTato hodnota nenÃ­ funkce a nedÃ¡ se pouÅ¾Ã­t. NezapomnÄ›li jste ukonÄit deklaraci?oTento vÃ½raz nenÃ­ funkcÃ­ a nedÃ¡ se pouÅ¾Ã­t. NechtÄ›li jste zÃ­skat k indexeru pÅ™Ã­stup pÅ™es expr.[index]?nTento vÃ½raz nenÃ­ funkcÃ­ a nedÃ¡ se pouÅ¾Ã­t. NechtÄ›li jste zÃ­skat k indexeru pÅ™Ã­stup pÅ™es expr[index]?
    nTato hodnota nenÃ­ funkcÃ­ a nedÃ¡ se pouÅ¾Ã­t. NechtÄ›li jste zÃ­skat k indexeru pÅ™Ã­stup pÅ™es {0}.[index]?mTato hodnota nenÃ­ funkcÃ­ a nedÃ¡ se pouÅ¾Ã­t. NechtÄ›li jste zÃ­skat k indexeru pÅ™Ã­stup pÅ™es {0}[index]?OVÃ½raz global se dÃ¡ pouÅ¾Ã­t jenom jako prvnÃ­ nÃ¡zev v kvalifikovanÃ© cestÄ›.NeplatnÃ½ vÃ½raz {0}NeplatnÃ½ popisek poleNeplatnÃ½ modul/vÃ½raz/typRToto nenÃ­ konstruktor nebo literÃ¡l, anebo se konstruktor pouÅ¾Ã­vÃ¡ nesprÃ¡vnÄ›.5Pro typ {0} nejsou k dispozici Å¾Ã¡dnÃ© konstruktory.(Typ zÃ¡znamu {0} neobsahuje popisek {1}.§Typ zÃ¡znamu pro pole zÃ¡znamu {0} se definoval pomocÃ­ atributu RequireQualifiedAccessAttribute. Do jmÃ©na, kterÃ© pouÅ¾Ã­vÃ¡te, pÅ™idejte nÃ¡zev typu zÃ¡znamu ({1}).»Instance obecnÃ©ho typu {0} chybÃ­ a nedÃ¡ se ani odvodit od argumentÅ¯ nebo nÃ¡vratovÃ©ho typu tohoto Älena. ZvaÅ¾te vytvoÅ™enÃ­ instance typu pÅ™i pÅ™Ã­stupu k tomuto typu, tÅ™eba {1}.£Existuje vÃ­c typÅ¯ s nÃ¡zvem {0}, kterÃ© pÅ™ebÃ­rajÃ­ rÅ¯znÃ½ poÄet obecnÃ½ch parametrÅ¯. Pro jednoznaÄnÃ© rozliÅ¡enÃ­ typu vytvoÅ™te instanci typu, tÅ™eba {1}./NeoÄekÃ¡vanÃ½ prÃ¡zdnÃ½ dlouhÃ½ identifikÃ¡tor´Typ sjednocenÃ­ pro pÅ™Ã­pad sjednocenÃ­ {0} se definoval pomocÃ­ atributu RequireQualifiedAccessAttribute. Do jmÃ©na, kterÃ© pouÅ¾Ã­vÃ¡te, pÅ™idejte nÃ¡zev typu sjednocenÃ­ ({1}).„Hodnota {0} byla oznaÄena jako InlineIfLambda, ale nemÃ¡ hodnotu lambda. Toto upozornÄ›nÃ­ slouÅ¾Ã­ pouze pro informaÄnÃ­ ÃºÄely.yNepovedlo se vloÅ¾it hodnotu {0} s oznaÄenÃ­m inline: moÅ¾nÃ¡ proto, Å¾e jste jako inline oznaÄili rekurzivnÃ­ hodnotu. RekurzivnÃ­ hodnota ValValue {0}Hodnota {0} mÃ¡ oznaÄenÃ­ inline, ale jejÃ­ implementace vyuÅ¾Ã­vÃ¡ internÃ­ nebo privÃ¡tnÃ­ funkci, ke kterÃ© nenÃ­ dostateÄnÃ½ pÅ™Ã­stup.SHodnota {0} mÃ¡ oznaÄenÃ­ inline, ale nenÃ­ svÃ¡zanÃ¡ s prostÅ™edÃ­m optimalizace..Hodnota s oznaÄenÃ­m inline se nedÃ¡ vloÅ¾it.8Hodnota s oznaÄenÃ­m inline mÃ¡ neoÄekÃ¡vanou hodnotu.cVytisknÄ›te odvozenÃ¡ rozhranÃ­ vÅ¡ech kompilovanÃ½ch souborÅ¯ do pÅ™idruÅ¾enÃ½ch souborÅ¯ podpisu.3ZÃ¡kladnÃ­ adresa knihovny, kterÃ¡ se mÃ¡ vytvoÅ™it&VytvoÅ™Ã­ spustitelnÃ½ soubor konzoly.'VytvoÅ™Ã­ knihovnu (krÃ¡tkÃ½ tvar: -a).<VytvoÅ™Ã­ modul, kterÃ½ se dÃ¡ pÅ™idat do jinÃ©ho sestavenÃ­/VytvoÅ™Ã­ spustitelnÃ½ soubor systÃ©mu Windows.'Enable nullness declarations and checksGenerovat kontroly pÅ™eteÄenÃ­•Zadejte algoritmus pro vÃ½poÄet kontrolnÃ­ho souÄtu zdrojovÃ©ho souboru uloÅ¾enÃ©ho v PDB. PodporovanÃ© hodnoty jsou: SHA1 nebo SHA256 (vÃ½chozÃ­).2Vymazat mezipamÄ›Å¥ vÃ½sledkÅ¯ sprÃ¡vce balÃ­ÄkÅ¯‹MoÅ¾nost pÅ™Ã­kazovÃ©ho Å™Ã¡dku --cliroot je zastaralÃ¡. PouÅ¾ijte mÃ­sto nÃ­ explicitnÃ­ odkaz na specifickou kopii knihovny mscorlib.dll.mPouÅ¾Ã­vÃ¡ se k pÅ™epsÃ¡nÃ­ umÃ­stÄ›nÃ­, kde kompilÃ¡tor hledÃ¡ knihovnu mscorlib.dll a komponenty rozhranÃ­.PUrÄuje znakovou strÃ¡nku, kterÃ¡ se pouÅ¾Ã­vÃ¡ ke ÄtenÃ­ zdrojovÃ½ch souborÅ¯.]Odkaz na sestavenÃ­ nebo adresÃ¡Å™ obsahujÃ­cÃ­ nÃ¡stroj pro dobu nÃ¡vrhu (krÃ¡tkÃ½ tvar: -t)4Komprimovat datovÃ© soubory rozhranÃ­ a optimalizace=BarevnÄ› rozliÅ¡enÃ¡ upozornÄ›nÃ­ vÃ½stupu a chybovÃ© zprÃ¡vy?Copyright (C) Microsoft Corporation. VÅ¡echna prÃ¡va vyhrazena.yVolnÄ› distribuovÃ¡no v rÃ¡mci licence MIT Open Source. https://github.com/Microsoft/visualfsharp/blob/master/License.txt0Povoluje nebo zakazuje optimalizaci mezi moduly.LMoÅ¾nost pÅ™Ã­kazovÃ©ho Å™Ã¡dku {0} je zastaralÃ¡. PouÅ¾ijte mÃ­sto nÃ­ {1}.¶MoÅ¾nost pÅ™Ã­kazovÃ©ho Å™Ã¡dku {0} je zastaralÃ¡. GenerovÃ¡nÃ­ dokumentu HTML je teÄ souÄÃ¡stÃ­ knihovny F# Power Pack a je pÅ™Ã­stupnÃ© prostÅ™ednictvÃ­m nÃ¡stroje FsHtmlDoc.exe.2MoÅ¾nost pÅ™Ã­kazovÃ©ho Å™Ã¡dku {0} je zastaralÃ¡.“Specify debugging type: full, portable, embedded, pdbonly. ('{0}' is the default if no debugging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file)./Generuje ladicÃ­ informace (krÃ¡tkÃ½ tvar: -g).<Definuje symboly podmÃ­nÄ›nÃ© kompilace (krÃ¡tkÃ½ tvar: -d).eVytvoÅ™Ã­ zpoÅ¾dÄ›nÃ½ podpis sestavenÃ­ jenom s vyuÅ¾itÃ­m veÅ™ejnÃ© ÄÃ¡sti klÃ­Äe silnÃ©ho nÃ¡zvu.YVytvoÅ™Ã­ deterministickÃ© sestavenÃ­ (vÄetnÄ› GUID verze modulu a ÄasovÃ©ho razÃ­tka).?VloÅ¾it vÅ¡echny zdrojovÃ© soubory do souboru PDB typu PortableBVloÅ¾Ã­ konkrÃ©tnÃ­ zdrojovÃ© soubory do pÅ™enosnÃ©ho souboru PDB.)Generovat ladicÃ­ informace v uvozovkÃ¡ch0VÃ½stupnÃ­ zprÃ¡vy s plnÄ› kvalifikovanou cestou/ZobrazÃ­ povolenÃ© hodnoty pro jazykovou verzi.6ZobrazÃ­ tuto zprÃ¡vu o pouÅ¾itÃ­ (krÃ¡tkÃ½ tvar: -?).- UPÅ˜ESNIT -- GENEROVÃNÃ KÃ“DU -- CHYBY A UPOZORNÄšNÃ -- VSTUPNÃ SOUBORY -	- JAZYK -- RÅ®ZNÃ‰ -- VÃSTUPNÃ SOUBORY -- PROSTÅ˜EDKY -MMoÅ¾nost pÅ™Ã­kazovÃ©ho Å™Ã¡dku {0} je urÄenÃ¡ jenom pro testovacÃ­ ÃºÄely.jNeplatnÃ¡ mapa cest. MapovÃ¡nÃ­ musÃ­ bÃ½t oddÄ›lenÃ¡ ÄÃ¡rkami a pouÅ¾Ã­vat formÃ¡t cesta=zdrojovÃ¡Cesta.ƒNeplatnÃ© pouÅ¾itÃ­ generovÃ¡nÃ­ referenÄnÃ­ho sestavenÃ­, nepouÅ¾Ã­vejte --standalone ani --staticlink s --refonly nebo --refout.+NeplatnÃ¡ cesta k referenÄnÃ­mu sestavenÃ­$NeplatnÃ½ soubor odpovÄ›di {0} ({1})RNeplatnÃ¡ verze {0} pro --subsystemversion. SprÃ¡vnÃ¡ verze je 4.00 nebo vyÅ¡Å¡Ã­.cNeplatnÃ¡ hodnota {0} pro --targetprofile. PlatnÃ© hodnoty jsou mscorlib, netcore nebo netstandard.'NeplatnÃ¡ ÃºroveÅˆ pro upozornÄ›nÃ­ {0}‡UrÄuje adresÃ¡Å™ pro cestu vloÅ¾enÃ½ch souborÅ¯, kterÃ½ se pouÅ¾ije k pÅ™ekladu zdrojovÃ½ch souborÅ¯ a sestavenÃ­ (krÃ¡tkÃ½ tvar: -I).yPropojÃ­ zadanÃ½ prostÅ™edek s tÃ­mto sestavenÃ­m, kde formÃ¡t resinfo je <soubor>[,<nÃ¡zev Å™etÄ›zce>[,public|private]].,Ignoruje upozornÄ›nÃ­ na kompatibilitu s ML./NÃ¡zev vÃ½stupnÃ­ho souboru (krÃ¡tkÃ½ tvar: -o)BNekopÃ­rujte FSharp.Core.dll k vytvÃ¡Å™enÃ½m binÃ¡rnÃ­m souborÅ¯m.aNepÅ™idÃ¡vat prostÅ™edek do generovanÃ©ho sestavenÃ­, kterÃ© obsahuje metadata specifickÃ¡ pro F#¸ZahrÅˆte jenom informace o optimalizaci nutnÃ© k implementaci vloÅ¾enÃ½ch konstruktorÅ¯. Deaktivuje se vklÃ¡dÃ¡nÃ­ napÅ™Ã­Ä moduly, ale zlepÅ¡Ã­ se kompatibilita binÃ¡rnÃ­ch souborÅ¯.@Neodkazovat ve vÃ½chozÃ­m nastavenÃ­ na vÃ½chozÃ­ sestavenÃ­ CLI6PotlaÄÃ­ zprÃ¡vu o autorskÃ½ch prÃ¡vech kompilÃ¡toru.!ZakÃ¡zat specifickÃ¡ upozornÄ›nÃ­$Nezahrnovat vÃ½chozÃ­ manifest Win32qZadejte zahrnutÃ© informace o optimalizaci, vÃ½chozÃ­ hodnota je soubor. DÅ¯leÅ¾itÃ© pro distribuovanÃ© knihovny.(Povolit optimalizace (krÃ¡tkÃ½ tvar: -O)IMapuje fyzickÃ© cesty na nÃ¡zvy zdrojovÃ½ch cest z vÃ½stupu kompilÃ¡toru.$Pojmenovat vÃ½stupnÃ­ ladicÃ­ souboryNÃ¡zev vÃ½stupnÃ­ho souboru pdb se nemÅ¯Å¾e shodovat s vÃ½stupnÃ­m nÃ¡zvem souboru sestavenÃ­ pomocÃ­ --pdb:filename.pdb.”Omezuje platformy, na kterÃ½ch je moÅ¾nÃ© tento kÃ³d spustit: x86, x64, Arm, Arm64, Itanium, anycpu32bitpreferred, nebo anycpu. VÃ½chozÃ­ je anycpu.BZadejte preferovanÃ½ nÃ¡zev jazykovÃ© verze (napÅ™. es-ES, ja-JP).'ProblÃ©m se znakovou strÃ¡nkou {0}: {1}‰VytvoÅ™Ã­ veÅ™ejnÃ½ podpis sestavenÃ­ jenom s vyuÅ¾itÃ­m veÅ™ejnÃ© ÄÃ¡sti klÃ­Äe silnÃ©ho nÃ¡zvu a oznaÄÃ­ sestavenÃ­ jako podepsanÃ©.[Vygenerovat sestavenÃ­ s viditelnostÃ­ IL, kterÃ© odpovÃ­dÃ¡ viditelnosti zdrojovÃ©ho kÃ³duVVytvoÅ™Ã­ referenÄnÃ­ sestavenÃ­ mÃ­sto ÃºplnÃ©ho sestavenÃ­ jako primÃ¡rnÃ­ vÃ½stup.>VytvoÅ™Ã­ referenÄnÃ­ sestavenÃ­ se zadanou cestou k souboru.+Odkazovat na sestavenÃ­ (krÃ¡tkÃ½ tvar: -r)?ZakÃ¡zat implicitnÃ­ generovÃ¡nÃ­ konstruktorÅ¯ pomocÃ­ reflexe_PouÅ¾Ã­t rezidentnÃ­ sluÅ¾bu kompilace na pozadÃ­ ke zlepÅ¡enÃ­ ÄasÅ¯ spuÅ¡tÄ›nÃ­ kompilÃ¡toru'VloÅ¾it zadanÃ½ spravovanÃ½ prostÅ™edek.DalÅ¡Ã­ moÅ¾nosti najdete v souboru odpovÄ›di.ƒNÃ¡zev souboru odpovÄ›di {0} je prÃ¡zdnÃ½, obsahuje neplatnÃ© znaky, mÃ¡ jednotku zadanou bez absolutnÃ­ cesty nebo je moc dlouhÃ½.'Soubor odpovÄ›di {0} se nenaÅ¡el v {1}.FUpÅ™esnÄ›te verzi jazyka, napÅ™Ã­klad â€latestâ€œ nebo â€previewâ€œ.KrÃ¡tkÃ½ tvar pro {0}4Vytisknout odvozenÃ© rozhranÃ­ sestavenÃ­ do souboru[Zahrnout informace o rozhranÃ­ F#, vÃ½chozÃ­ je soubor. KlÃ­ÄovÃ© pro distribuci knihoven._PÅ™eloÅ¾it odkazy na sestavenÃ­ pomocÃ­ pravidel zaloÅ¾enÃ½ch na adresÃ¡Å™i, ne pomocÃ­ MSBuildZInformaÄnÃ­ soubor zdrojovÃ©ho odkazu, kterÃ½ se mÃ¡ vloÅ¾it do souboru PDB typu Portable„Staticky propojit knihovnu F# a vÅ¡echny odkazovanÃ© knihovny DLL, kterÃ© jsou na nÃ­ zÃ¡vislÃ©, do prÃ¡vÄ› generovanÃ©ho sestavenÃ­µStaticky propojit zadanÃ© sestavenÃ­ a vÅ¡echny odkazovanÃ© knihovny DLL, kterÃ© jsou na tomto sestavenÃ­ zÃ¡vislÃ©. PouÅ¾Ã­t nÃ¡zev sestavenÃ­, tÅ™eba mylib, ne nÃ¡zev knihovny DLL6PÅ™epsat pravidla odsazenÃ­ implikovanÃ¡ verzÃ­ jazyka-UrÄuje kontejner klÃ­Äe se silnÃ½m nÃ¡zvem.*UrÄuje soubor klÃ­Äe se silnÃ½m nÃ¡zvem.,Zadejte verzi subsystÃ©mu tohoto sestavenÃ­.PodporovanÃ© jazykovÃ© verze:)Zapnout nebo vypnout volÃ¡nÃ­ funkce Tail‡Zadejte profil cÃ­lovÃ© architektury tohoto sestavenÃ­. PlatnÃ© hodnoty jsou mscorlib, netcore nebo netstandard. VÃ½chozÃ­ je mscorlib.NeznÃ¡mÃ½ argument --test: {0}"Algoritmus {0} nenÃ­ podporovanÃ½.VNeplatnÃ¡ hodnota '{0}' pro --optimizationdata, platnÃ¡ hodnota: none, file, compress.ŒNerozpoznanÃ¡ platforma {0}, platnÃ© hodnoty jsou x86, x64, Arm, Arm64, Itanium, anycpu32bitpreferred a anycpu. VÃ½chozÃ­ hodnota je anycpu.ZNeplatnÃ¡ hodnota â€{0}â€œ pro --interfacedata, platnÃ¡ hodnota je: none, file, compress.INerozpoznanÃ½ typ ladÄ›nÃ­ {0}. OÄekÃ¡vanÃ© typy jsou pdbonly nebo full.lNerozpoznanÃ¡ hodnota {0} pro parametr --langversion; seznam moÅ¾nostÃ­ zobrazÃ­te zadÃ¡nÃ­m --langversion:?KNerozpoznanÃ½ cÃ­l {0}. OÄekÃ¡vanÃ© jsou exe, winexe, library nebo module.,Povolit technologii ASLR s vysokou entropiÃ­&VÃ½stupnÃ­ zprÃ¡vy v kÃ³dovÃ¡nÃ­ UTF-8-Zobrazit banner verze kompilÃ¡toru a ukonÄit*Nastavit ÃºroveÅˆ pro upozornÄ›nÃ­ (0â€“5)WPovolit specifickÃ¡ upozornÄ›nÃ­, kterÃ¡ mÅ¯Å¾ou bÃ½t ve vÃ½chozÃ­m nastavenÃ­ vypnutÃ¡-Oznamovat konkrÃ©tnÃ­ upozornÄ›nÃ­ jako chyby*Oznamovat vÅ¡echna upozornÄ›nÃ­ jako chyby"Zadejte soubor ikony Win32 (.ico).Zadat soubor manifestu Win32)UrÄuje soubor prostÅ™edkÅ¯ Win32 (.res).+Zapsat xmldoc sestavenÃ­ do danÃ©ho souboruFFunkce sprÃ¡vy balÃ­ÄkÅ¯ vyÅ¾aduje jazykovou verzi 5.0 nebo vyÅ¡Å¡Ã­.{0}ŸKlÃ­Ä sprÃ¡vce balÃ­ÄkÅ¯ â€{0}â€œ nebyl v {1} zaregistrovÃ¡n. AktuÃ¡lnÄ› zaregistrovÃ¡no: {2}. Cesty navÃ­c mÅ¯Å¾ete zadat tak, Å¾e do pÅ™Ã­kazovÃ©ho Å™Ã¡dku pÅ™edÃ¡te --compilertool:<extensionsfolder>. DalÅ¡Ã­ informace o rozÅ¡Ã­Å™enÃ­ch najdete tady: https://aka.ms/dotnetdepmanagerModifikÃ¡tory dostupnosti nejsou u tohoto Älena povolenÃ©. AbstraktnÃ­ datovÃ© oblasti majÃ­ vÅ¾dycky stejnou viditelnost jako nadÅ™azenÃ½ typ.NZnak | nenÃ­ u identifikÃ¡torÅ¯ velikosti pÃ­smen aktivnÃ­ch vzorÅ¯ povolenÃ½.UIdentifikÃ¡tory velikosti pÃ­smen aktivnÃ­ho vzoru musÃ­ zaÄÃ­nat velkÃ½m pÃ­smenem.8VÅ¡em polÃ­m vÃ½ÄtovÃ©ho typu se musÃ­ pÅ™edat hodnota.ĞPouÅ¾itÃ­ -> ve vÃ½razech poÅ™adÃ­ a vÃ½poÄtu je omezenÃ© na formu for vzor in vÃ½raz -> vÃ½raz. Ke generovÃ¡nÃ­ prvkÅ¯ v komplexnÄ›jÅ¡Ã­ch vÃ½razech poÅ™adÃ­ pouÅ¾ijte syntaxi for ... in ... do ... yield...Yassert nejde pouÅ¾Ã­t jako hodnotu prvnÃ­ tÅ™Ã­dy. PouÅ¾ijte mÃ­sto toho assert <vÃ½raz>.mNedÃ¡ se najÃ­t cÃ­l kÃ³du pro tento atribut. MoÅ¾nÃ¡ je to proto, Å¾e kÃ³d za tÃ­mto atributem je neÃºplnÃ½.4Atributy nejsou u implementacÃ­ rozhranÃ­ povolenÃ©.,Atributy v tomto konstruktoru se ignorovaly.Tady atributy nejsou povolenÃ©./Atributy u deklaracÃ­ inherit nejsou povolenÃ©.-SprÃ¡vnÃ© umÃ­stÄ›nÃ­ atributÅ¯ je pÅ™ed val.<RozÅ¡Ã­Å™enÃ­ nejsou u typu delegÃ¡ta moduleDefns povolenÃ¡.?ZvaÅ¾te moÅ¾nost pouÅ¾Ã­t mÃ­sto toho samostatnÃ½ typ zÃ¡znamu.tSyntaxi prÅ¯niku omezenÃ­ lze pouÅ¾Ã­t pouze s flexibilnÃ­mi typy, napÅ™Ã­klad â€#IDisposable a #ISomeInterfaceâ€œ.WModifikÃ¡tory dostupnosti nejsou u vazeb do povolenÃ©, ale pÅ™edal se modifikÃ¡tor {0}.uNeplatnÃ½ interpolovanÃ½ Å™etÄ›zec. VyplnÄ›nÃ­ vÃ½razu interpolovanÃ©ho Å™etÄ›zce je prÃ¡zdnÃ©, oÄekÃ¡val se vÃ½raz.ÛDefinice typu vyÅ¾aduje jeden nebo vÃ­c ÄlenÅ¯ nebo jinÃ© deklarace. Pokud mÃ¡te v Ãºmyslu definovat prÃ¡zdnou tÅ™Ã­du, strukturu nebo rozhranÃ­, pouÅ¾ijte formulaci type ... = class end, interface end nebo struct end.EModifikÃ¡tory dostupnosti nejsou u polÃ­ vÃ½ÄtovÃ©ho typu povolenÃ©.LModifikÃ¡tory dostupnosti nejsou na tÃ©to pozici pro typy vÃ½Ätu povolenÃ©.BKonec souboru zaÄal v komentÃ¡Å™i na tÃ©to pozici nebo pÅ™ed nÃ­.AKonec souboru zaÄal v direktivÄ› na tÃ©to pozici nebo pÅ™ed nÃ­.?Konec souboru zaÄal v oddÃ­lu #if na tÃ©to pozici nebo za nÃ­.GKonec souboru zaÄal v oddÃ­lu IF-OCAML na tÃ©to pozici nebo pÅ™ed nÃ­.ITady nebo pÅ™ed tÃ­mto mÃ­stem zaÄal neÃºplnÃ½ interpolovanÃ½ Å™etÄ›zec.dTady nebo pÅ™ed tÃ­mto mÃ­stem zaÄalo vyplÅˆovÃ¡nÃ­ vÃ½razu neÃºplnÃ©ho interpolovanÃ©ho Å™etÄ›zce.aTady nebo pÅ™ed tÃ­mto mÃ­stem zaÄal neÃºplnÃ½ interpolovanÃ½ Å™etÄ›zec s trojitÃ½mi uvozovkami.STady nebo pÅ™ed tÃ­mto mÃ­stem zaÄal neÃºplnÃ½ interpolovanÃ½ doslovnÃ½ Å™etÄ›zec.@Konec souboru zaÄal v Å™etÄ›zci na tÃ©to pozici nebo pÅ™ed nÃ­.ZKonec souboru zaÄal v Å™etÄ›zci vloÅ¾enÃ©m do komentÃ¡Å™e na tÃ©to pozici nebo pÅ™ed nÃ­.YKonec souboru zaÄal v Å™etÄ›zci v trojitÃ½ch uvozovkÃ¡ch na tÃ©to pozici nebo pÅ™ed nÃ­.sKonec souboru zaÄal v Å™etÄ›zci v trojitÃ½ch uvozovkÃ¡ch vloÅ¾enÃ©m do komentÃ¡Å™e na tÃ©to pozici nebo pÅ™ed nÃ­.KKonec souboru zaÄal v doslovnÃ©m Å™etÄ›zci na tÃ©to pozici nebo pÅ™ed nÃ­.eKonec souboru zaÄal v doslovnÃ©m Å™etÄ›zci vloÅ¾enÃ©m do komentÃ¡Å™e na tÃ©to pozici nebo pÅ™ed nÃ­.^Chyba ve vrÃ¡cenÃ©m vÃ½razu pro tuto klauzuli let. DÅ¯vodem mÅ¯Å¾e bÃ½t nesprÃ¡vnÃ© odsazenÃ­.IProbÄ›hl pokus o analÃ½zu jako nÃ¡zvu operÃ¡toru, ale tento pokus selhal.×Blok, kterÃ½ nÃ¡sleduje po tomto {0}, nenÃ­ dokonÄenÃ½. KaÅ¾dÃ½ blok kÃ³du je vÃ½raz a musÃ­ mÃ­t vÃ½sledek. {1} nemÅ¯Å¾e bÃ½t koneÄnÃ½ element kÃ³du v bloku. ZvaÅ¾te, Å¾e tomuto bloku dÃ¡te explicitnÃ­ vÃ½sledek.&Za touto pozicÃ­ se oÄekÃ¡vÃ¡ vÃ½raz.ANeoÄekÃ¡vanÃ½ konec typu. Za touto pozicÃ­ se oÄekÃ¡vÃ¡ nÃ¡zev.$Za tÃ­mto bodem byl oÄekÃ¡vÃ¡n vzor#Za touto pozicÃ­ se oÄekÃ¡val typ.Byl oÄekÃ¡vÃ¡n vÃ½raz.OÄekÃ¡vÃ¡ se vzorek.Expecting record fieldOÄekÃ¡vÃ¡ se typExpecting union case field*Vazba pole musÃ­ bÃ½t v podobÄ› id = expr;LChybÃ­ do ve vÃ½razu for. OÄekÃ¡valo se for <vzor> in <vÃ½raz> do <vÃ½raz>.!VyÅ¾aduje se metoda get nebo set.*VyÅ¾aduje se metoda get, set nebo get,set.BVlastnost getter mÅ¯Å¾e mÃ­t maximÃ¡lnÄ› jednu skupinu argumentÅ¯.ZOÄekÃ¡vÃ¡ se, Å¾e vlastnost getter bude funkcÃ­, tÅ™eba get() = ... nebo get(index) = ...OÄekÃ¡val se identifikÃ¡tor.'Atributy u zkratky modulu se ignorujÃ­._Atribut pÅ™Ã­stupu {0} se u zkratky modulu nepovoluje. Zkratky modulu jsou vÅ¾dycky privÃ¡tnÃ­.aAtribut viditelnosti {0} se u zkratky modulu nepovoluje. Zkratky modulu jsou vÅ¾dycky privÃ¡tnÃ­.6Jmenovatel nesmÃ­ bÃ½t 0 v exponentu mÄ›rnÃ© jednotky.LU objektovÃ½ch vÃ½razÅ¯ se nepovolujÃ­ definice member val ani override val.OÄekÃ¡vÃ¡ se in nebo =.kNeÃºplnÃ¡ podmÃ­nka. OÄekÃ¡valo se if <vÃ½raz> then <vÃ½raz> nebo if <vÃ½raz> then <vÃ½raz> else <vÃ½raz>.bNeÃºplnÃ½ znakovÃ½ literÃ¡l (pÅ™Ã­klad: Q) nebo volÃ¡nÃ­ kvalifikovanÃ©ho typu (pÅ™Ã­klad: T.Name)dNeÃºplnÃ½ vÃ½raz operÃ¡toru (napÅ™Ã­klad^b) nebo volÃ¡nÃ­ kvalifikovanÃ©ho typu (pÅ™Ã­klad: ^T.Name)>Vlastnosti indexeru se musÃ­ pÅ™edÃ¡vat aspoÅˆ jeden argument.ÑDeklarace inherit nemÅ¯Å¾ou mÃ­t vazby as. Pro pÅ™Ã­stup ke ÄlenÅ¯m zÃ¡kladnÃ­ tÅ™Ã­dy pÅ™i pÅ™episovÃ¡nÃ­ metody se dÃ¡ pouÅ¾Ã­t syntaxe base.SomeMember, kde base je klÃ­ÄovÃ© slovo. Tuto vazbu as odeberte.PModifikÃ¡tory dostupnosti nejsou u typÅ¯ kÃ³du vloÅ¾enÃ½ch sestavenÃ­ povolenÃ©.GCeloÄÃ­selnÃ¡ smyÄka for musÃ­ pouÅ¾Ã­vat jednoduchÃ½ identifikÃ¡tor.BRozhranÃ­ majÃ­ vÅ¾dycky stejnou viditelnost jako nadÅ™azenÃ½ typ.%NeplatnÃ½ vÃ½raz anonymnÃ­ho zÃ¡znamu"NeplatnÃ½ typ anonymnÃ­ho zÃ¡znamuNeplatnÃ¡ syntaxe deklaraceNeplatnÃ½ literÃ¡l v typuNeplatnÃ½ operÃ¡tor pÅ™edponyqNeplatnÃ¡ definice operÃ¡tora. Definice operÃ¡torÅ¯ pÅ™edpon musÃ­ pouÅ¾Ã­vat platnÃ© nÃ¡zvy tÄ›chto operÃ¡torÅ¯..NeplatnÃ¡ metoda getter nebo setter vlastnosti*NeplatnÃ© pouÅ¾itÃ­ klÃ­ÄovÃ©ho slova rec~Notace deklarace let ... and ... se pro nerekurzivnÃ­ vazby v kÃ³du F# nepouÅ¾Ã­vÃ¡. ZvaÅ¾te pouÅ¾itÃ­ posloupnosti vazeb let.3Tento Älen nenÃ­ u implementace objektu povolenÃ½.5Neshoda v nÃ¡zvu operÃ¡toru citace (zaÄÃ­nÃ¡ na {0}))Neshoda v citaci, kterÃ¡ zaÄÃ­nÃ¡ na {0}ChybÃ­ tÄ›lo funkce.@NespÃ¡rovanÃ¡ levÃ¡ zÃ¡vorka <. OÄekÃ¡vÃ¡ se pravÃ¡ zÃ¡vorka >.!ChybÃ­ klÃ­ÄovÃ© slovo â€{0}â€œOÄekÃ¡vÃ¡ se text ÄlenaZa teÄkou chybÃ­ kvalifikace.4OÄekÃ¡val se argument typu nebo statickÃ½ argument.#ChybÃ­ nÃ¡zev pÅ™Ã­padu sjednocenÃ­?Jako zkratku modulu musÃ­te zadat jednoduchÃ½ nÃ¡zev, ne cestu.>Jako nÃ¡zev modulu musÃ­te zadat jednoduchÃ½ nÃ¡zev, ne cestu.gSyntaxe (typ,...,typ) ident se v kÃ³du F# nepouÅ¾Ã­vÃ¡. MÃ­sto toho zkuste pouÅ¾Ã­t ident<typ,...,typ>.dPokud je zadÃ¡na viditelnost vlastnosti, nastavenÃ­ viditelnosti metody set nebo get nenÃ­ povoleno.µDefinice vlastnostÃ­ se nedajÃ­ deklarovat jako mÄ›nitelnÃ©. Pokud chcete tuto vlastnost definovat jako nastavitelnou, pouÅ¾ijte syntaxi member val PropertyName = expr with get,set.xPokud chcete tuto vlastnost definovat jako nastavitelnou, pouÅ¾ijte syntaxi member val PropertyName = expr with get,set.’Soubory by mÄ›ly zaÄÃ­nat buÄ oborem nÃ¡zvÅ¯, nebo deklaracÃ­ modulu, tÅ™eba namespace SomeNamespace.SubNamespace nebo module SomeNamespace.SomeModule, nejde ale pouÅ¾Ã­t obojÃ­. Pokud chcete definovat modul uvnitÅ™ oboru nÃ¡zvÅ¯, pouÅ¾ijte syntaxi module SomeModule = ...€Tento pÅ™Ã­stup Älena je nejednoznaÄnÃ½. PÅ™i vytvÃ¡Å™enÃ­ objektu pouÅ¾ijte zÃ¡vorky, napÅ™. (new SomeType(args)).MemberName'5Po deklaraci namespace nemÅ¯Å¾e nÃ¡sledovat symbol =.CPro direktivu #if nebo #else se nenaÅ¡la Å¾Ã¡dnÃ¡ direktiva #endif.EPro tuto klauzuli let se nenaÅ¡el Å¾Ã¡dnÃ½ odpovÃ­dajÃ­cÃ­ vÃ½raz in.–Odeberte mezery mezi nÃ¡zvem a parametrem typu, napÅ™Ã­klad \"C<'T>\", ne \"C <'T>\". Parametry typu je potÅ™eba zadat bezprostÅ™ednÄ› za nÃ¡zev typu. Odeberte mezery mezi nÃ¡zvem a parametrem typu, napÅ™Ã­klad \"type C<'T>\", ne type \"C <'T>\". Parametry typu je potÅ™eba zadat bezprostÅ™ednÄ› za nÃ¡zev typu.pPouÅ¾itÃ­ syntaxe typu int C nebo C  <int> tady nenÃ­ povolenÃ©. ZvaÅ¾te zapsÃ¡nÃ­ tohoto typu v podobÄ› C<int>.8Argumenty hodnoty mÅ¯Å¾ou pÅ™ebÃ­rat jenom typy tÅ™Ã­dy.SPÅ™ed prvnÃ­ deklaracÃ­ namespace se dajÃ­ pouÅ¾Ã­t jenom direktivy kompilÃ¡toru #.0Povoluje se nanejvÃ½Å¡ jedno rozÅ¡Ã­Å™enÃ­ with.DV primÃ¡rnÃ­ch konstruktorech jsou povoleny pouze jednoduchÃ© vzory.~V kÃ³du F# mÅ¯Å¾ete pouÅ¾Ã­t expr.[expr]. Je moÅ¾nÃ©, Å¾e bude potÅ™eba zadÃ¡nÃ­m anotace typu vyznaÄit prvnÃ­ vÃ½raz v poli. ModifikÃ¡tory dostupnosti nejsou v polÃ­ch zÃ¡znamÅ¯ povolenÃ©. PomocÃ­ type R = internal ... nebo type R = private ... pÅ™edejte dostupnost celÃ© reprezentaci.€Metody set vlastnosti musÃ­ bÃ½t definovanÃ© pomocÃ­ syntaxe set value = , set idx value = nebo set (idx1,...,idxN) value = ... AVlastnost setter mÅ¯Å¾e mÃ­t maximÃ¡lnÄ› dvÄ› skupiny argumentÅ¯.“NeÃºplnÃ¡ deklarace statickÃ©ho konstruktoru. Pro deklaraci pouÅ¾ijte â€static letâ€œ, â€static doâ€œ, â€static memberâ€œ nebo â€static valâ€œ.¼Po sobÄ› jdoucÃ­ argumenty by mÄ›ly bÃ½t oddÄ›lenÃ© mezerami nebo by mÄ›ly bÃ½t Å™azenou kolekcÃ­ ÄlenÅ¯ a argumenty zahrnujÃ­cÃ­ pouÅ¾itÃ­ funkcÃ­ nebo metod by mÄ›ly bÃ½t v zÃ¡vorkÃ¡ch.fPo sobÄ› jdoucÃ­ vzory by mÄ›ly bÃ½t oddÄ›lenÃ© mezerami nebo by mÄ›ly bÃ½t Å™azenou kolekcÃ­ ÄlenÅ¯.chyba syntaxe)Chyba syntaxe v argumentu typu s popiskemqSyntaxe module ... : sig .. end se v kÃ³du F# nepouÅ¾Ã­vÃ¡. ZvaÅ¾te pouÅ¾itÃ­ syntaxe module ... = begin ... end.uSyntaxe module ... = struct ... end se v kÃ³du F# nepouÅ¾Ã­vÃ¡. ZvaÅ¾te pouÅ¾itÃ­ syntaxe module ... = begin ... end.LModifikÃ¡tory dostupnosti nejsou na tÃ©to pozici pro zkratky typu povolenÃ©.‡PoznÃ¡mky typu u metod getter nebo setter vlastnosti se musÃ­ pÅ™edÃ¡vat aÅ¾ po get() nebo set(v). PÅ™Ã­klad: with get() : string = ...$NÃ¡zev typu nemÅ¯Å¾e bÃ½t prÃ¡zdnÃ½.NeuzavÅ™enÃ½ blok/PodtrÅ¾Ã­tko se pro nÃ¡zev pole pouÅ¾Ã­t nedÃ¡./NeoÄekÃ¡vanÃ½ prÃ¡zdnÃ½ seznam typu moduleDefnNeoÄekÃ¡vanÃ½ konec vstupuBNeoÄekÃ¡vanÃ½ konec vstupu v definici hodnoty, funkce nebo Älena–NeoÄekÃ¡vanÃ½ konec vstupu ve vÄ›tvi else if nebo elif podmÃ­nÄ›nÃ©ho vÃ½razu OÄekÃ¡valo se elif <expr> then <expr> nebo else if <expr> then <expr>.™NeoÄekÃ¡vanÃ½ konec vstupu ve vÄ›tvi else podmÃ­nÄ›nÃ©ho vÃ½razu. OÄekÃ¡valo se if <vÃ½raz> then <vÃ½raz> nebo if <vÃ½raz> then <vÃ½raz> else <vÃ½raz>.&NeoÄekÃ¡vanÃ½ konec vstupu ve vÃ½razufNeoÄekÃ¡vanÃ½ konec vstupu ve vÃ½razu for. OÄekÃ¡vanÃ¡ notace je for <vzor> in <vÃ½raz> do <vÃ½raz>.mNeoÄekÃ¡vanÃ½ konec vstupu v tÄ›le vÃ½razu lambda. OÄekÃ¡vanÃ¡ notace je fun <vzor> ... <vzor> -> <vÃ½raz>.†NeoÄekÃ¡vanÃ½ konec vstupu ve vÃ½razu match. OÄekÃ¡vanÃ¡ notace je match <vÃ½raz> with | <vzor> -> <vÃ½raz> | <vzor> -> <vÃ½raz> ...-NeoÄekÃ¡vanÃ½ konec vstupu u ÄlenÅ¯ objektu™NeoÄekÃ¡vanÃ½ konec vstupu ve vÄ›tvi then podmÃ­nÄ›nÃ©ho vÃ½razu. OÄekÃ¡valo se if <vÃ½raz> then <vÃ½raz> nebo if <vÃ½raz> then <vÃ½raz> else <vÃ½raz>.{NeoÄekÃ¡vanÃ½ konec vstupu ve vÃ½razu try. OÄekÃ¡valo se try <vÃ½raz> with <pravidla> nebo try <vÃ½raz> finally <vÃ½raz>..NeoÄekÃ¡vanÃ½ konec vstupu v argumentech typu+NeoÄekÃ¡vanÃ½ konec vstupu v definici typu-NeoÄekÃ¡vanÃ½ konec vstupu v signatuÅ™e typuXNeoÄekÃ¡vanÃ½ konec vstupu ve vÃ½razu while. OÄekÃ¡valo se while <vÃ½raz> do <vÃ½raz>.5NeoÄekÃ¡vanÃ½ konec vstupu ve vÃ½razu match nebo try"NeoÄekÃ¡vanÃ½ identifikÃ¡tor: {0}.NeoÄekÃ¡vanÃ½ operÃ¡tor vpony ve vÃ½razu typuBNeoÄekÃ¡vanÃ½ celoÄÃ­selnÃ½ literÃ¡l ve vÃ½razu mÄ›rnÃ© jednotkyeNeoÄekÃ¡vanÃ½ operÃ¡tor vpony ve vÃ½razu mÄ›rnÃ© jednotky. PlatnÃ½mi operÃ¡tory jsou znaky *, / a ^.±NeoÄekÃ¡vanÃ½ operÃ¡tor citace <@ v definici typu. Pokud chcete zprostÅ™edkovateli typu pÅ™edÃ¡vat doslovnÃ½ Å™etÄ›zec jako statickÃ½ argument, vloÅ¾te mezi znaky < a @ mezeru.+StÅ™ednÃ­k se na tÃ©to pozici neoÄekÃ¡vÃ¡.SNeoÄekÃ¡vanÃ½ symbol . v definici Älenu. OÄekÃ¡valo se with, = nebo jinÃ½ token.dNeoÄekÃ¡vanÃ½ symbol = ve vÃ½razu. NemÄ›li jste v Ãºmyslu pouÅ¾Ã­t mÃ­sto toho for x in y ... z do?QModifikÃ¡tory dostupnosti tady nejsou povolenÃ©, ale pÅ™edal se modifikÃ¡tor {0}..NeoÄekÃ¡vanÃ½ token {0} nebo neÃºplnÃ½ vÃ½raz«ModifikÃ¡tory dostupnosti nejsou u pÅ™Ã­padÅ¯ typu union povolenÃ©. PomocÃ­ notace type U = internal ... nebo type U = private ... pÅ™edejte dostupnost celÃ© reprezentaci.NespÃ¡rovanÃ½ vÃ½raz {0}$NespÃ¡rovanÃ© klÃ­ÄovÃ© slovo begin0NespÃ¡rovanÃ© klÃ­ÄovÃ© slovo begin nebo struct!NespÃ¡rovanÃ¡ dvojice zÃ¡vorek {{NespÃ¡rovanÃ© znaky {{|NespÃ¡rovanÃ¡ zÃ¡vorka [NespÃ¡rovanÃ¡ dvojice znakÅ¯ [|;NespÃ¡rovanÃ© klÃ­ÄovÃ© slovo class, interface nebo structBNespÃ¡rovanÃ¡ dvojice znakÅ¯ [<. OÄekÃ¡vala se dvojice znakÅ¯ >].£NeÃºplnÃ¡ definice hodnoty nebo funkce. Pokud je tato definice ve vÃ½razu, musÃ­ bÃ½t tÄ›lo tohoto vÃ½razu odsazenÃ© na stejnou ÃºroveÅˆ jako klÃ­ÄovÃ© slovo let.˜NeÃºplnÃ¡ definice hodnoty. Pokud je tato definice ve vÃ½razu, musÃ­ bÃ½t tÄ›lo tohoto vÃ½razu odsazenÃ© na stejnou ÃºroveÅˆ jako klÃ­ÄovÃ© slovo let!.NespÃ¡rovanÃ¡ zÃ¡vorka (—NeÃºplnÃ¡ definice hodnoty. Pokud je tato definice ve vÃ½razu, musÃ­ bÃ½t tÄ›lo tohoto vÃ½razu odsazenÃ© na stejnou ÃºroveÅˆ jako klÃ­ÄovÃ© slovo use.˜NeÃºplnÃ¡ definice hodnoty. Pokud je tato definice ve vÃ½razu, musÃ­ bÃ½t tÄ›lo tohoto vÃ½razu odsazenÃ© na stejnou ÃºroveÅˆ jako klÃ­ÄovÃ© slovo use!.3NespÃ¡rovanÃ½ nebo Å¡patnÄ› formÃ¡tovanÃ½ blok with8U primÃ¡rnÃ­ch konstruktorÅ¯ nejsou vazby use povolenÃ©.CV modulech nejsou vazby use povolenÃ©. ZpracujÃ­ se jako vazby let.vModifikÃ¡tory dostupnosti by se mÄ›ly umÃ­stit bezprostÅ™ednÄ› pÅ™ed identifikÃ¡tor, kterÃ½ pojmenovÃ¡vÃ¡ konstruktor.CModifikÃ¡tory dostupnosti nejsou v deklaracÃ­ch inherits povolenÃ©.FChybÃ­ do ve vÃ½razu while. OÄekÃ¡valo se while <vÃ½raz> do <vÃ½raz>.ChybÄ›jÃ­cÃ­ promÄ›nnÃ¡ {0}DÄŒÃ¡steÄnÃ© aktivnÃ­ vzory mÅ¯Å¾ou generovat jenom jeden vÃ½sledek.8PotÃ­Å¾e s nÃ¡zvem souboru {0}: neplatnÃ© znaky v cestÄ›SOchrana porovnÃ¡nÃ­ vzorÅ¯ musÃ­ bÃ½t typu bool, ale tento vÃ½raz when je typu {0}.œChyba ÄtenÃ­ nebo zÃ¡pisu metadat pro knihovnu DLL {0} zkompilovanou v F#. Byla knihovna DLL zkompilovanÃ¡ ve starÅ¡Ã­ verzi kompilÃ¡toru F#? (chyba: {1}).ÙNovÄ› pÅ™idanÃ½ stav pickle nejde pouÅ¾Ã­t v FSharp.Core, protoÅ¾e musÃ­ fungovat i ve starÅ¡Ã­ch kompilÃ¡torech a nÃ¡strojÃ­ch. ÄŒasovÃ© okno je nejmÃ©nÄ› 3 roky po zavedenÃ­ funkce. PoruÅ¡enÃ­: {0}. Kontext: \n {1} øNastala chyba pÅ™i ÄtenÃ­ uzlu metadat F# na pozici {0} v tabulce {1} sestavenÃ­ {2}. Tento uzel nemÃ¡ Å¾Ã¡dnou odpovÃ­dajÃ­cÃ­ deklaraci. PÅ™edejte toto upozornÄ›nÃ­ dÃ¡l. SestavenÃ­ F#, kterÃ© pouÅ¾Ã­vÃ¡te, mÅ¯Å¾e bÃ½t potÅ™eba znovu kompilovat.ƒPÅ™i ÄtenÃ­ metadat jazyka F# sestavenÃ­ {0} doÅ¡lo k chybÄ›. Byl pouÅ¾it rezervovanÃ½ konstruktor. Je moÅ¾nÃ©, Å¾e budete muset upgradovat kompilÃ¡tor jazyka F# nebo pouÅ¾Ã­t dÅ™Ã­vÄ›jÅ¡Ã­ verzi sestavenÃ­, ve kterÃ© se nevyuÅ¾Ã­vÃ¡ konkrÃ©tnÃ­ konstruktor.7RegistrovanÃ­ sprÃ¡vci PackageManagers nepodporujÃ­ #i.<OÄekÃ¡val se jednoÅ™Ã¡dkovÃ½ komentÃ¡Å™ nebo konec Å™Ã¡dku./NeoÄekÃ¡vanÃ½ znak {0} ve vÃ½razu preprocesoruNeÃºplnÃ½ vÃ½raz preprocesoru.ChybÄ›jÃ­cÃ­ token {0} ve vÃ½razu preprocesoru0NeoÄekÃ¡vanÃ½ token {0} ve vÃ½razu preprocesoruSAtribut ReadOnly byl pouÅ¾it na typ struktury s mÄ›nitelnÃ½m (promÄ›nlivÃ½m) polem.(RekurzivnÃ­ hierarchie tÅ™Ã­d u typu {0}Nahradit nÃ¡vrhem: {0}LA constrained generic construct occurred in the resumable code specification¥CÃ­lovÃ½ popisek pro __resumeAt nebyl staticky urÄen. __resumeAt s nestatickÃ½m cÃ­lovÃ½m popiskem se mÅ¯Å¾e objevit jenom na zaÄÃ¡tku metody obnovitelnÃ©ho kÃ³du.<RychlÃ½ integer pro smyÄku nesmÃ­ obsahovat body obnovenÃ­.8A 'let rec' occurred in the resumable code specification9Blok â€withâ€œ try/with nesmÃ­ obsahovat body obnovenÃ­.,try/finally nesmÃ­ obsahovat body obnovenÃ­.]DelegÃ¡t nebo funkce vytvÃ¡Å™ejÃ­cÃ­ obnovitelnÃ½ kÃ³d ve stavovÃ©m stroji mÃ¡ parametry typu<Nepovedlo se snÃ­Å¾it vyvolÃ¡nÃ­ obnovitelnÃ©ho kÃ³du v {0}.2Hodnoty obnovitelnÃ©ho kÃ³du {0} nemajÃ­ definici.'StavovÃ½ stroj mÃ¡ neoÄekÃ¡vanÃ½ tvar.úTento stavovÃ½ stroj nenÃ­ staticky kompilovatelnÃ½. {0}. PouÅ¾ije se alternativnÃ­ dynamickÃ¡ implementace, kterÃ¡ mÅ¯Å¾e bÃ½t pomalejÅ¡Ã­. ZvaÅ¾te Ãºpravu kÃ³du tak, aby byl stavovÃ½ stroj staticky kompilovatelnÃ½, nebo toto upozornÄ›nÃ­ potlaÄte.ÑTento stavovÃ½ stroj nenÃ­ staticky kompilovatelnÃ½ a nenÃ­ k dispozici Å¾Ã¡dnÃ¡ alternativa. {0}. Pokud chcete zadat alternativu, pouÅ¾ijte if __useResumableCodeâ€œ then <state-machine> else <alternative>â€œ.4ZvaÅ¾te pouÅ¾itÃ­ parametru return! namÃ­sto return.Sadu .NET SDK pro tento skript neÅ¡lo urÄit. Pokud se skript nachÃ¡zÃ­ v adresÃ¡Å™i pouÅ¾Ã­vajÃ­cÃ­m global.json, zkontrolujte, jestli je nainstalovanÃ¡ odpovÃ­dajÃ­cÃ­ sada .NET SDK. VÃ½stup ze zadÃ¡nÃ­ {0} --version v adresÃ¡Å™i {1} byl {2} a ukonÄovacÃ­ kÃ³d byl {3}.Sada .NET SDK pro tento skript nedÃ¡ urÄit. dotnet.exe se nepovedlo najÃ­t, ujistÄ›te se, Å¾e je sada .NET SDK nainstalovanÃ¡.ÒSadu .NET SDK pro tento skript neÅ¡lo urÄit. Pokud se skript nachÃ¡zÃ­ v adresÃ¡Å™i pouÅ¾Ã­vajÃ­cÃ­m global.json, zkontrolujte, jestli je nainstalovanÃ¡ odpovÃ­dajÃ­cÃ­ sada .NET SDK. NeoÄekÃ¡vanÃ¡ chyba {0}.PZdrojovÃ½ soubor je pÅ™Ã­liÅ¡ velkÃ½ pro vloÅ¾enÃ½ do souboru PDB typu Portable.IPole struktury nebo tÅ™Ã­dy {0} nenÃ­ na tomto mÃ­stÄ› v kÃ³du dostupnÃ©.(NavrÅ¾enÃ½ nÃ¡zev)7AktivnÃ­ vzory nemÅ¯Å¾ou vracet vÃ­c neÅ¾ 7 moÅ¾nostÃ­.ŒAdresa hodnoty vrÃ¡cenÃ¡ vÃ½razem nejde pÅ™evzÃ­t. PÅ™ed pÅ™evzetÃ­m adresy pÅ™iÅ™aÄte vrÃ¡cenou hodnotu hodnotÄ› s vazbou na klauzuli Let.jModul a definice typu s nÃ¡zvem {0} se vyskytujÃ­ v oboru nÃ¡zvÅ¯ {1} ve dvou ÄÃ¡stech tohoto sestavenÃ­.dTento literÃ¡lovÃ½ vÃ½raz nebo argument atributu mÃ¡ za nÃ¡sledek pÅ™eteÄenÃ­ aritmetickÃ© operace.gDvÄ› definice typu s nÃ¡zvem {0} se vyskytujÃ­ v oboru nÃ¡zvÅ¯ {1} ve dvou ÄÃ¡stech tohoto sestavenÃ­.şTato operace pÅ™istupuje k promÄ›nlivÃ© hodnotÄ› na nejvyÅ¡Å¡Ã­ Ãºrovni definovanÃ© v jinÃ©m sestavenÃ­ nepodporovanÃ½m zpÅ¯sobem. K hodnotÄ› se nedÃ¡ pÅ™istupovat prostÅ™ednictvÃ­m jejÃ­ adresy. ZvaÅ¾te nÃ¡sledujÃ­cÃ­ postup: zkopÃ­rujte vÃ½raz do lokÃ¡lnÃ­ promÄ›nnÃ©, tÅ™eba let mutable x = ..., a po dokonÄenÃ­ operace pÅ™iÅ™aÄte v pÅ™Ã­padÄ› potÅ™eby znovu pÅ¯vodnÃ­ hodnotu.xNeplatnÃ¡ notace pro metodu getter vlastnosti. PÅ™i pouÅ¾itÃ­ explicitnÃ­ syntaxe se vyÅ¾aduje aspoÅˆ jeden argument ().ONeplatnÃ¡ notace pro metodu set vlastnosti. VyÅ¾aduje se aspoÅˆ jeden argument.CZjistila se neplatnÃ¡ signatura Älena kvÅ¯li dÅ™Ã­vÄ›jÅ¡Ã­ chybÄ›.NeplatnÃ¡ mutace konstantnÃ­ho vÃ½razu. ZvaÅ¾te moÅ¾nost zkopÃ­rovat vÃ½raz do lokÃ¡lnÃ­ promÄ›nnÃ©, tÅ™eba let mutable x = ...YObor nÃ¡zvÅ¯ a modul s nÃ¡zvem {0} se oba vyskytujÃ­ ve dvou ÄÃ¡stech tohoto sestavenÃ­.GToto nenÃ­ platnÃ½ konstantnÃ­ vÃ½raz nebo hodnota vlastnÃ­ho atributu.±RekurzivnÃ­ hodnoty nejde pouÅ¾Ã­t pÅ™Ã­mo jako konstrukce typu {0} v rekurzivnÃ­ vazbÄ›. Tato funkce je uÅ¾ z jazyka F# odebranÃ¡. ZvaÅ¾te moÅ¾nost pouÅ¾Ã­t mÃ­sto nÃ­ zÃ¡znam.¥RekurzivnÃ­ hodnoty se nedajÃ­ pÅ™Ã­mo pÅ™iÅ™adit k nepromÄ›nlivÃ©mu poli {0} typu {1} v rekurzivnÃ­ vazbÄ›. ZvaÅ¾te moÅ¾nost pouÅ¾Ã­t mÃ­sto toho promÄ›nlivÃ© pole.ŒRekurzivnÄ› definovanÃ© hodnoty se nedajÃ­ pouÅ¾Ã­t pÅ™Ã­mo jako souÄÃ¡st konstrukce hodnoty Å™azenÃ© kolekce ÄlenÅ¯ v rekurzivnÃ­ vazbÄ›.KDva moduly s nÃ¡zvem {0} se vyskytujÃ­ ve dvou ÄÃ¡stech tohoto sestavenÃ­.6Typ {0} mÃ¡ reprezentaci vloÅ¾enÃ©ho kÃ³du sestavenÃ­.9Typ nebo modul {0} nenÃ­ konkrÃ©tnÃ­m modulem nebo typem.`Modul nebo obor nÃ¡zvÅ¯ {0} z kompilaÄnÃ­ jednotky {1} neobsahoval modul nebo obor nÃ¡zvÅ¯ {2}.eModul nebo obor nÃ¡zvÅ¯ {0} z kompilaÄnÃ­ jednotky {1} neobsahoval obor nÃ¡zvÅ¯, modul nebo typ {2}.PModul nebo obor nÃ¡zvÅ¯ {0} z kompilaÄnÃ­ jednotky {1} neobsahoval hodnotu {2}./NeoÄekÃ¡vanÃ© pouÅ¾itÃ­ promÄ›nnÃ© typu ByRef..NeoÄekÃ¡vanÃ© dekÃ³dovÃ¡nÃ­ AutoOpenAttribute:NeoÄekÃ¡vanÃ© dekÃ³dovÃ¡nÃ­ InterfaceDataVersionAttribute8NeoÄekÃ¡vanÃ© dekÃ³dovÃ¡nÃ­ InternalsVisibleToAttribute5Tato hodnota nemÃ¡ platnÃ½ typ metody set vlastnosti.eHodnota se zkopÃ­rovala pro pÅ™Ã­pad, Å¾e by se v dÅ¯sledku tÃ©to operace pÅ¯vodnÃ­ hodnota zmÄ›nila.sHodnot definovanÃ¡ v modulu musÃ­ bÃ½t mÄ›nitelnÃ¡, aby se mohla pÅ™evzÃ­t jejÃ­ adresa, napÅ™. let mutable x = ...„Hodnota musÃ­ bÃ½t promÄ›nlivÃ¡, aby se dal zmÄ›nit obsah nebo aby se dala pÅ™evzÃ­t adresa typu hodnoty, tÅ™eba let mutable x = ...DF# podporuje rozmÄ›ry polÃ­ od 1 do 32. Hodnota {0} nenÃ­ povolenÃ¡.6ZkrÃ¡cenÃ½m typÅ¯m se nedÃ¡ pÅ™edÃ¡vat atribut Sealed.>Zkratky pro vÃ½jimky Common IL nemÅ¯Å¾ou pÅ™ebÃ­rat argumenty.SZkratky pro typy vÃ½jimek Common IL musÃ­ mÃ­t odpovÃ­dajÃ­cÃ­ konstruktor objektu.]AbstraktnÃ­ ÄlenovÃ© se v rozÅ¡Ã­Å™enÃ­ nepovolujÃ­ â€“ musÃ­ se definovat v samotnÃ©m typu.mTato hodnota pÅ™episuje nebo implementuje abstraktnÃ­ vlastnost, kterÃ¡ ale nemÃ¡ odpovÃ­dajÃ­cÃ­ metodu {0}.ğInstance tohoto typu se nedajÃ­ vytvoÅ™it, a to buÄ proto, Å¾e je tento typ oznaÄenÃ½ jako abstraktnÃ­, nebo proto, Å¾e jste neimplementovali vÅ¡echny metody. ZvaÅ¾te moÅ¾nost pouÅ¾Ã­t mÃ­sto toho objektovÃ½ vÃ½raz {{ new ... with ... }}.9Access modifiers cannot be applied to an SRTP constraint.XTento aktivnÃ­ vzor oÄekÃ¡vÃ¡ tento poÄet argumentÅ¯ vÃ½razu: {0}, napÅ™Ã­klad {1}{2}.mTento aktivnÃ­ vzor oÄekÃ¡vÃ¡ tento poÄet argumentÅ¯ vÃ½razu: {0} a argument vzoru, napÅ™Ã­klad {1}{2} pat.lTento aktivnÃ­ vzor neoÄekÃ¡vÃ¡ Å¾Ã¡dnÃ© argumenty, tj. mÄ›l by se pouÅ¾Ã­vat takto: {0} a ne takto: {1} x.MTento aktivnÃ­ vzor oÄekÃ¡vÃ¡ pÅ™esnÄ› jeden argument vzoru, napÅ™. {0} pat.@AktivnÃ­ vzory nemajÃ­ Å¾Ã¡dnÃ¡ pole. Tato syntaxe je neplatnÃ¡.\VÅ¡echna implementovanÃ¡ rozhranÃ­ by se mÄ›la deklarovat pÅ™i poÄÃ¡teÄnÃ­ deklaraci typu.¡Typy s atributem AllowNullLiteral mÅ¯Å¾ou dÄ›dit jenom od typÅ¯, kterÃ© umoÅ¾ÅˆujÃ­ pouÅ¾Ã­t taky literÃ¡l s hodnotou null, nebo tyto typy mÅ¯Å¾ou implementovat.tVÃ½znam _ je tady nejednoznaÄnÃ½. Nelze ho pouÅ¾Ã­t pro promÄ›nnou typu discard a zkratku funkce ve stejnÃ©m oboru.ßTento vÃ½raz mÃ¡ typ {0} a je kompatibilnÃ­ pouze s typem {1} prostÅ™ednictvÃ­m nejednoznaÄnÃ©ho implicitnÃ­ho pÅ™evodu. ZvaÅ¾te pouÅ¾itÃ­ explicitnÃ­ho volÃ¡nÃ­ op_Implicit. PouÅ¾itelnÃ½mi implicitnÃ­mi pÅ™evody jsou: {2}ŠTato funkce se v tÃ©to verzi jazyka F# nepodporuje. Abyste mohli tuto funkci pouÅ¾Ã­vat, moÅ¾nÃ¡ bude nutnÃ© pÅ™idat /langversion:preview.FDva typy anonymnÃ­ch zÃ¡znamÅ¯ jsou z rÅ¯znÃ½ch sestavenÃ­: {0} a {1}.:Pole {0} se v tomto vÃ½razu zÃ¡znamu vyskytuje vÃ­cekrÃ¡t.…Tento anonymnÃ­ zÃ¡znam neodpovÃ­dÃ¡ pÅ™esnÄ› oÄekÃ¡vanÃ©mu tvaru. PÅ™idejte chybÄ›jÃ­cÃ­ pole {0} a odeberte nadbyteÄnÃ¡ pole {1}.-NeplatnÃ¡ deklarace typu anonymnÃ­ho zÃ¡znamuETento anonymnÃ­ zÃ¡znam by mÄ›l mÃ­t pole {0}, ale tady mÃ¡ pole {1}.KTento anonymnÃ­ zÃ¡znam by mÄ›l mÃ­t pole {0}, ale tady mÃ¡ pole â€{1}â€œ.,V tomto anonymnÃ­m zÃ¡znamu chybÃ­ pole {0}.@Tento anonymnÃ­ zÃ¡znam obsahuje dalÅ¡Ã­ pole. Odebrat pole {0}.KTento anonymnÃ­ zÃ¡znam by mÄ›l mÃ­t pole â€{0}â€œ, ale tady mÃ¡ pole {1}.QTento anonymnÃ­ zÃ¡znam by mÄ›l mÃ­t pole â€{0}â€œ, ale tady mÃ¡ pole â€{1}â€œ.2V tomto anonymnÃ­m zÃ¡znamu chybÃ­ pole â€{0}â€œ.FTento anonymnÃ­ zÃ¡znam obsahuje dalÅ¡Ã­ pole. Odebrat pole â€{0}â€œ.BPole {0} se v tomto anonymnÃ­m typu zÃ¡znamu vyskytuje vÃ­cekrÃ¡t.?AnonymnÃ­ typy promÄ›nnÃ½ch nejsou v tÃ©to deklaraci povolenÃ©.PAnonymnÃ­ mÄ›rnÃ¡ jednotka se nedÃ¡ vnoÅ™it do jinÃ©ho vÃ½razu mÄ›rnÃ© jednotky.–ÄŒlen {0} nepÅ™ijÃ­mÃ¡ sprÃ¡vnÃ½ poÄet argumentÅ¯. OÄekÃ¡vanÃ½ poÄet argumentÅ¯ je {1}, ale pÅ™edalo se jich {2}. PoÅ¾adovanÃ¡ signatura je {3}.{4}¯ÄŒlen {0} nepÅ™ijÃ­mÃ¡ sprÃ¡vnÃ½ poÄet argumentÅ¯. PoÄet argumentÅ¯ pÅ™ijÃ­manÃ½ch jednÃ­m pÅ™etÃ­Å¾enÃ­m je {1}, ale pÅ™edalo se jich {2}. PoÅ¾adovanÃ¡ signatura je {3}.{4}XNejmÃ­Åˆ jedno pÅ™epsÃ¡nÃ­ neimplementovalo sprÃ¡vnÄ› odpovÃ­dajÃ­cÃ­ abstraktnÃ­ Älen.Atribut {0} se vyskytuje jak v implementaci, tak v signatuÅ™e, ale argumenty atributu se liÅ¡Ã­. Do kompilovanÃ©ho kÃ³du se zahrne jenom atribut ze signatury.|Atribut AutoOpen(\"{0}\") v sestavenÃ­ {1} neodkazoval na platnÃ½ modul nebo obor nÃ¡zvÅ¯ v tomto sestavenÃ­ a ignoroval se.<VÃ½razy atributu musÃ­ bÃ½t volÃ¡nÃ­ konstruktorÅ¯ objektÅ¯.CTento atribut nenÃ­ platnÃ½ pro pouÅ¾itÃ­ u tohoto elementu jazyka.§Tento atribut nenÃ­ platnÃ½ pro pouÅ¾itÃ­ u tohoto elementu jazyka. Atributy sestavenÃ­ by mÄ›ly bÃ½t pÅ™ipojenÃ© k deklaraci do (), v pÅ™Ã­padÄ› potÅ™eby v modulu F#.3Atributy nejsou u vazeb Let ve vÃ½razech povolenÃ©.(Atributy nejsou ve vzorech se povolenÃ©.2Atributy tohoto typu urÄujÃ­ pro typ vÃ­c druhÅ¯.0Atributy nejde pouÅ¾Ã­t pro rozÅ¡Ã­Å™enÃ­ typÅ¯.œDefinice member val jsou povolenÃ© jenom u typÅ¯ s primÃ¡rnÃ­m konstruktorem. ZvaÅ¾te moÅ¾nost pÅ™idat do definice typu argumenty, tÅ™eba type X(args) = ...j{0} se musÃ­ umÃ­stit za klauzuli vÃ½bÄ›ru for a pak musÃ­ nÃ¡sledovat zbytek dotazu. Syntaxe: ... {1} ...;Po {0} musÃ­ nÃ¡sledovat nÃ¡zev promÄ›nnÃ©. PouÅ¾itÃ­: {1}.8VÃ½razy let!, use! a do! se v dotazech pouÅ¾Ã­t nedajÃ­.4Vazba nemÅ¯Å¾e mÃ­t souÄasnÄ› oznaÄenÃ­ use i rec.”Tento vÃ½raz pouÅ¾Ã­vÃ¡ integrovanÃ½ implicitnÃ­ pÅ™evod pro pÅ™evod typu {0} na typ {1}. PÅ™eÄtÄ›te si tÃ©ma https://aka.ms/fsharp-implicit-convs.kTyp oznaÄenÃ½ IsByRefLike musÃ­ bÃ½t takÃ© strukturou. ZvaÅ¾te moÅ¾nost pÅ™idat k typu atribut [<Struct>].ëK ukazateli byref vrÃ¡cenÃ©mu funkcÃ­ nebo metodou se od F# 4.5 implicitnÄ› pÅ™istupuje pÅ™es ukazatel. Pokud chcete nÃ¡vratovou hodnotu zÃ­skat jako ukazatel, pouÅ¾ijte operÃ¡tor adresy, napÅ™Ã­klad &f(x) nebo &obj.Method(arg1, arg2).7Typy ByRef nesmÃ­ mÃ­t rozÅ¡Ã­Å™enÃ­ volitelnÃ©ho typu.4{0} se dÃ¡ pouÅ¾Ã­t jenom u volitelnÃ½ch argumentÅ¯.R{0} se musÃ­ pouÅ¾Ã­t pro argument typu {1}, ale pouÅ¾il se pro argument typu {2}..Nejde volat abstraktnÃ­ zÃ¡kladnÃ­ Älen: {0}.–Nejde volat metodu rozÅ¡Ã­Å™enÃ­ byref {0}. Parametr â€thisâ€œ vyÅ¾aduje, aby hodnota byla mÄ›nitelnÃ¡ nebo typu byref, kterÃ¡ nenÃ­ jen pro ÄtenÃ­.3Nejde vytvoÅ™it rozÅ¡Ã­Å™enÃ­ zapeÄetÄ›nÃ©ho typu..Nejde dÄ›dit z vymazanÃ©ho poskytnutÃ©ho typu.ONejde dÄ›dit z typu rozhranÃ­. PouÅ¾ijte mÃ­sto toho vÃ½raz interface ... with. ZapeÄetÄ›nÃ½ typ nejde zdÄ›dit."Z typu promÄ›nnÃ© se nedÃ¡ dÄ›dit.BZdÄ›dÄ›nÃ½ Älen {0} se nedÃ¡ pÅ™epsat, protoÅ¾e je zapeÄetÄ›nÃ½._Nejde ÄÃ¡steÄnÄ› pouÅ¾Ã­t rozÅ¡iÅ™ujÃ­cÃ­ metodu {0}, protoÅ¾e prvnÃ­ parametr je typu byref.@Atribut CompiledName se nedÃ¡ u tohoto elementu jazyka pouÅ¾Ã­t.RozhranÃ­ nemÅ¯Å¾ou obsahovat definice konkrÃ©tnÃ­ch ÄlenÅ¯. MoÅ¾nÃ¡ bude potÅ™eba definovat u typu konstruktor, kterÃ½ bude vyjadÅ™ovat, Å¾e jde o tÅ™Ã­du.=Atribut ConditionalAttribute se dÃ¡ pouÅ¾Ã­t jenom u ÄlenÅ¯._Atribut System.Diagnostics.ConditionalAttribute je platnÃ½ jenom u metod nebo tÅ™Ã­d atributÅ¯.‰Jedna nebo vÃ­c promÄ›nnÃ½ch explicitnÃ­ tÅ™Ã­dy nebo typu funkce pro tuto vazbu se nedala zobecnit, protoÅ¾e mÃ¡ omezenÃ­ na jinÃ© typy.ÃTento konstruktor je jako souÄÃ¡st vÃ½razu vÃ½poÄtu nejednoznaÄnÃ½. VnoÅ™enÃ© vÃ½razy jde zapsat pomocÃ­ notace let _ = (...) a vnoÅ™enÃ© vÃ½poÄty pomocÃ­ notace let! res = builder {{ ... }}.¸Tento konstruktor je jako souÄÃ¡st vÃ½razu poÅ™adÃ­ nejednoznaÄnÃ½. VnoÅ™enÃ© vÃ½razy jde zapsat pomocÃ­ notace let _ = (...) a vnoÅ™enÃ¡ poÅ™adÃ­ pomocÃ­ notace yield! seq {{... }}.?Tento konstruktor se dÃ¡ pouÅ¾Ã­t jenom ve vÃ½razech vÃ½poÄtu.•Tento konstruktor se dÃ¡ pouÅ¾Ã­t jenom ve vÃ½razech vÃ½poÄtu. Pokud chcete vracet hodnotu z bÄ›Å¾nÃ© funkce, napiÅ¡te jednoduÅ¡e vÃ½raz bez return.ûTento konstruktor se dÃ¡ pouÅ¾Ã­t jenom ve vÃ½razech seznamÅ¯, polÃ­ a posloupnostÃ­, napÅ™Ã­klad ve vÃ½razech ve formÄ› seq {{ ... }}, [ ... ] nebo [| ... |]. Tyto vÃ½razy pouÅ¾Ã­vajÃ­ syntaxi for ... in ... do ... yield... ke generovÃ¡nÃ­ elementÅ¯.MTento konstruktor se dÃ¡ pouÅ¾Ã­t jenom ve vÃ½razech poÅ™adÃ­ nebo vÃ½poÄtu.zKonstruktor nemÅ¯Å¾e mÃ­t parametry explicitnÃ­ho typu. ZvaÅ¾te moÅ¾nost pouÅ¾Ã­t mÃ­sto toho metodu statickÃ© konstrukce..Konstruktor nemÃ¡ Å¾Ã¡dnÃ© pole s nÃ¡zvem {0}.=VÃ½razy konstruktorÅ¯ pro rozhranÃ­ nepÅ™ebÃ­rajÃ­ argumenty..Tento konstruktor objektu vyÅ¾aduje argumenty.²Konstruktory pro typ {0} musÃ­ pÅ™Ã­mo nebo nepÅ™Ã­mo volat svoje implicitnÃ­ konstruktory objektu. MÃ­sto vÃ½razu zÃ¡znamu pouÅ¾ijte volÃ¡nÃ­ implicitnÃ­ho konstruktoru objektu.¾Konstruktory se musÃ­ pouÅ¾Ã­t pro argumenty a nejde je pouÅ¾Ã­t jako hodnoty prvnÃ­ tÅ™Ã­dy. V pÅ™Ã­padÄ› potÅ™eby pouÅ¾ijte anonymnÃ­ funkci (fun arg1 ... argN -> new Type(arg1,...,argN)).7V rozÅ¡Ã­Å™enÃ­ch vÃ½jimky nejde zadÃ¡vat konstruktory.+Pro tento typ nejde definovat konstruktory.tKonstruktory nejsou povolenÃ© jako Äleny rozÅ¡Ã­Å™enÃ­ â€“ musÃ­ bÃ½t definovanÃ© v rÃ¡mci pÅ¯vodnÃ­ definice typu.Vstupem vÃ½razu pro kopÃ­rovÃ¡nÃ­ a aktualizaci, kterÃ½ vytvoÅ™Ã­ anonymnÃ­ zÃ¡znam, musÃ­ bÃ½t anonymnÃ­ zÃ¡znam nebo zÃ¡znam.ŠTento vÃ½raz zÃ¡znamu kopÃ­rovÃ¡nÃ­ a aktualizace mÄ›nÃ­ vÅ¡echna pole typu zÃ¡znamu '{0}'. ZvaÅ¾te pouÅ¾itÃ­ syntaxe konstrukce zÃ¡znamu.UV rozhranÃ­ IDisposable se nenaÅ¡la metoda Dispose nebo je tato metoda pÅ™etÃ­Å¾enÃ¡.{PÅ™i sestavovÃ¡nÃ­ vÃ½razu fixed se mezi odkazy nepovedlo najÃ­t metodu System.Runtime.CompilerServices.OffsetToStringData.nPoÄet argumentÅ¯ pro vlastnÃ­ atribut neodpovÃ­dÃ¡ oÄekÃ¡vanÃ©mu poÄtu argumentÅ¯ pro konstruktor atributu.-VlastnÃ­ atribut musÃ­ bÃ½t odkazovÃ©ho typu.3VlastnÃ­ atribut musÃ­ vyvolat konstruktor objektu.½{0} se pouÅ¾Ã­vÃ¡ s nesprÃ¡vnÃ½m poÄtem argumentÅ¯. Toto je vlastnÃ­ operace v tomto vÃ½razu dotazu nebo vÃ½poÄtu. OÄekÃ¡vanÃ½ poÄet argumentÅ¯ je {1}, ale poÄet pÅ™edÃ¡vanÃ½ch je {2}.WDefinice vlastnÃ­ho operÃ¡toru {0} nepouÅ¾Ã­vÃ¡ platnou kombinaci pÅ™Ã­znakÅ¯ atributu.€VlastnÃ­ operace {0} odkazuje na metodu, kterÃ¡ je pÅ™etÄ›Å¾ovanÃ¡. Implementace vlastnÃ­ch operacÃ­ se nemÅ¯Å¾ou pÅ™etÄ›Å¾ovat.ŒVlastnÃ­ operace se ve spojenÃ­ s operÃ¡tory use, try/with, try/finally, if/then/else nebo match v tomto vÃ½razu vÃ½poÄtu pouÅ¾Ã­t nedajÃ­.VlastnÃ­ operace se nedajÃ­ pouÅ¾Ã­t ve spojenÃ­ s vazbou let, kterÃ¡ je bez hodnoty nebo rekurzivnÃ­ a nachÃ¡zÃ­ se v jinÃ© ÄÃ¡sti tohoto vÃ½razu vÃ½poÄtu.^{0} se nepouÅ¾Ã­vÃ¡ sprÃ¡vnÄ›. Toto je vlastnÃ­ operace v tomto vÃ½razu dotazu nebo vÃ½poÄtu.n{0} se nepouÅ¾Ã­vÃ¡ sprÃ¡vnÄ›. PouÅ¾itÃ­: {1}. Toto je vlastnÃ­ operace v tomto vÃ½razu dotazu nebo vÃ½poÄtu.8Tento element deklarace nenÃ­ u rozÅ¡Ã­Å™enÃ­ povolenÃ½.ÁMinimÃ¡lnÄ› jeden parametr deklarovanÃ©ho typu u tohoto rozÅ¡Ã­Å™enÃ­ typu neobsahuje omezenÃ­ typu nebo mÃ¡ nesprÃ¡vnÃ© omezenÃ­ typu, kterÃ© se neshoduje s pÅ¯vodnÃ­mi omezenÃ­mi typu na {0}.CMetoda implementovanÃ¡ touto vÃ½chozÃ­ tÅ™Ã­dou je nejednoznaÄnÃ¡.+Tato metoda uÅ¾ mÃ¡ vÃ½chozÃ­ implementaci.ŠVÃ½chozÃ­ implementace tohoto rozhranÃ­ uÅ¾ se pÅ™idala, protoÅ¾e jste v definici typu nezadali explicitnÃ­ implementaci tohoto rozhranÃ­.©VÃ½chozÃ­ konstruktor s nulovou inicializacÃ­ typu struktura se dÃ¡ pouÅ¾Ã­t jenom v pÅ™Ã­padÄ›, Å¾e vÅ¡echna pole typu struktura pÅ™ipouÅ¡tÄ›jÃ­ vÃ½chozÃ­ inicializaci.<Atribut DefaultValue se dÃ¡ pouÅ¾Ã­t jenom u deklaracÃ­ val.BKonstruktoru delegÃ¡ta se musÃ­ pÅ™edÃ¡vat jedinÃ¡ hodnota funkce.×Specifikace delegÃ¡tÅ¯ nesmÃ­ bÃ½t curryfikovanÃ© typy. Pro delegÃ¡ty, kteÅ™Ã­ majÃ­ vÃ­ce argumentÅ¯, pouÅ¾ijte typ * ... * typ -> typ a pro delegÃ¡ty, kteÅ™Ã­ vracÃ­ hodnoty funkcÃ­, pouÅ¾ijte typ -> (typ -> typ).VVazby DLLImport musÃ­ bÃ½t statickÃ½mi Äleny v definici tÅ™Ã­dy nebo funkce v modulu.5ProvizornÃ­ kÃ³dy DLLImport nemÅ¯Å¾ou bÃ½t vloÅ¾enÃ©.=KlÃ­ÄovÃ© slovo do! se ve vÃ½razech poÅ™adÃ­ nedÃ¡ pouÅ¾Ã­t.…MetodÄ› nebo funkci {0} by se nemÄ›ly pÅ™edÃ¡vat argumenty explicitnÃ­ho typu, protoÅ¾e svoje parametry typu nedeklaruje explicitnÄ›.­ZkrÃ¡cenÃ¡ syntaxe lambda je podporovÃ¡na pouze pro atomickÃ© vÃ½razy, jako je metoda, vlastnost, pole nebo indexer v implicitnÃ­ argumentu _. PÅ™Ã­klad: let f = _. Length'.!DuplicitnÃ­ specifikace rozhranÃ­]An empty body may only be used if the computation expression builder defines a 'Zero' method.PVÃ½razy zÃ¡znamu zkopÃ­rovÃ¡nÃ­ a aktualizace musÃ­ zahrnovat aspoÅˆ jedno pole.Ÿ{{ }} nenÃ­ platnÃ½ vÃ½raz. ZÃ¡znamy musÃ­ obsahovat alespoÅˆ jedno pole. PrÃ¡zdnÃ© posloupnosti se specifikujÃ­ pomocÃ­ Seq.empty nebo prÃ¡zdnÃ©ho seznamu [].OAtribut EntryPointAttribute se dÃ¡ pouÅ¾Ã­t jenom u definic funkcÃ­ v modulech.”Typ {0} nenÃ­ platnÃ½m vÃ½ÄtovÃ½m typem, to znamenÃ¡, Å¾e u nÄ›j chybÃ­ metoda MoveNext(), kterÃ¡ by vracela logickou hodnotu, a vlastnost Current.+VÃ½Äty nemÅ¯Å¾ou mÃ­t deklarace rozhranÃ­.VÃ½Äty nemÅ¯Å¾ou mÃ­t Äleny.UdÃ¡lost {0} nenÃ­ statickÃ¡.UdÃ¡lost {0} je statickÃ¡.mZkratky vÃ½jimek musÃ­ odkazovat na existujÃ­cÃ­ vÃ½jimky nebo typy F# odvozenÃ© od tÅ™Ã­dy System.Exception.4Zkratky vÃ½jimek by nemÄ›ly mÃ­t seznamy argumentÅ¯./VÃ½jimka {0} nemÃ¡ Å¾Ã¡dnÃ© pole s nÃ¡zvem {1}.>OÄekÃ¡val se nadÅ™azenÃ½ prvek modulu nebo oboru nÃ¡zvÅ¯ {0}.OÄekÃ¡val se typ rozhranÃ­.'OÄekÃ¡val se typ, ne mÄ›rnÃ¡ jednotka.:OÄekÃ¡val se parametr typu, ne parametr mÄ›rnÃ© jednotky.OÄekÃ¡val se parametr mÄ›rnÃ© jednotky, ne parametr typu. ExplicitnÃ­ parametry mÄ›rnÃ½ch jednotek musÃ­ bÃ½t oznaÄenÃ© atributem [<Measure>].(OÄekÃ¡vala se mÄ›rnÃ¡ jednotka, ne typ.LExplicitnÃ­ konstruktor objektu by mÄ›l pouÅ¾Ã­vat syntaxi new(args) = expr.XExplicitnÃ­ statickÃ½ inicializÃ¡tor by mÄ›l pouÅ¾Ã­vat syntaxi static new(args) = expr.NExplicitnÃ­ parametry typu se dajÃ­ pouÅ¾Ã­t jenom u vazeb modulu nebo Älena.JExplicitnÃ­ specifikace typu se nedajÃ­ pouÅ¾Ã­t u konstruktorÅ¯ vÃ½jimek.TcExprUndelayed: zpoÅ¾dÄ›nÃ©?OÄekÃ¡vanÃ½ poÄet vÃ½razÅ¯ je {0}. PoÄet pÅ™edanÃ½ch je {1}.cNotace expr then expr se dÃ¡ ve vÃ½razu pouÅ¾Ã­t jenom v rÃ¡mci explicitnÃ­ho konstruktoru objektu.©Notace {{ expr with ... }} se dÃ¡ ve vÃ½razech pouÅ¾Ã­t jenom u typÅ¯ zÃ¡znamu. Pokud chcete vytvoÅ™it objektovÃ© typy, pouÅ¾ijte formulaci {{ new Type(...) with ... }}.LTato notace vÃ½razu se dÃ¡ pouÅ¾Ã­t jenom ve vÃ½razech poÅ™adÃ­ a vÃ½poÄtu.ûTento vÃ½raz seznamu nebo pole zahrnuje element s formulacÃ­ if ... then ... else. OhraniÄte tento vÃ½raz zÃ¡vorkami, aby bylo jasnÃ©, Å¾e jde o samostatnÃ½ prvek seznamu nebo pole. OdliÅ¡Ã­te ho tak od seznamu generovanÃ©ho pomocÃ­ vÃ½razu poÅ™adÃ­.)NadbyteÄnÃ½m polÃ­m se pÅ™edaly hodnoty.”VÅ¡echny typy zÃ¡znam, sjednocenÃ­ a struktura v knihovnÄ› FSharp.Core.dll musÃ­ mÃ­t explicitnÃ­ oznaÄenÃ­ StructuralComparison nebo NoComparison.Toto pole nenÃ­ mÄ›nitelnÃ©.Pole {0} nenÃ­ statickÃ©.Toto pole je jen pro ÄtenÃ­.SPojmenovanÃ© pole {0} koliduje s automaticky generovanÃ½m nÃ¡zvem anonymnÃ­ho pole.5PojmenovanÃ© pole {0} se pouÅ¾Ã­vÃ¡ vÃ­c neÅ¾ jednou.6Toto pole nenÃ­ literÃ¡l a nedÃ¡ se pouÅ¾Ã­t ve vzoru.6Poli {0} typu {1} se nepÅ™edalo Å¾Ã¡dnÃ© pÅ™iÅ™azenÃ­.Toto pole vyÅ¾aduje nÃ¡zev.1Deklarace pole nebo hodnoty tady nenÃ­ povolenÃ¡.~Tyto popisky pole a oÄekÃ¡vanÃ½ typ tohoto vÃ½razu zÃ¡znamu nebo vzoru neurÄujÃ­ jednoznaÄnÄ› odpovÃ­dajÃ­cÃ­ typ zÃ¡znamu.‡NeplatnÃ© pouÅ¾itÃ­ â€fixedâ€œ. VÃ½raz â€fixedâ€œ se dÃ¡ pouÅ¾Ã­t jenom v deklaraci ve formÃ¡tu â€use x = fixed exprâ€œ, kde vÃ½raz je jedna z tÄ›chto vÄ›cÃ­: pole, adresa elementu pole, Å™etÄ›zec, byref, inref nebo typ implementujÃ­cÃ­ GetPinnableReference().5OdpovÃ­dajÃ­cÃ­ formÃ¡lnÃ­ argument nenÃ­ nepovinnÃ½.¿Tato hodnota funkce se pouÅ¾Ã­vÃ¡ k vytvoÅ™enÃ­ typu delegÃ¡ta, jehoÅ¾ signatura obsahuje argument ByRef. MusÃ­te pouÅ¾Ã­t explicitnÃ­ vÃ½raz lambda, kterÃ½ pÅ™ebÃ­rÃ¡ argumenty v poÄtu {0}.BObecnÃ© funkci {0} se musÃ­ pÅ™edÃ¡vat explicitnÃ­ argumenty typu.‡PoskytnutÃ© typy generovanÃ© tÃ­mto pouÅ¾itÃ­m zprostÅ™edkovatele typu moÅ¾nÃ¡ nepÅ¯jde pouÅ¾Ã­t v jinÃ½ch sestavenÃ­ch F# a mÄ›ly by se oznaÄit jako internÃ­ nebo privÃ¡tnÃ­. ZvaÅ¾te pouÅ¾itÃ­ notace type internal TypeName = ... nebo type private TypeName = ...PParametr obecnÃ©ho typu se pouÅ¾il tak, Å¾e ho to omezuje, aby vÅ¾dycky byl {0}.<ObecnÃ½m typÅ¯m se nemÅ¯Å¾e pÅ™edÃ¡vat atribut StructLayout.lPoÅ¾adoval se systÃ©movÃ½ typ {0}, ale Å¾Ã¡dnÃ¡ odkazovanÃ¡ systÃ©movÃ¡ knihovna DLL tento typ neobsahovala.ÁSyntaxe expr1[expr2] se pouÅ¾Ã­vÃ¡ pro indexovÃ¡nÃ­. Pokud chcete povolit indexovÃ¡nÃ­, zvaÅ¾te moÅ¾nost pÅ™idat anotaci typu, nebo pokud volÃ¡te funkci, pÅ™idejte mezeru, tÅ™eba expr1 [expr2].ËSyntaxe expr1[expr2] je teÄ vyhrazena pro indexovÃ¡nÃ­. VÃ­ce informacÃ­: https://aka.ms/fsharp-index-notation. Pokud volÃ¡te funkci, pÅ™idejte mezi funkci a argument mezeru, tÅ™eba someFunction [expr].„DoporuÄuje se, aby se objekty, kterÃ© podporujÃ­ rozhranÃ­ IDisposable, vytvÃ¡Å™ely pomocÃ­ syntaxe new Type(args) a ne Type(args) nebo Type jako hodnota funkce pÅ™edstavujÃ­cÃ­ konstruktor. TÃ­m se urÄÃ­, Å¾e prostÅ™edky mÅ¯Å¾e vlastnit generovanÃ¡ hodnota.|VÃ½raz if/then/else se nedÃ¡ pouÅ¾Ã­t v dotazech. ZvaÅ¾te moÅ¾nost pouÅ¾Ã­t mÃ­sto toho vÃ½raz if/then nebo vÃ½raz poÅ™adÃ­.WLiterÃ¡lovÃ© hodnotÄ› nejde pÅ™iÅ™adit atribut [<ThreadStatic>] nebo [<ContextStatic>].:Typy Byref nejsou v deklaraci otevÅ™enÃ©ho typu povolenÃ©.šExplicitnÃ­ deklarace typu pro konstruktory musÃ­ mÃ­t formÃ¡t ty1 * ... * tyN -> resTy. Je moÅ¾nÃ©, Å¾e vÃ½raz resTy bude potÅ™eba uzavÅ™Ã­t do zÃ¡vorek.NeplatnÃ½ vzorNToto nenÃ­ platnÃ½ literÃ¡lovÃ½ vÃ½raz. Atribut [<Literal>] se bude ignorovat.!NeplatnÃ¡ syntaxe ve vÃ½razu typuşTyp struktury, zÃ¡znamu nebo sjednocenÃ­ {0} explicitnÄ› implementuje rozhranÃ­ System.IComparable<_>. Pro typ je tÅ™eba pouÅ¾Ã­t atribut CustomComparison a mÄ›li byste takÃ© poskytnout konzistentnÃ­ implementaci neobecnÃ©ho rozhranÃ­ System.IComparable.›Typ struktura, zÃ¡znam nebo sjednocenÃ­ {0} implementuje explicitnÄ› rozhranÃ­ System.IComparable. Pro tento typ musÃ­te pouÅ¾Ã­t atribut CustomComparison.êTyp struktury, zÃ¡znamu nebo sjednocenÃ­ {0} explicitnÄ› implementuje rozhranÃ­ System.IEquatable<_>. PouÅ¾ijte pro typ atribut CustomEquality a poskytnÄ›te konzistentnÃ­ implementaci neobecnÃ©ho pÅ™epsÃ¡nÃ­ System.Object.Equals(obj).Typ struktura, zÃ¡znam nebo sjednocenÃ­ {0} implementuje explicitnÄ› rozhranÃ­ System.IStructuralComparable. PouÅ¾ijte pro tento typ atribut CustomComparison.›Typ struktura, zÃ¡znam nebo sjednocenÃ­ {0} implementuje explicitnÄ› rozhranÃ­ System.IStructuralEquatable. PouÅ¾ijte pro tento typ atribut CustomEquality.PTento vÃ½raz pouÅ¾Ã­vÃ¡ implicitnÃ­ pÅ™evod {0} pro pÅ™evod typu {1} na typ {2}.ÍTento vÃ½raz pouÅ¾Ã­vÃ¡ implicitnÃ­ pÅ™evod {0} pro pÅ™evod typu {1} na typ {2}. PÅ™eÄtÄ›te si tÃ©ma https://aka.ms/fsharp-implicit-convs. Toto upozornÄ›nÃ­ mÅ¯Å¾e bÃ½t vypnutÃ© pomocÃ­ '#nowarn \"3391\".:Za lomÃ­tkem (/) nÃ¡sleduje implicitnÃ­ vytvoÅ™enÃ­ mÃ­ry.SSyntaxe arr.[idx] je teÄ revidovÃ¡na na arr[idx]. Aktualizujte prosÃ­m svÅ¯j kÃ³d.ÍFunkce nebo Älen {0} se pouÅ¾Ã­vÃ¡ zpÅ¯sobem, kterÃ½ vyÅ¾aduje, aby se k jeho definici doplnily dalÅ¡Ã­ poznÃ¡mky typu. Je to kvÅ¯li zajiÅ¡tÄ›nÃ­ konzistence odvozenÃ½ch typÅ¯. OdvozenÃ¡ signatura je {1}.ÛToto je definice funkce, kterÃ¡ stÃ­nuje pÅ™Ã­pad sjednocenÃ­. Pokud je to to, co chcete, toto upozornÄ›nÃ­ ignorujte nebo potlaÄte. Pokud chcete, aby se jednÃ¡ o dekonstrukci pÅ™Ã­padu sjednocenÃ­, pÅ™idejte zÃ¡vorky.Deklarace inherit se nedÃ¡ pouÅ¾Ã­t u typÅ¯ rozhranÃ­. ZvaÅ¾te mÃ­sto toho moÅ¾nost implementovat rozhranÃ­ pomocÃ­ interface ... with ... end.Deklarace inherit mÃ¡ argumenty, ale nenÃ­ v typu s primÃ¡rnÃ­m konstruktorem. ZvaÅ¾te moÅ¾nost pÅ™idat do definice typu argumenty, tÅ™eba type X(args) = ...ŒTato deklarace inherit specifikuje zdÄ›dÄ›nÃ½ typ, ale ne argumenty. ZvaÅ¾te moÅ¾nost poskytnutÃ­ argumentÅ¯, tÅ™eba inherit BaseType(args).*ZdÄ›dÄ›nÃ¡ deklarace tady nenÃ­ povolenÃ¡./ZdÄ›dÄ›nÃ½ typ nenÃ­ typem objektovÃ©ho modelu.—Vlastnost init-only â€{0}â€œ nelze nastavit mimo inicializaÄnÃ­ kÃ³d. Zobrazit https://aka.ms/fsharp-assigning-values-to-properties-at-initializationAtribut InlineIfLambda je moÅ¾nÃ© pouÅ¾Ã­t pouze u parametrÅ¯ vloÅ¾enÃ½ch funkcÃ­ metod s typem funkce nebo typem delegÃ¡ta F#.­Tento Älen instance vyÅ¾aduje, aby parametr pÅ™edstavoval objekt, kterÃ½ se vyvolÃ¡vÃ¡. Upravte Älena tak, aby byl statickÃ½, nebo pouÅ¾ijte notaci member x.Member(args) =:Typy rozhranÃ­ a typy delegÃ¡tÅ¯ nemÅ¯Å¾ou obsahovat pole.,Typy rozhranÃ­ nemÅ¯Å¾ou bÃ½t zapeÄetÄ›nÃ©.mRozhranÃ­ zdÄ›dÄ›nÃ¡ jinÃ½mi rozhranÃ­mi by se mÄ›la deklarovat pomocÃ­ inherit ... a ne pomocÃ­ interface...²Neshoda v interpolovanÃ©m Å™etÄ›zci. InterpolovanÃ© Å™etÄ›zce nemÅ¯Å¾ou pouÅ¾Ã­vat specifikÃ¡tory formÃ¡tu %, pokud se kaÅ¾dÃ©mu z nich nezadÃ¡ nÄ›jakÃ½ vÃ½raz, napÅ™. %d{{1+1}}.6Za pouÅ¾itÃ­m into musÃ­ nÃ¡sledovat zbytek vÃ½poÄtu.>'{0}' is not a valid method name. Use a 'let' binding instead.1NeplatnÃ© zarovnÃ¡nÃ­ v interpolovanÃ©m Å™etÄ›zci3NeplatnÃ½ argument popisku parametrizovanÃ©ho vzoruNeplatnÃ© pÅ™iÅ™azenÃ­&Toto nenÃ­ platnÃ½ konstantnÃ­ vÃ½raz.NeplatnÃ© omezenÃ­”NeplatnÃ© omezenÃ­: Typ pouÅ¾itÃ½ pro toto omezenÃ­ je zapeÄetÄ›nÃ½. ZnamenÃ¡ to, Å¾e tomuto omezenÃ­ mÅ¯Å¾e vyhovovat maximÃ¡lnÄ› jedno Å™eÅ¡enÃ­.NeplatnÃ¡ deklarace4Specifikace delegÃ¡tÅ¯ musÃ­ mÃ­t notaci typ -> typ./OmezenÃ­ enum musÃ­ bÃ½t ve formÃ¡tu enum<typ>.0Toto nenÃ­ platnÃ¡ hodnota pro literÃ¡l vÃ½Ätu.:VnitÅ™nÃ­ chyba. NeplatnÃ½ index pro pole aktivnÃ­ho vzoru[OperÃ¡tor {0} se nedÃ¡ pÅ™edefinovat. ZvaÅ¾te moÅ¾nost pouÅ¾itÃ­ jinÃ©ho nÃ¡zvu operÃ¡toru.:NeÃºplnÃ½ vÃ½raz nebo neplatnÃ© pouÅ¾itÃ­ syntaxe indexeruNeplatnÃ¡ vloÅ¾enÃ¡ specifikaceFNeplatnÃ¡ deklarace Älena. Jeho jmÃ©no chybÃ­ nebo obsahuje zÃ¡vorky.›({0}) nenÃ­ vhodnÃ½ nÃ¡zev pro Älena. Pokud definujete statickÃ©ho Älena, kterÃ½ se mÃ¡ pouÅ¾Ã­t z jinÃ½ch jazykÅ¯ CLI, pouÅ¾ijte mÃ­sto toho nÃ¡zev {1}.KNeplatnÃ½ nÃ¡zev Älena. ÄŒlenovÃ© nemÅ¯Å¾ou mÃ­t nÃ¡zev .ctor nebo .cctor.†({0}) nenÃ­ vhodnÃ½ nÃ¡zev pro Älena, protoÅ¾e se mu v knihovnÄ› F# prostÅ™ednictvÃ­m pevnÃ½ch typÅ¯ pÅ™edÃ¡vÃ¡ standardnÃ­ definice.ğ({0}) nenÃ­ vhodnÃ½ nÃ¡zev pro Älena. Pokud chcete definovat sÃ©mantiku rovnosti pro typ, pÅ™epiÅ¡te Älena Object.Equals. Pokud definujete statickÃ©ho Älena, kterÃ½ se mÃ¡ pouÅ¾Ã­t z jinÃ½ch jazykÅ¯ CLI, pouÅ¾ijte mÃ­sto toho nÃ¡zev {1}.ş({0}) nenÃ­ vhodnÃ½ nÃ¡zev pro Älena. Pokud chcete definovat sÃ©mantiku porovnÃ¡nÃ­ pro typ, implementujte rozhranÃ­ System.IComparable. Pokud definujete statickÃ©ho Älena, kterÃ½ se mÃ¡ pouÅ¾Ã­t z jinÃ½ch jazykÅ¯ CLI, pouÅ¾ijte mÃ­sto toho nÃ¡zev {1}.KTato rekurzivnÃ­ vazba pouÅ¾Ã­vÃ¡ neplatnou kombinaci rekurzivnÃ­ch tvarÅ¯.NeplatnÃ½ nÃ¡zev moduluFNeplatnÃ½ nÃ¡zev oboru nÃ¡zvÅ¯, modulu, typu nebo pÅ™Ã­padu typu unionROmezenÃ­ new musÃ­ pÅ™ebÃ­rat jeden argument typu unit a vracet konstruovanÃ½ typ.ºKonstanty ÄÃ­selnÃ½ch literÃ¡lÅ¯, kterÃ© nejsou primitivnÃ­, se nedajÃ­ pouÅ¾Ã­t u porovnÃ¡nÃ­ vzorÅ¯, protoÅ¾e mÅ¯Å¾ou bÃ½t bÄ›hem pouÅ¾itÃ­ modulu NumericLiteral mapovanÃ© na vÃ­ce rÅ¯znÃ½ch typÅ¯. ZvaÅ¾te moÅ¾nost nahrazenÃ­ promÄ›nnou a na konci klauzule porovnÃ¡nÃ­ pouÅ¾ijte when <promÄ›nnÃ¡> = <konstanta>.ŞToto nenÃ­ platnÃ½ vÃ½raz konstruktoru objektu. ExplicitnÃ­ konstruktor objektu musÃ­ buÄ volat alternativnÃ­ konstruktor, nebo inicializovat vÅ¡echna pole objektu a specifikovat volÃ¡nÃ­ konstruktoru nadÅ™azenÃ© tÅ™Ã­dy.›NeplatnÃ½ objektovÃ½ vÃ½raz. U objektÅ¯ bez pÅ™epsÃ¡nÃ­ nebo rozhranÃ­ by se mÄ›l vÃ½raz formulovat pomocÃ­ notace new Type(args) bez sloÅ¾enÃ½ch zÃ¡vorek.0NeplatnÃ½ vÃ½raz objektu, poÅ™adÃ­ nebo zÃ¡znamu]OperÃ¡tor {0} se nedoporuÄuje pÅ™edefinovÃ¡vat. ZvaÅ¾te pouÅ¾itÃ­ jinÃ©ho nÃ¡zvu operÃ¡toru.œOperÃ¡tor {0} se nedoporuÄuje pÅ™edefinovÃ¡vat. Pokud chcete definovat sÃ©mantiku rovnosti pro typ, pÅ™epiÅ¡te Älena Object.Equals v definici tohoto typu.ÁOperÃ¡tor {0} se nedoporuÄuje pÅ™edefinovÃ¡vat. Pokud chcete definovat pÅ™etÃ­Å¾enou sÃ©mantiku porovnÃ¡nÃ­ pro urÄitÃ½ typ, implementujte rozhranÃ­ System.IComparable v definici tohoto typu.8NeplatnÃ© nepovinnÃ© pÅ™iÅ™azenÃ­ k vlastnosti nebo poliToto nenÃ­ platnÃ½ vzor.ØTato vlastnost nemÃ¡ platnÃ½ typ. Vlastnosti, kterÃ© pÅ™ebÃ­rajÃ­ vÃ­ce argumentÅ¯ indexeru, by mÄ›ly mÃ­t typy s notacÃ­ ty1 * ty2 -> ty3. Vlastnosti, kterÃ© vracÃ­ funkce, by mÄ›ly mÃ­t typy s notacÃ­ (ty1 -> ty2).NeplatnÃ¡ konstrukce zÃ¡znamukNeplatnÃ¡ relace spojenÃ­ v {0}. OÄekÃ¡vanÃ¡ notace je vÃ½raz <op> vÃ½raz, kde <op> je =, =?, ?= nebo ?=?.IKonstruktor {0} je moÅ¾nÃ© pouÅ¾Ã­t jenom v platnÃ©m obnovitelnÃ©m kÃ³du.ÊNeplatnÃ© omezenÃ­. PlatnÃ© formulÃ¡Å™e omezenÃ­ zahrnujÃ­ "T :> ISomeInterface\" pro omezenÃ­ rozhranÃ­ a \"SomeConstrainingType<'T>\" pro vlastnÃ­ omezenÃ­. Viz https://aka.ms/fsharp-type-constraints.hNeplatnÃ½ vÃ½raz zÃ¡znamu, poÅ™adÃ­ nebo vÃ½poÄtu. VÃ½razy poÅ™adÃ­ by mÄ›ly mÃ­t notaci seq {{ ... }}.#NeplatnÃ¡ signatura pro Älena sadymPouÅ¾itÃ­ [<Struct>] u hodnot, funkcÃ­ a metod je povolenÃ© jenom u ÄÃ¡steÄnÃ½ch aktivnÃ­ch definic vzorÅ¯.‘PoÄet argumentÅ¯ typu se neshodoval: poÄet pÅ™edanÃ½ch je {0}, ale poÄet oÄekÃ¡vanÃ½ch je {1}. MÅ¯Å¾e to souviset s dÅ™Ã­v hlÃ¡Å¡enou chybou. Argumenty typu tady nejde zadat.NeplatnÃ© rozÅ¡Ã­Å™enÃ­ typudLiterÃ¡lovÃ½ vÃ½Äet musÃ­ bÃ½t typu int, uint, int16, uint16, int64, uint64, byte, sbyte nebo char.MMÄ›rnÃ© jednotky se podporujÃ­ jen u typÅ¯ float, float32, decimal a integer.MÄ›rnÃ© jednotky se nedajÃ­ pouÅ¾Ã­t jako argumenty pÅ™edpony typu. PÅ™epiÅ¡te je na argumenty pÅ™Ã­pony v lomenÃ½ch zÃ¡vorkÃ¡ch.;Vazby use! musÃ­ mÃ­t formÃ¡t use! <promÄ›nnÃ¡> = <vÃ½raz>. use! se nedÃ¡ kombinovat s and!.=Vazby use musÃ­ bÃ½t ve formÃ¡tu use <promÄ›nnÃ¡> = <vÃ½raz>.šPÅ™Ã­znak atributu UseNullAsTrueValue se dÃ¡ pouÅ¾Ã­t jenom s typy sjednocenÃ­, kterÃ© majÃ­ jeden prÃ¡zdnÃ½ pÅ™Ã­pad a aspoÅˆ jeden neprÃ¡zdnÃ½ pÅ™Ã­pad.cNeplatnÃ© pouÅ¾itÃ­ konstruktoru delegÃ¡ta. PouÅ¾ijte syntaxi new Type(args) nebo jenom Type(args)."NeplatnÃ© pouÅ¾itÃ­ typu rozhranÃ­9NeplatnÃ© pouÅ¾itÃ­ zpÄ›tnÃ©ho indexu ve vÃ½razu seznamu.NeplatnÃ© pouÅ¾itÃ­ nÃ¡zvu typujTyp oznaÄenÃ½ IsReadOnly musÃ­ bÃ½t takÃ© strukturou. ZvaÅ¾te moÅ¾nost pÅ™idat k typu atribut [<Struct>]./V dotazech musÃ­ {0} pouÅ¾Ã­t jednoduchÃ½ vzor.SDruh typu urÄenÃ©ho jeho atributy se neshoduje s druhem odvozenÃ½m jeho definicÃ­.‘Tento kÃ³d je mÃ­Åˆ obecnÃ½, neÅ¾ poÅ¾adujÃ­ jeho poznÃ¡mky, protoÅ¾e promÄ›nnÃ¡ explicitnÃ­ho typu {0} se nedÃ¡ zobecnit. KÃ³d se omezil na {1}.–Tato definice se dÃ¡ pouÅ¾Ã­t jenom u typu s primÃ¡rnÃ­m konstruktorem. ZvaÅ¾te moÅ¾nost pÅ™idat do definice typu argumenty, tÅ™eba type X(args) = ...•Tento vÃ½raz seznamu pÅ™ekraÄuje maximÃ¡lnÃ­ velikost literÃ¡lÅ¯ seznamu. PouÅ¾ijte pole pro rozsÃ¡hlejÅ¡Ã­ literÃ¡ly a volejte metodu Array.ToList.ñSyntaxe [expr1][expr2] je pÅ™i pouÅ¾itÃ­ jako argument nejednoznaÄnÃ¡. VÃ­ce informacÃ­: https://aka.ms/fsharp-index-notation. Pokud plÃ¡nujete indexovÃ¡nÃ­ nebo vytvÃ¡Å™enÃ­ Å™ezÅ¯, musÃ­te pouÅ¾Ã­t (expr1).[expr2] na pozici argumentu. Pokud volÃ¡te funkci s vÃ­cenÃ¡sobnÃ½mi curryfikovanÃ½mi argumenty, pÅ™idejte mezi nÄ› mezeru, tÅ™eba someFunction [expr1] [expr2].¨Syntaxe [expr1][expr2] je teÄ vyhrazena pro indexovÃ¡nÃ­ a je pÅ™i pouÅ¾itÃ­ jako argument nejednoznaÄnÃ¡. VÃ­ce informacÃ­: https://aka.ms/fsharp-index-notation. Pokud volÃ¡te funkci s vÃ­cenÃ¡sobnÃ½mi curryfikovanÃ½mi argumenty, pÅ™idejte mezi nÄ› mezeru, tÅ™eba someFunction [expr1] [expr2].RDeklarace [<Literal>] nemÅ¯Å¾e pouÅ¾Ã­vat aktivnÃ­ vzor jako svÅ¯j identifikÃ¡tor.zPokud se definuje takÃ© konstantnÃ­ hodnota, napÅ™Ã­klad val x: int = 1, mÅ¯Å¾e bÃ½t deklaracÃ­ jenom atribut [<Literal>].2Hodnota literÃ¡lu nemÅ¯Å¾e mÃ­t oznaÄenÃ­ inline.3Hodnota literÃ¡lu nemÅ¯Å¾e mÃ­t oznaÄenÃ­ mutable.2Hodnota literÃ¡lu nemÅ¯Å¾e mÃ­t obecnÃ© parametry.3V tomto vzoru literÃ¡lu se nedajÃ­ zadat argumenty.QHodnota se nedÃ¡ pÅ™iÅ™adit k jinÃ© hodnotÄ›, kterÃ¡ je oznaÄenÃ¡ jako literÃ¡l.<K hodnotÄ› oznaÄenÃ© jako literÃ¡l se {0} nedÃ¡ pÅ™iÅ™adit. Vazby lokÃ¡lnÃ­ tÅ™Ã­dy nemÅ¯Å¾ou mÃ­t oznaÄenÃ­ inline. ZvaÅ¾te moÅ¾nost rozÅ¡Ã­Å™enÃ­ definice mimo tÅ™Ã­du. V opaÄnÃ©m pÅ™Ã­padÄ› neoznaÄujte jako inline.+Toto vyhledÃ¡vÃ¡nÃ­ se tady nedÃ¡ pouÅ¾Ã­t.-VÃ½razy match se nedajÃ­ v dotazech pouÅ¾Ã­t.4Deklarace mÃ­ry mÅ¯Å¾ou mÃ­t jenom statickÃ© Äleny.SDeklarace mÃ­ry mÅ¯Å¾ou mÃ­t jenom statickÃ© Äleny: Konstruktory dostupnÃ© nejsou.-Definice mÃ­ry nemÅ¯Å¾ou mÃ­t parametry typu.3Vazba ÄlenskÃ© i lokÃ¡lnÃ­ tÅ™Ã­dy mÃ¡ nÃ¡zev {0}.|Typ {0} obsahuje Älen {1}, ale nenÃ­ to virtuÃ¡lnÃ­ nebo abstraktnÃ­ metoda, kterÃ¡ by se dala pÅ™epsat nebo implementovat.'Tento Älen nenÃ­ dostateÄnÄ› obecnÃ½.DSynMemberKind.PropertyGetSet se oÄekÃ¡vÃ¡ jen ve stromech analÃ½zy.5Tento Älen nenÃ­ v implementaci rozhranÃ­ povolenÃ½.‰ÄŒlenovÃ© rozÅ¡Ã­Å™enÃ­ nemÅ¯Å¾ou poskytovat pÅ™etÃ­Å¾enÃ­ operÃ¡torÅ¯. ZvaÅ¾te moÅ¾nost definovat mÃ­sto toho operÃ¡tor v definici typu.;RozhranÃ­ nemÅ¯Å¾ou obsahovat definice pÅ™epsÃ¡nÃ­ ÄlenÅ¯.~ÄŒlen {0} se pouÅ¾Ã­vÃ¡ neplatnÃ½m zpÅ¯sobem. PouÅ¾itÃ­ {1} se odvozuje pÅ™ed definicÃ­ {2}. To je neplatnÃ½ dopÅ™ednÃ½ odkaz.šÄŒlenovÃ©, kteÅ™Ã­ rozÅ¡iÅ™ujÃ­ typy rozhranÃ­, delegÃ¡ta nebo vÃ½Ätu, musÃ­ bÃ½t umÃ­stÄ›nÃ© v modulu oddÄ›lenÄ› od definice typu. Tento modul musÃ­ mÃ­t buÄ atribut AutoOpen, nebo musÃ­ bÃ½t otevÅ™enÃ½ explicitnÄ› klientskÃ½m kÃ³dem, aby se Älen rozÅ¡Ã­Å™enÃ­ vloÅ¾il do oboru.4Metoda {0} nenÃ­ na tomto mÃ­stÄ› v kÃ³du dostupnÃ¡.APÅ™epsÃ¡nÃ­ metod a implementace rozhranÃ­ tady nejsou povolenÃ©.IVyÅ¾aduje se operace vlastnÃ­ho dotazu pro {0}, kterÃ¡ ale nenÃ­ zadanÃ¡.<The following required properties have to be initialized:{0}zVe skupinÄ› rekurzivnÃ­ch deklaracÃ­ se musÃ­ zkratky modulu nachÃ¡zet za deklaracemi open a pÅ™ed ostatnÃ­mi deklaracemi.JCesta {0} je obor nÃ¡zvÅ¯. Zkratka modulu nemÅ¯Å¾e zkracovat obor nÃ¡zvÅ¯.ÈTato deklarace otevÃ­rÃ¡ modul {0}, kterÃ½ mÃ¡ oznaÄenÃ­ RequireQualifiedAccess. Upravte kÃ³d tak, aby mÃ­sto toho pouÅ¾Ã­val kvalifikovanÃ© odkazy na elementy modulu, tÅ™eba mÃ­sto map pouÅ¾ijte List.map. Touto zmÄ›nou zajistÃ­te, Å¾e bude kÃ³d funkÄnÃ­ i v pÅ™Ã­padÄ›, Å¾e se budou do knihoven pÅ™idÃ¡vat novÃ© konstruktory.JPole â€{0}â€œ se v tomto vÃ½razu nebo vzoru zÃ¡znamu zobrazuje vÃ­cekrÃ¡tÆBylo nalezeno vÃ­ce shod typÅ¯:\n{0}\nTyp â€{1}â€œ byl pouÅ¾it. Vzhledem k pÅ™ekrÃ½vajÃ­cÃ­m se nÃ¡zvÅ¯m polÃ­\n{2}\nzvaÅ¾te pouÅ¾itÃ­ poznÃ¡mek typu nebo zmÄ›Åˆte poÅ™adÃ­ otevÅ™enÃ½ch pÅ™Ã­kazÅ¯.APro tento identifikÃ¡tor jste zadali vÃ­c atributÅ¯ viditelnosti.¡Pro tento identifikÃ¡tor jste zadali vÃ­c atributÅ¯ viditelnosti. Vazby let ve tÅ™Ã­dÃ¡ch jsou vÅ¾dycky privÃ¡tnÃ­, stejnÄ› jako kterÃ¡koli vazba let ve vÃ½razu.<OznaÄenÃ­ inline se u promÄ›nlivÃ½ch hodnot pouÅ¾Ã­t nedÃ¡.6PromÄ›nlivÃ© hodnoty nemÅ¯Å¾ou mÃ­t obecnÃ© parametry.SZÃ¡pis promÄ›nlivÃ½ch hodnot funkcÃ­ by mÄ›l bÃ½t let mutable f = (fun arg -> ...).QPojmenovanÃ© argumenty musÃ­ bÃ½t umÃ­stÄ›nÃ© aÅ¾ za vÅ¡emi ostatnÃ­mi argumenty.(NÃ¡zev {0} nemÃ¡ vazbu v kontextu vzoru.x{0} je aktivnÃ­ vzorek a nenÃ­ moÅ¾nÃ© s nÃ­m zachÃ¡zet jako s rozliÅ¡enÃ½m pÅ™Ã­padem typu union s pojmenovanÃ½mi poli.XPojmenovanÃ½ argument {0} neodpovÃ­dÃ¡ Å¾Ã¡dnÃ©mu argumentu nebo mÄ›nitelnÃ© vlastnosti.FPojmenovanÃ© argumenty nejde pÅ™edÃ¡vat volÃ¡nÃ­m vlastnostÃ­ ÄlenÅ¯.1{0} se dÃ¡ pouÅ¾Ã­t jenom u pojmenovanÃ½ch typÅ¯.ŞObory nÃ¡zvÅ¯ nemÅ¯Å¾ou obsahovat Äleny rozÅ¡Ã­Å™enÃ­ (to jde jenom ve stejnÃ©m souboru a skupinÄ› deklaracÃ­ oboru nÃ¡zvÅ¯, kde je definovanÃ½ i typ). K uloÅ¾enÃ­ deklaracÃ­ ÄlenÅ¯ rozÅ¡Ã­Å™enÃ­ mÅ¯Å¾ete pouÅ¾Ã­t modul.aObory nÃ¡zvÅ¯ nemÅ¯Å¾ou obsahovat hodnoty. K uloÅ¾enÃ­ deklaracÃ­ hodnot mÅ¯Å¾ete pouÅ¾Ã­t modul.xU typÅ¯ rozhranÃ­ se new pouÅ¾Ã­t nedÃ¡. ZvaÅ¾te moÅ¾nost pouÅ¾Ã­t mÃ­sto toho objektovÃ½ vÃ½raz {{ new ... with ... }}.|Tento novÃ½ Älen skrÃ½vÃ¡ abstraktnÃ­ Älen {0}. ZmÄ›Åˆte jeho nÃ¡zev nebo mÃ­sto toho pouÅ¾ijte klÃ­ÄovÃ© slovo override.ÙTento novÃ½ Älen skrÃ½vÃ¡ po vymazÃ¡nÃ­ Å™azenÃ½ch kolekcÃ­ ÄlenÅ¯, funkcÃ­, mÄ›rnÃ½ch jednotek a poskytnutÃ½ch typÅ¯ abstraktnÃ­ Älen {0}. ZmÄ›Åˆte jeho nÃ¡zev nebo mÃ­sto toho pouÅ¾ijte klÃ­ÄovÃ© slovo override.)U new se musÃ­ pouÅ¾Ã­t pojmenovanÃ½ typ.CKlÃ­ÄovÃ© slovo new se dÃ¡ pouÅ¾Ã­t jenom s konstruktory objektÅ¯.sÄŒlen {0} neodpovÃ­dÃ¡ Å¾Ã¡dnÃ© abstraktnÃ­ ani virtuÃ¡lnÃ­ metodÄ›, kterÃ¡ by se dala pÅ™epsat nebo implementovat.<PÅ™i vytvÃ¡Å™enÃ­ hodnoty zÃ¡znamu nejde zadÃ¡vat argumenty.öTyp struktura, zÃ¡znam nebo sjednocenÃ­ {0} se nedÃ¡ strukturÃ¡lnÄ› porovnÃ¡vat, protoÅ¾e parametr typu {1} nevyhovuje omezenÃ­ comparison. ZvaÅ¾te moÅ¾nost pÅ™idat k typu {2} atribut NoComparisonto: tak bude jasnÃ©, Å¾e se typ nedÃ¡ porovnÃ¡vat.ìTyp struktura, zÃ¡znam nebo sjednocenÃ­ {0} se nedÃ¡ strukturÃ¡lnÄ› porovnÃ¡vat, protoÅ¾e typ {1} nevyhovuje omezenÃ­ comparison. ZvaÅ¾te moÅ¾nost pÅ™idat k typu {2} atribut NoComparisonto: tak bude jasnÃ©, Å¾e se typ nedÃ¡ porovnÃ¡vat.mPouÅ¾itÃ­ metod s atributem NoEagerConstraintApplicationAttribute vyÅ¾aduje /langversion:6.0 nebo novÄ›jÅ¡Ã­.ıTyp struktura, zÃ¡znam nebo sjednocenÃ­ {0} nepodporuje strukturÃ¡lnÃ­ rovnost, protoÅ¾e parametr typu {1} nevyhovuje omezenÃ­ equality. ZvaÅ¾te moÅ¾nost pÅ™idat k typu {2} atribut NoEquality: tak bude jasnÃ©, Å¾e typ nepodporuje strukturÃ¡lnÃ­ rovnost.óTyp struktura, zÃ¡znam nebo sjednocenÃ­ {0} nepodporuje strukturÃ¡lnÃ­ rovnost, protoÅ¾e typ {1} nevyhovuje omezenÃ­ equality. ZvaÅ¾te moÅ¾nost pÅ™idat k typu {2} atribut NoEquality: tak bude jasnÃ©, Å¾e typ nepodporuje strukturÃ¡lnÃ­ rovnost.lV dotazech pouÅ¾ijte notaci for x in n ... m do ..., kterÃ¡ zajistÃ­ rozsah napÅ™Ã­Ä celoÄÃ­selnÃ½mi typy.CImplementace rozhranÃ­ se s vÃ½razy konstrukcÃ­ nedajÃ­ pÅ™edÃ¡vat.eNenaÅ¡el se Å¾Ã¡dnÃ½ abstraktnÃ­ Älen nebo Älen rozhranÃ­, kterÃ½ by odpovÃ­dal tomuto pÅ™epsÃ¡nÃ­.UNenaÅ¡la se Å¾Ã¡dnÃ¡ abstraktnÃ­ vlastnost, kterÃ¡ by odpovÃ­dala tomuto pÅ™epsÃ¡nÃ­.ZNenaÅ¡la se Å¾Ã¡dnÃ½ statickÃ½ abstraktnÃ­ Älen, kterÃ½ by odpovÃ­dal tomuto pÅ™epsÃ¡nÃ­._NenaÅ¡la se Å¾Ã¡dnÃ¡ statickÃ¡ abstraktnÃ­ vlastnost, kterÃ¡ by odpovÃ­dala tomuto pÅ™epsÃ¡nÃ­.0VÃ½raz try/finally se nedÃ¡ pouÅ¾Ã­t v dotazech.(VÃ½raz while se v dotazu pouÅ¾Ã­t nedÃ¡.=Tato hodnota nenÃ­ literÃ¡lovÃ¡ a nedÃ¡ se ve vzoru pouÅ¾Ã­t.qTato definice let se v dotazu pouÅ¾Ã­t nedÃ¡. V dotazech je moÅ¾nÃ© pouÅ¾Ã­t jenom definice jednoduchÃ½ch hodnot.ÂPouÅ¾ili jste obecnÃ½ Älen {0} v neuniformnÃ­ instanci pÅ™ed tÃ­mto mÃ­stem v programu. ZvaÅ¾te moÅ¾nost zmÄ›nit poÅ™adÃ­ ÄlenÅ¯ tak, aby se tento uvedl jako prvnÃ­. PÅ™Ã­padnÄ› specifikujte ÃºplnÃ½ typ Älena explicitnÄ›, vÄetnÄ› typÅ¯ argumentÅ¯, nÃ¡vratovÃ©ho typu a vÅ¡ech dalÅ¡Ã­ch obecnÃ½ch parametrÅ¯ a omezenÃ­.YU nenulovÃ½ch konstant nemÅ¯Å¾ou bÃ½t obecnÃ© jednotky. ObecnÃ½ nulovÃ½ zÃ¡pis je 0.0<_>.¤Tento vÃ½raz podporuje indexovÃ¡nÃ­, tÅ™eba expr.[index]. Syntaxe expr[index] vyÅ¾aduje /langversion:preview. VÃ­ce informacÃ­: https://aka.ms/fsharp-index-notation¢Tato hodnota podporuje indexovÃ¡nÃ­, tÅ™eba {0}.[index]. Syntaxe {1}[index] vyÅ¾aduje /langversion:preview. VÃ­ce informacÃ­: https://aka.ms/fsharp-index-notationNenÃ­ vÃ½jimka.6Tento vÃ½raz nenÃ­ funkce a nepodporuje zÃ¡pis indexu.5Hodnota {0} nenÃ­ funkce a nepodporuje zÃ¡pis indexu.…Tento kÃ³d nenÃ­ dostateÄnÄ› obecnÃ½. PromÄ›nnÃ¡ typu {0} se nedÃ¡ zobecnit, protoÅ¾e by se tak dostala mimo svÅ¯j definiÄnÃ­ obor.,Toto nenÃ­ platnÃ½ nÃ¡zev pÅ™Ã­padu vÃ½Ätu.£With nullness checking enabled, overrides of .ToString() method must return a non-nullable string. You can handle potential nulls via the built-in string function.sThe 'nullness checking' language feature is not enabled. This use of a nullness checking construct will be ignored.•Tento ÄÃ­selnÃ½ literÃ¡l vyÅ¾aduje, aby modul {0} definujÃ­cÃ­ funkce FromZero, FromOne, FromInt32, FromInt64 a FromString byl v definiÄnÃ­m oboru.bVÃ½razy konstruktoru objektu se dajÃ­ pouÅ¾Ã­t jenom k implementaci konstruktorÅ¯ v typech tÅ™Ã­d.ŠVÃ½razy konstruktoru objektu (tÅ™eba vÃ½razy zÃ¡znamu se specifikacÃ­ dÄ›diÄnosti) se dajÃ­ pouÅ¾Ã­t jenom k implementaci konstruktorÅ¯ v typech objektovÃ©ho modelu. K vytvoÅ™enÃ­ instancÃ­ typÅ¯ objektovÃ©ho modelu mimo konstruktory pouÅ¾ijte new ObjectType(args).'Konstruktor objektu vyÅ¾aduje argument.=RozhranÃ­ nemÅ¯Å¾ou obsahovat definice konstruktorÅ¯ objektu.QVolÃ¡nÃ­ konstruktorÅ¯ objektu u parametrÅ¯ typu se nedajÃ­ pÅ™edÃ¡vat argumenty.ŸTato notace objektovÃ©ho vÃ½razu se v F# nepouÅ¾Ã­vÃ¡. K definovÃ¡nÃ­ implementacÃ­ ÄlenÅ¯ v objektovÃ½ch vÃ½razech pouÅ¾ijte member this.MemberName ... = ...gV objektovÃ½ch vÃ½razech se dajÃ­ specifikovat jenom pÅ™epsÃ¡nÃ­ abstraktnÃ­ch a virtuÃ¡lnÃ­ch ÄlenÅ¯.¨OperÃ¡tor expr.[idx] se pouÅ¾Ã­vÃ¡ u objektu neurÄitÃ©ho typu zaloÅ¾enÃ©ho na informacÃ­ch pÅ™ed tÃ­mto mÃ­stem v programu. ZvaÅ¾te pÅ™idÃ¡nÃ­ dalÅ¡Ã­ch omezenÃ­ typu.—Objekty se musÃ­ inicializovat pomocÃ­ vÃ½razu konstruktoru objektu, kterÃ½ volÃ¡ zdÄ›dÄ›nÃ½ konstruktor objektu a pÅ™iÅ™azuje hodnoty ke vÅ¡em polÃ­m.8Atribut AbstractClass se dÃ¡ pÅ™edÃ¡vat jenom tÅ™Ã­dÃ¡m.,OznaÄenÃ­ inline mÅ¯Å¾ou mÃ­t jenom funkce.pPromÄ›nlivÃ© vazby let nemÅ¯Å¾ou bÃ½t rekurzivnÃ­ ani definovanÃ© v rekurzivnÃ­ch modulech nebo oborech nÃ¡zvÅ¯.WVe vÃ½razech konstrukcÃ­ se dajÃ­ pouÅ¾Ã­t jenom jednoduchÃ© vazby s notacÃ­ id = expr.UVazbu v konstruktorech let rec mÅ¯Å¾ou mÃ­t jenom vzory s jednoduchÃ½mi promÄ›nnÃ½mi.dAtribut StructLayout se dÃ¡ pÅ™edÃ¡vat jenom strukturÃ¡m a tÅ™Ã­dÃ¡m bez primÃ¡rnÃ­ch konstruktorÅ¯.VAtribut Measure se dÃ¡ pÅ™edÃ¡vat jenom typÅ¯m, kterÃ© pÅ™edstavujÃ­ mÄ›rnÃ© jednotky.XVe skupinÄ› rekurzivnÃ­ch deklaracÃ­ musÃ­ bÃ½t deklarace open v kaÅ¾dÃ©m modulu prvnÃ­.°Tato deklarace otevÃ­rÃ¡ obor nÃ¡zvÅ¯ nebo modul {0} prostÅ™ednictvÃ­m ÄÃ¡steÄnÄ› kvalifikovanÃ© cesty. Upravte tento kÃ³d tak, aby pouÅ¾Ã­val Ãºplnou cestu oboru nÃ¡zvÅ¯. Touto zmÄ›nou zajistÃ­te, Å¾e bude kÃ³d funkÄnÃ­ i v pÅ™Ã­padÄ›, Å¾e se budou do knihoven F# a CLI pÅ™idÃ¡vat novÃ© konstruktory.<OperÃ¡tor {0} nepodporuje pouÅ¾itÃ­ klÃ­ÄovÃ©ho slova into.*NeplatnÃ¡ syntaxe pro {0}. PouÅ¾itÃ­: {1}.,Po {0} musÃ­ nÃ¡sledovat in. PouÅ¾itÃ­: {1}.oNepovinnÃ© argumenty musÃ­ bÃ½t uvedenÃ© na konci seznamu argumentÅ¯, tj. aÅ¾ po vÅ¡ech povinnÃ½ch argumentech.9NepovinnÃ© argumenty jsou povolenÃ© jenom u ÄlenÅ¯ typu.@NepovinnÃ© argumenty se u vlastnÃ­ch atributÅ¯ pouÅ¾Ã­t nedajÃ­.ëSyntaxe expr1[expr2] je pÅ™i pouÅ¾itÃ­ jako argument nejednoznaÄnÃ¡. VÃ­ce informacÃ­: https://aka.ms/fsharp-index-notation. Pokud plÃ¡nujete indexovÃ¡nÃ­ nebo vytvÃ¡Å™enÃ­ Å™ezÅ¯, musÃ­te pouÅ¾Ã­t expr1.[expr2] na pozici argumentu. Pokud volÃ¡te funkci s vÃ­cenÃ¡sobnÃ½mi curryfikovanÃ½mi argumenty, pÅ™idejte mezi nÄ› mezeru, tÅ™eba someFunction expr1 [expr2].¤Syntaxe expr1[expr2] je teÄ vyhrazena pro indexovÃ¡nÃ­ a je pÅ™i pouÅ¾itÃ­ jako argument nejednoznaÄnÃ¡. VÃ­ce informacÃ­: https://aka.ms/fsharp-index-notation. Pokud volÃ¡te funkci s vÃ­cenÃ¡sobnÃ½mi curryfikovanÃ½mi argumenty, pÅ™idejte mezi nÄ› mezeru, tÅ™eba someFunction expr1 [expr2].µMinimÃ¡lnÄ› jedno pÅ™etÃ­Å¾enÃ­ tÃ©to metody mÃ¡ curryfikovanÃ© argumenty. ZvaÅ¾te Ãºpravu nÃ¡vrhu tÄ›chto ÄlenÅ¯ tak, aby pÅ™ebÃ­raly argumenty v podobÄ› Å™azenÃ© kolekce ÄlenÅ¯.œToto pÅ™epsÃ¡nÃ­ pÅ™ebÃ­rÃ¡ jinÃ½ poÄet argumentÅ¯ vzhledem k odpovÃ­dajÃ­cÃ­mu abstraktnÃ­mu Älenovi. NaÅ¡li se nÃ¡sledujÃ­cÃ­ abstraktnÃ­ ÄlenovÃ©: {0}ŠToto pÅ™epsÃ¡nÃ­ pÅ™ebÃ­rÃ¡ Å™azenou kolekci ÄlenÅ¯ mÃ­sto vÃ­ce argumentÅ¯. Zkuste do definice metody pÅ™idat dalÅ¡Ã­ vrstvu zÃ¡vorek, napÅ™. member _. Foo((x, y)) nebo odeberte zÃ¡vorky v deklaraci abstraktnÃ­ metody (napÅ™. 'abstract member Foo: 'a * 'b -> 'c').VModifikÃ¡tory dostupnosti nejsou u implementacÃ­ rozhranÃ­ nebo pÅ™epsÃ¡nÃ­ povolenÃ©.zPÅ™i pÅ™episovÃ¡nÃ­ obecnÃ© abstraktnÃ­ metody musÃ­te explicitnÄ› deklarovat buÄ vÅ¡echny, nebo Å¾Ã¡dnÃ© parametry typu.ğParametr {0} je odvozenÃ½ jako parametr typu byref. ParametrÅ¯m typu byref se musÃ­ pÅ™edÃ¡vat explicitnÃ­ anotace typu, tÅ™eba x1: byref<int>. V pÅ™Ã­padÄ› jejÃ­ho pouÅ¾itÃ­ se k parametru typu byref pÅ™istoupÃ­ implicitnÄ› pÅ™es ukazatel.LParametr s atributy vyÅ¾aduje takÃ© nÃ¡zev, tÅ™eba [<Atribut>] NÃ¡zev : Typ.ñSyntaxe (expr1)[expr2] je pÅ™i pouÅ¾itÃ­ jako argument nejednoznaÄnÃ¡. VÃ­ce informacÃ­: https://aka.ms/fsharp-index-notation. Pokud plÃ¡nujete indexovÃ¡nÃ­ nebo vytvÃ¡Å™enÃ­ Å™ezÅ¯, musÃ­te pouÅ¾Ã­t (expr1).[expr2] na pozici argumentu. Pokud volÃ¡te funkci s vÃ­cenÃ¡sobnÃ½mi curryfikovanÃ½mi argumenty, pÅ™idejte mezi nÄ› mezeru, tÅ™eba someFunction (expr1) [expr2].©Syntaxe (expr1)[expr2] je teÄ pro indexovÃ¡nÃ­ vyhrazenÃ¡ a je pÅ™i pouÅ¾itÃ­ jako argument nejednoznaÄnÃ¡. VÃ­ce informacÃ­: https://aka.ms/fsharp-index-notation. Pokud volÃ¡te funkci s vÃ­cenÃ¡sobnÃ½mi curryfikovanÃ½mi argumenty, pÅ™idejte mezi nÄ› mezeru, tÅ™eba someFunction (expr1) [expr2].ƒMulti-case partial active patterns are not supported. Consider using a single-case partial active pattern or a full active pattern.LValue known to be without null passed to a function meant for nullables: {0}1You can remove this |Null|NonNull| pattern usage.1You can remove this |NonNullQuick| pattern usage.hYou can create 'Some value' directly instead of 'ofObj', or consider not using an option for this value.mYou can create 'ValueSome value' directly instead of 'ofObj', or consider not using a voption for this value.(You can remove this `nonNull` assertion.±Typy System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate a System.Array se v objektovÃ©m vÃ½razu nebo ve tÅ™Ã­dÄ› objektu nedajÃ­ pouÅ¾Ã­t jako nadÅ™azenÃ©.!Tato vlastnost se nedÃ¡ nastavit. Vlastnost {0} se nedÃ¡ nastavit."Vlastnost {0} se nedÃ¡ pÅ™eÄÃ­st.Vlastnost {0} nenÃ­ statickÃ¡.Vlastnost {0} je statickÃ¡.GTato vlastnost nebo pole se u tohoto typu vlastnÃ­ho atributu nenaÅ¡la.bVlastnost nemÅ¯Å¾e mÃ­t explicitnÃ­ parametry typu. ZvaÅ¾te mÃ­sto toho moÅ¾nost pouÅ¾itÃ­ metody.ZKlÃ­ÄovÃ© slovo rec je v tomto modulu odvozenÃ© od vnÄ›jÅ¡Ã­ deklarace rec a ignoruje se.6Tento zÃ¡znam obsahuje pole z nekonzistentnÃ­ch typÅ¯.WTypy zÃ¡znam, sjednocenÃ­, zkratka a struktura nemÅ¯Å¾ou mÃ­t atribut AllowNullLiteral.rRekurzivnÃ­ vazby, kterÃ© obsahujÃ­ specifikace ÄlenÅ¯, se dajÃ­ pouÅ¾Ã­t jenom jako pÅ™Ã­mÃ© rozÅ¡Ã­Å™enÃ­ typu.ŸSignatura reprezentaci tohoto typu skrÃ½vÃ¡. Charakteristiku typu je potÅ™eba urÄit pomocÃ­ atributu, jako je tÅ™eba [<Sealed>], [<Class>] nebo [<Interface>].[Argumenty mÅ¯Å¾ou pÅ™ebÃ­rat jenom aktivnÃ­ vzory, kterÃ© vracejÃ­ prÃ¡vÄ› jeden vÃ½sledek.rTento Å™Ã­dicÃ­ konstruktor se dÃ¡ pouÅ¾Ã­t jenom v pÅ™Ã­padÄ›, Å¾e tvÅ¯rce vÃ½razu vÃ½poÄtu definuje metodu {0}.»Konstrukt â€let! ... and! ...â€œ se dÃ¡ pouÅ¾Ã­t jen v pÅ™Ã­padÄ›, Å¾e tvÅ¯rce vÃ½poÄetnÃ­ch vÃ½razÅ¯ definuje buÄ metodu â€{0}â€œ, nebo vhodnÃ© metody â€MergeSourceâ€œ a â€Bindâ€œ.FToto nenÃ­ promÄ›nnÃ¡, konstanta, aktivnÃ­ rozliÅ¡ovaÄ nebo literÃ¡l.Syntaxe type X with ... je vyhrazenÃ¡ pro rozÅ¡Ã­Å™enÃ­. Typy, kterÃ© majÃ­ skrytou reprezentaci, ale majÃ­ Äleny, se teÄ v signaturÃ¡ch deklarujÃ­ pomocÃ­ notace type X = ... Je moÅ¾nÃ©, Å¾e k definici typu v signatuÅ™e bude potÅ™eba pÅ™idat takÃ© atribut [<Sealed>].`NeplatnÃ½ obnovitelnÃ½ kÃ³d. Parametr obnovitelnÃ©ho kÃ³du musÃ­ bÃ½t typu delegÃ¡t nebo funkce.qNeplatnÃ½ obnovitelnÃ½ kÃ³d. Parametr obnovitelnÃ©ho kÃ³du musÃ­ mÃ­t nÃ¡zev, kterÃ¡ zaÄÃ­nÃ¡ na â€__expandâ€œ.PInvalid resumable code. A 'let rec' occurred in the resumable code specificationNeplatnÃ½ obnovitelnÃ½ kÃ³d. JakÃ¡koli metoda funkce, kterÃ¡ pÅ™ijÃ­mÃ¡ nebo vracÃ­ obnovitelnÃ½ kÃ³d, musÃ­ bÃ½t oznaÄena jako â€inlineâ€œ.¦VyvolÃ¡nÃ­ obnovitelnÃ©ho kÃ³du. Toto upozornÄ›nÃ­ potlaÄte, pokud definujete novÃ½ obnovitelnÃ½ kÃ³d niÅ¾Å¡Ã­ ÃºrovnÄ› v rÃ¡mci existujÃ­cÃ­ho obnovitelnÃ©ho kÃ³du.ePouÅ¾itÃ­ obnovitelnÃ©ho kÃ³du nebo obnovitelnÃ½ch stavovÃ½ch strojÅ¯ vyÅ¾aduje /langversion:preview.0V dotazech se nedÃ¡ pouÅ¾Ã­t return! ani return.nNÃ¡vratovÃ© typy pÅ™Ã­padÅ¯ typu union musÃ­ bÃ½t identickÃ© s typem, kterÃ½ se definuje, a to aÅ¾ po zkratky.*NÃ¡vratovÃ© hodnoty nemÅ¯Å¾ou mÃ­t nÃ¡zvy.ÒMetodu pole {0} poskytuje modul runtime a nedÃ¡ se v kÃ³du pouÅ¾Ã­t pÅ™Ã­mo. U operacÃ­ s prvky polÃ­ zvaÅ¾te moÅ¾nost pouÅ¾itÃ­ skupiny funkcÃ­ GetArray/SetArray z modulu LanguagePrimitives.IntrinsicFunctions.;Ve vÃ½razech poÅ™adÃ­ se vÃ½sledky generujÃ­ pomocÃ­ yield.¶Nelze volat â€{0}â€œ - metodu setter 