em.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})"> and
            the other overrides
            </seealso>
        </member>
        <member name="P:Microsoft.Identity.Client.DeviceCodeResult.UserCode">
            <summary>
            User code returned by the service
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.DeviceCodeResult.DeviceCode">
            <summary>
            Device code returned by the service
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.DeviceCodeResult.VerificationUrl">
            <summary>
            Verification URL where the user must navigate to authenticate using the device code and credentials.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.DeviceCodeResult.ExpiresOn">
            <summary>
            Time when the device code will expire.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.DeviceCodeResult.Interval">
            <summary>
            Polling interval time to check for completion of authentication flow.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.DeviceCodeResult.Message">
            <summary>
            User friendly text response that can be used for display purpose.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.DeviceCodeResult.ClientId">
            <summary>
            Identifier of the client requesting device code.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.DeviceCodeResult.Scopes">
            <summary>
            List of the scopes that would be held by token.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Extensibility.AbstractConfidentialClientAcquireTokenParameterBuilderExtension">
            <summary>
            Extensions for all AcquireToken methods
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Extensibility.AbstractConfidentialClientAcquireTokenParameterBuilderExtension.OnBeforeTokenRequest``1(Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder{``0},System.Func{Microsoft.Identity.Client.Extensibility.OnBeforeTokenRequestData,System.Threading.Tasks.Task})">
            <summary>
            Intervenes in the request pipeline, by executing a user provided delegate before MSAL makes the token request. 
            The delegate can modify the request payload by adding or removing  body parameters and headers. <see cref="T:Microsoft.Identity.Client.Extensibility.OnBeforeTokenRequestData"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="builder">The builder to chain options to</param>
            <param name="onBeforeTokenRequestHandler">An async delegate which gets invoked just before MSAL makes a token request</param>
            <returns>The builder to chain other options to.</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.Extensibility.AbstractConfidentialClientAcquireTokenParameterBuilderExtension.WithProofOfPosessionKeyId``1(Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder{``0},System.String,System.String)">
            <summary>
            Binds the token to a key in the cache.No cryptographic operations is performed on the token.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="builder">The builder to chain options to</param>
            <param name="keyId">A key id to which the access token is associated. The token will not be retrieved from the cache unless the same key id is presented. Can be null.</param>
            <param name="expectedTokenTypeFromAad">AAD issues several types of bound tokens. MSAL checks the token type, which needs to match the value set by ESTS. Normal POP tokens have this as "pop"</param>
            <returns>the builder</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.Extensibility.AcquireTokenForClientBuilderExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Extensibility.AcquireTokenForClientBuilderExtensions.WithProofOfPosessionKeyId(Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder,System.String,System.String)">
            <summary>
            Binds the token to a key in the cache. L2 cache keys contain the key id.
            No cryptographic operations is performed on the token.
            </summary>
            <param name="builder"></param>
            <param name="keyId">A key id to which the access token is associated. The token will not be retrieved from the cache unless the same key id is presented. Can be null.</param>
            <param name="expectedTokenTypeFromAad">AAD issues several types of bound tokens. MSAL checks the token type, which needs to match the value set by ESTS. Normal POP tokens have this as "pop"</param>
            <returns>the builder</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.Extensibility.AcquireTokenInteractiveParameterBuilderExtensions">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Extensibility.AcquireTokenInteractiveParameterBuilderExtensions.WithCustomWebUi(Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder,Microsoft.Identity.Client.Extensibility.ICustomWebUi)">
            <summary>
                Extension method enabling MSAL.NET extenders for public client applications to set a custom web UI
                that will let the user sign-in with Azure AD, present consent if needed, and get back the authorization
                code
            </summary>
            <param name="builder">Builder for an AcquireTokenInteractive</param>
            <param name="customWebUi">Customer implementation for the Web UI</param>
            <returns>the builder to be able to chain .With methods</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.Extensibility.AcquireTokenOnBehalfOfParameterBuilderExtensions">
            <summary>
            Extension methods for the <see cref="T:Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder" />
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Extensibility.AcquireTokenOnBehalfOfParameterBuilderExtensions.WithSearchInCacheForLongRunningProcess(Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder,System.Boolean)">
            <summary>
            Only affects <see cref="M:Microsoft.Identity.Client.ILongRunningWebApi.InitiateLongRunningProcessInWebApi(System.Collections.Generic.IEnumerable{System.String},System.String,System.String@)"/>.
            When enabled, mimics MSAL 4.50.0 and below behavior - checks in cache for cached tokens first, 
            and if not found, then uses user assertion to request new tokens from AAD.
            When disabled (default behavior), doesn't search in cache, but uses the user assertion to retrieve tokens from AAD.
            </summary>
            <remarks>
            This method should only be used in specific cases for backwards compatibility. For most cases, rely on the default behavior
            of <see cref="M:Microsoft.Identity.Client.ILongRunningWebApi.InitiateLongRunningProcessInWebApi(System.Collections.Generic.IEnumerable{System.String},System.String,System.String@)"/> and
            <see cref="M:Microsoft.Identity.Client.ILongRunningWebApi.AcquireTokenInLongRunningProcess(System.Collections.Generic.IEnumerable{System.String},System.String)"/> described in https://aka.ms/msal-net-long-running-obo .
            </remarks>
            <param name="builder"></param>
            <param name="searchInCache">Whether to search in cache.</param>
            <returns>The builder to chain the .With methods</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.Extensibility.AppTokenProviderParameters">
            <summary>
            The authentication parameters provided to the app token provider callback.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.AppTokenProviderParameters.Scopes">
            <summary>
            Specifies which scopes to request.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.AppTokenProviderParameters.CorrelationId">
            <summary>
            Correlation id of the authentication request.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.AppTokenProviderParameters.Claims">
            <summary>
            A string with one or multiple claims.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.AppTokenProviderParameters.TenantId">
            <summary>
            Tenant id of the 
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.AppTokenProviderParameters.CancellationToken">
            <summary>
            Used to cancel the authentication attempt made by the token provider
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Extensibility.AppTokenProviderResult">
            <summary>
            Token result from external app token provider
            </summary>
            <remarks>
            This is part of an extensibility mechanism designed to be used by Azure SDK in order to 
            enhance managed identity support.
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.AppTokenProviderResult.AccessToken">
            <summary>
            The actual token, usually in JWT format
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.AppTokenProviderResult.ExpiresInSeconds">
            <summary>
            Expiration of token 
            </summary>
            <remarks>Mandatory</remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.AppTokenProviderResult.RefreshInSeconds">
            <summary>
            When the token should be refreshed.
            </summary>
            <remarks>If not set, MSAL will set it to half of the expiry time if that time is longer than 2 hours.</remarks>
        </member>
        <member name="T:Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationBuilderExtensions">
            <summary>
            Extensibility methods for <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplicationBuilder"/>
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationBuilderExtensions.WithAppTokenProvider(Microsoft.Identity.Client.ConfidentialClientApplicationBuilder,System.Func{Microsoft.Identity.Client.Extensibility.AppTokenProviderParameters,System.Threading.Tasks.Task{Microsoft.Identity.Client.Extensibility.AppTokenProviderResult}})">
            <summary>
            Allows setting a callback which returns an access token, based on the passed-in parameters.
            MSAL will pass in its authentication parameters to the callback and it is expected that the callback
            will construct a <see cref="T:Microsoft.Identity.Client.Extensibility.AppTokenProviderResult"/> and return it to MSAL.
            MSAL will cache the token response the same way it does for other authentication results.
            </summary>
            <remarks>This is part of an extensibility mechanism designed to be used only by Azure SDK in order to
            enhance managed identity support. Only client_credential flow is supported.</remarks>
        </member>
        <member name="T:Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationExtensions">
            <summary>
            Extensibility methods for <see cref="T:Microsoft.Identity.Client.IConfidentialClientApplication"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationExtensions.StopLongRunningProcessInWebApiAsync(Microsoft.Identity.Client.ILongRunningWebApi,System.String,System.Threading.CancellationToken)">
            <summary>
            Stops an in-progress long-running on-behalf-of session by removing the tokens associated with the provided cache key.
            See <see href="https://aka.ms/msal-net-long-running-obo">Long-running OBO in MSAL.NET</see>.
            </summary>
            <param name="clientApp">Client application to remove tokens from.</param>
            <param name="longRunningProcessSessionKey">OBO cache key used to remove the tokens.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>True if tokens are removed from the cache; false, otherwise.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="longRunningProcessSessionKey"/> is not set.</exception>
        </member>
        <member name="T:Microsoft.Identity.Client.Extensibility.ICustomWebUi">
            <summary>
            Interface that an MSAL.NET extender can implement to provide their own web UI in public client applications
            to sign-in user and have them consented part of the Authorization code flow.
            MSAL.NET provides an embedded web view for Windows and Mac, but there are other scenarios not yet supported.
            This extensibility point enables them to provide such UI in a secure way
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Extensibility.ICustomWebUi.AcquireAuthorizationCodeAsync(System.Uri,System.Uri,System.Threading.CancellationToken)">
             <summary>
             Method called by MSAL.NET to delegate the authentication code web with the Secure Token Service (STS)
             </summary>
             <param name="authorizationUri"> URI computed by MSAL.NET that will let the UI extension
             navigate to the STS authorization endpoint in order to sign-in the user and have them consent
             </param>
             <param name="redirectUri">The redirect URI that was configured. The auth code will be appended to this redirect URI and the browser
             will redirect to it.
             </param>
             <param name="cancellationToken">The cancellation token to which you should respond to.
             See <see href="https://learn.microsoft.com/dotnet/standard/parallel-programming/task-cancellation">Task cancellation</see> for details.
             </param>
             <returns> The URI returned back from the STS authorization endpoint. This URI contains a code=CODE
             parameters that MSAL.NET will extract and redeem.
             </returns>
             <remarks>
             The <paramref name="authorizationUri">authorizationUri</paramref>"/> is crafted to
             leverage PKCE in order to protect the token from a man in the middle attack.
             Only MSAL.NET can redeem the code.
            
             In the event of cancellation, the implementer should return OperationCanceledException.
             </remarks>
        </member>
        <member name="T:Microsoft.Identity.Client.Extensibility.OnBeforeTokenRequestData">
            <summary>
            Authentication request details
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Extensibility.OnBeforeTokenRequestData.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.Uri,System.Threading.CancellationToken)">
            <summary>
            Constructor. 
            </summary>
            <remarks>Apps should not have to use this constructor. It is provided for testability purposes.</remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.OnBeforeTokenRequestData.BodyParameters">
            <summary>
            Parameters which will be sent in the request body, as POST parameters.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.OnBeforeTokenRequestData.Headers">
            <summary>
            Headers which will be sent with the request.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.OnBeforeTokenRequestData.RequestUri">
            <summary>
            The token endpoint, including any query parameters, where the request is being sent to.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Extensibility.OnBeforeTokenRequestData.CancellationToken">
            <summary>
            The cancellation token associated with the request
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Advanced.AcquireTokenParameterBuilderExtensions">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Advanced.AcquireTokenParameterBuilderExtensions.WithExtraHttpHeaders``1(Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder{``0},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Adds additional Http Headers to the token request.
            </summary>
            <param name="builder">Parameter builder for a acquiring tokens.</param>
            <param name="extraHttpHeaders">additional Http Headers to add to the token request.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Identity.Client.PublicClientApplicationExtensions">
            <summary>
            Extensibility methods for <see cref="T:Microsoft.Identity.Client.IPublicClientApplication"/>
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplicationExtensions.IsProofOfPossessionSupportedByClient(Microsoft.Identity.Client.IPublicClientApplication)">
            <summary>
            Used to determine if the currently available broker is able to perform Proof-of-Possession.
            </summary>
            <returns>Boolean indicating if Proof-of-Possession is supported</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.SSHCertificates.SSHExtensions">
            <summary>
            Extensions that add support for SSH certificates
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.SSHCertificates.SSHExtensions.WithSSHCertificateAuthenticationScheme(Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder,System.String,System.String)">
            <summary>
            Instructs AAD to return an SSH certificate instead of a Bearer token. The SSH certificate 
            (not the same as public / private key pair used by SSH), can be used to securely deploy 
            a public SSH key to a machine. See https://aka.ms/msal-net-ssh for details.
            </summary>
            <param name="builder">Interactive authentication builder</param>
            <param name="publicKeyJwk">The public SSH key in JWK format (https://tools.ietf.org/html/rfc7517). 
            Currently only RSA is supported, and the JWK should contain only the RSA modulus and exponent</param>
            <param name="keyId">A key identifier, it can be in any format. Used to distinguish between 
            different keys when fetching an SSH certificate from the token cache.</param>
        </member>
        <member name="M:Microsoft.Identity.Client.SSHCertificates.SSHExtensions.WithSSHCertificateAuthenticationScheme(Microsoft.Identity.Client.AcquireTokenSilentParameterBuilder,System.String,System.String)">
            <summary>
            Instructs AAD to return an SSH certificate instead of a Bearer token. Attempts to retrieve
            the certificate from the token cache, and if one is not found, attempts to acquire one silently, 
            using the refresh token. See https://aka.ms/msal-net-ssh for details.
            </summary>
            <remarks>
            The same keyID must be used to distinguish between various 
            </remarks>
            <param name="builder">Silent authentication builder</param>
            <param name="publicKeyJwk">The public SSH key in JWK format (https://tools.ietf.org/html/rfc7517). 
            Currently only RSA is supported, and the JWK should contain only the RSA modulus and exponent</param>
            <param name="keyId"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Identity.Client.Http.HttpManager">
             <remarks>
             We invoke this class from different threads and they all use the same HttpClient.
             To prevent race conditions, make sure you do not get / set anything on HttpClient itself,
             instead rely on HttpRequest objects which are thread specific.
            
             In particular, do not change any properties on HttpClient such as BaseAddress, buffer sizes and Timeout. You should
             also not access DefaultRequestHeaders because the getters are not thread safe (use HttpRequestMessage.Headers instead).
             </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.HttpManager.SendGetForceResponseAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Identity.Client.Core.ILoggerAdapter,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Performs the GET request just like <see cref="M:Microsoft.Identity.Client.Http.HttpManager.SendGetAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Identity.Client.Core.ILoggerAdapter,System.Boolean,System.Threading.CancellationToken)"/>
            but does not throw a ServiceUnavailable service exception. Instead, it returns the <see cref="T:Microsoft.Identity.Client.Http.HttpResponse"/> associated
            with the request.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.HttpManager.SendPostForceResponseAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Identity.Client.Core.ILoggerAdapter,System.Threading.CancellationToken)">
            <summary>
            Performs the POST request just like <see cref="M:Microsoft.Identity.Client.Http.HttpManager.SendPostAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Identity.Client.Core.ILoggerAdapter,System.Threading.CancellationToken)"/>
            but does not throw a ServiceUnavailable service exception. Instead, it returns the <see cref="T:Microsoft.Identity.Client.Http.HttpResponse"/> associated
            with the request.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.HttpManager.SendPostForceResponseAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},System.Net.Http.StringContent,Microsoft.Identity.Client.Core.ILoggerAdapter,System.Threading.CancellationToken)">
            <summary>
            Performs the POST request just like <see cref="M:Microsoft.Identity.Client.Http.HttpManager.SendPostAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},System.Net.Http.HttpContent,Microsoft.Identity.Client.Core.ILoggerAdapter,System.Threading.CancellationToken)"/>
            but does not throw a ServiceUnavailable service exception. Instead, it returns the <see cref="T:Microsoft.Identity.Client.Http.HttpResponse"/> associated
            with the request.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.HttpManager.IsRetryableStatusCode(System.Int32)">
            <summary>
            In HttpManager, the retry policy is based on this simple condition.
            Avoid changing this, as it's breaking change.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Http.HttpManagerFactory">
            <summary>
            Factory to return the instance of HttpManager based on retry configuration and type of MSAL application.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Http.HttpManagerManagedIdentity">
            <remarks>
            HTTP Manager specific to managed identity to implement the retry for specific HTTP status codes.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.HttpManagerManagedIdentity.IsRetryableStatusCode(System.Int32)">
            <summary>
            Retry policy specific to managed identity flow.
            Avoid changing this, as it's breaking change.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Http.HttpManagerWithRetry">
             <remarks>
             We invoke this class from different threads and they all use the same HttpClient.
             To prevent race conditions, make sure you do not get / set anything on HttpClient itself,
             instead rely on HttpRequest objects which are thread specific.
            
             In particular, do not change any properties on HttpClient such as BaseAddress, buffer sizes and Timeout. You should
             also not access DefaultRequestHeaders because the getters are not thread safe (use HttpRequestMessage.Headers instead).
             </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.HttpManagerWithRetry.SendPostAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},System.Net.Http.HttpContent,Microsoft.Identity.Client.Core.ILoggerAdapter,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.HttpManagerWithRetry.SendGetAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Identity.Client.Core.ILoggerAdapter,System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.HttpManagerWithRetry.SendGetForceResponseAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Identity.Client.Core.ILoggerAdapter,System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.HttpManagerWithRetry.SendPostForceResponseAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},Microsoft.Identity.Client.Core.ILoggerAdapter,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.HttpManagerWithRetry.SendPostForceResponseAsync(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},System.Net.Http.StringContent,Microsoft.Identity.Client.Core.ILoggerAdapter,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.Http.RedirectUriHelper.Validate(System.Uri,System.Boolean)">
            <summary>
            Check common redirect URI problems.
            Optionally check that the redirect URI is not the OAuth2 standard redirect URI https://login.microsoftonline.com/common/oauth2/nativeclientb
            when using a system browser, because the browser cannot redirect back to the app.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.IAccount">
            <summary>
            The IAccount interface represents information about a single account.
            The same user can be present in different tenants, that is, a user can have multiple accounts.
            An <c>IAccount</c> is returned in the <see cref="T:Microsoft.Identity.Client.AuthenticationResult"/>.<see cref="P:Microsoft.Identity.Client.AuthenticationResult.Account"/> property, and can be used as parameters
            of PublicClientApplication and ConfidentialClientApplication methods acquiring tokens such as <see cref="M:Microsoft.Identity.Client.ClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/>
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IAccount.Username">
            <summary>
            Gets a string containing the displayable value in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c>.
            This can be null.
            </summary>
            <remarks>This property replaces the <c>DisplayableId</c> property of <c>IUser</c> in previous versions of MSAL.NET</remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.IAccount.Environment">
            <summary>
            Gets a string containing the identity provider for this account, e.g. <c>login.microsoftonline.com</c>.
            </summary>
            <remarks>This property replaces the <c>IdentityProvider</c> property of <c>IUser</c> in previous versions of MSAL.NET
            except that IdentityProvider was a URL with information about the tenant (in addition to the cloud environment), whereas Environment is only the <see cref="P:System.Uri.Host"/></remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.IAccount.HomeAccountId">
            <summary>
            AccountId of the home account for the user. This uniquely identifies the user across AAD tenants.
            </summary>
            <remarks>Can be null, for example if this account was migrated to MSAL.NET from ADAL.NET v3's token cache</remarks>
        </member>
        <member name="T:Microsoft.Identity.Client.IApplicationBase">
            <summary>
            Interface used for creation of client applications. For details see https://aka.ms/msal-net-client-applications.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.IByRefreshToken">
             <summary>
            
             </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Acquires an access token from an existing refresh token and stores it, and the refresh token, in
            the user token cache, where it will be available for further AcquireTokenSilent calls.
            This method can be used in migration to MSAL from ADAL v2, and in various integration
            scenarios where you have a RefreshToken available.
            See https://aka.ms/msal-net-migration-adal2-msal2.
            </summary>
            <param name="scopes">Scope to request from the token endpoint.
            Setting this to null or empty will request an access token, refresh token and ID token with default scopes</param>
            <param name="refreshToken">The refresh token from ADAL 2.x</param>
            <returns>A builder enabling you to add optional parameters before executing the token request</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Acquires an access token from an existing refresh token and stores it and the refresh token into
            the user token cache, where it will be available for further AcquireTokenSilentAsync calls.
            This method can be used in migration to MSAL from ADAL v2 and in various integration
            scenarios where you have a RefreshToken available.
            (see https://aka.ms/msal-net-migration-adal2-msal2)
            </summary>
            <param name="scopes">Scope to request from the token endpoint.
            Setting this to null or empty will request an access token, refresh token and ID token with default scopes</param>
            <param name="refreshToken">The refresh token from ADAL 2.x</param>
        </member>
        <member name="T:Microsoft.Identity.Client.IClientApplicationBase">
            <inheritdoc/>
            <summary>
            Interface defining common API methods and properties. Both <see cref="T:PublicClientApplication"/> and <see cref="T:ConfidentialClientApplication"/>
            extend this class. For details see https://aka.ms/msal-net-client-applications
            </summary>    
        </member>
        <member name="P:Microsoft.Identity.Client.IClientApplicationBase.AppConfig">
            <summary>
            Details on the configuration of the ClientApplication for debugging purposes.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IClientApplicationBase.UserTokenCache">
            <summary>
            User token cache which holds ID tokens, access tokens, and refresh tokens for accounts. It's used
            and updated silently if needed when calling <see cref="M:Microsoft.Identity.Client.ClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/>
            It is updated by each acquire token method, with the exception of <see cref="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})"/> which only uses the application
            cache (see <see cref="P:Microsoft.Identity.Client.IConfidentialClientApplication.AppTokenCache"/>).
            </summary>
            <remarks>On .NET Framework and .NET Core you can also customize the token cache serialization.
            See https://aka.ms/msal-net-token-cache-serialization. This is taken care of by MSAL.NET on mobile platforms.
            It is recommended to use token cache serialization for web site and web api scenarios.
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.IClientApplicationBase.Authority">
            <summary>
            Gets the URL of the authority, or the security token service (STS) from which MSAL.NET will acquire security tokens.
            The return value of this property is either the value provided by the developer in the constructor of the application, or otherwise
            the value of the <see cref="F:Microsoft.Identity.Client.ApplicationBase.DefaultAuthority"/> static member (that is <c>https://login.microsoftonline.com/common/</c>)
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.IClientApplicationBase.GetAccountsAsync">
            <summary>
            Returns all the available <see cref="T:Microsoft.Identity.Client.IAccount">accounts</see> in the user token cache for the application.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.IClientApplicationBase.GetAccountAsync(System.String)">
            <summary>
            Get the <see cref="T:Microsoft.Identity.Client.IAccount"/> by its identifier among the accounts available in the token cache and of the same
            environment (authority host) as <see cref="P:Microsoft.Identity.Client.IClientApplicationBase.Authority"/>.
            </summary>
            <param name="identifier">Account identifier. The value of the identifier will probably have been stored value from the
            value of the <see cref="P:Microsoft.Identity.Client.AccountId.Identifier"/> property of <see cref="T:Microsoft.Identity.Client.AccountId"/>.
            You typically get the account ID from an <see cref="T:Microsoft.Identity.Client.IAccount"/> by using the <see cref="P:Microsoft.Identity.Client.IAccount.HomeAccountId"/> property.</param>
        </member>
        <member name="M:Microsoft.Identity.Client.IClientApplicationBase.GetAccountsAsync(System.String)">
            <summary>
            Only for Azure AD B2C scenarios, get the <see cref="T:Microsoft.Identity.Client.IAccount"/> collection by its identifier
            among the accounts available in the token cache based on the user flow.
            </summary>
            <param name="userFlow">The identifier is the user flow being targeted by the specific B2C authority.</param>
        </member>
        <member name="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)">
            <summary>
            Attempts to acquire an access token for the <paramref name="account"/> from the user token cache,
            with advanced parameters controlling the network call. See <see href="https://aka.ms/msal-net-acquiretokensilent">Acquire tokens silently</see>.
            </summary>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <param name="account">Account for which the token is requested. <see cref="T:Microsoft.Identity.Client.IAccount"/></param>
            <returns>An <see cref="T:Microsoft.Identity.Client.AcquireTokenSilentParameterBuilder"/> used to build the token request, adding optional
            parameters.</returns>
            <exception cref="T:Microsoft.Identity.Client.MsalUiRequiredException">When an interaction is required with the end user of the application,
            for instance, if no refresh token was in the cache; the user needs to consent or to re-sign-in (for instance if the password expired);
            or the user needs to perform two factor authentication.</exception>
            <remarks>
            The access token is considered a match if it contains <b>at least</b> all the requested scopes. This means that an access token with more scopes than
            requested could be returned as well. If the access token is expired or close to expiration (within a 5 minute window),
            then the cached refresh token (if available) is used to acquire a new access token by making a silent network call.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Attempts to acquire an access token for the <paramref name="loginHint"/> from the user token cache,
            with advanced parameters controlling the network call. See <see href="https://aka.ms/msal-net-acquiretokensilent">Acquire tokens silently</see>.
            </summary>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <param name="loginHint">Typically the username, in UPN format, e.g. <c>johnd@contoso.com</c>.</param>
            <returns>An <see cref="T:Microsoft.Identity.Client.AcquireTokenSilentParameterBuilder"/> used to build the token request, adding optional
            parameters.</returns>
            <exception cref="T:Microsoft.Identity.Client.MsalUiRequiredException">When an interaction is required with the end user of the application,
            for instance, if no refresh token was in the cache; the user needs to consent or to re-sign-in (for instance if the password expired);
            or the user needs to perform two factor authentication.</exception>
            <remarks>
            The access token is considered a match if it contains <b>at least</b> all the requested scopes. This means that an access token with more scopes than
            requested could be returned as well. If the access token is expired or close to expiration (within a 5 minute window),
            then the cached refresh token (if available) is used to acquire a new access token by making a silent network call.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IClientApplicationBase.RemoveAsync(Microsoft.Identity.Client.IAccount)">
            <summary>
            Removes all tokens in the cache for the specified account.
            </summary>
            <param name="account">Instance of the account that needs to be removed.</param>
        </member>
        <member name="P:Microsoft.Identity.Client.IClientApplicationBase.Users">
            <summary>
            In MSAL 1.x returned an enumeration of <see cref="T:Microsoft.Identity.Client.IUser"/>. From MSAL 2.x, use <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.GetAccountsAsync"/> instead.
            See https://aka.ms/msal-net-2-released for more details.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.IClientApplicationBase.GetUser(System.String)">
            <summary>
            In MSAL 1.x, return a user from its identifier. From MSAL 2.x, use <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.GetAccountsAsync"/> instead.
            See https://aka.ms/msal-net-2-released for more details.
            </summary>
            <param name="identifier">Identifier of the user to retrieve</param>
            <returns>the user in the cache with the identifier passed as an argument</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IClientApplicationBase.Remove(Microsoft.Identity.Client.IUser)">
            <summary>
            In MSAL 1.x removed a user from the cache. From MSAL 2.x, use <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.RemoveAsync(Microsoft.Identity.Client.IAccount)"/> instead.
            See https://aka.ms/msal-net-2-released for more details.
            </summary>
            <param name="user">User to remove from the cache</param>
        </member>
        <member name="P:Microsoft.Identity.Client.IClientApplicationBase.Component">
            <summary>
            Identifier of the component (libraries/SDK) consuming MSAL.NET.
            This will allow for disambiguation between MSAL usage by the app vs MSAL usage by component libraries.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IClientApplicationBase.SliceParameters">
            <summary>
            Sets or Gets a custom query parameters that may be sent to the STS for dogfood testing or debugging. This is a string of segments
            of the form <c>key=value</c> separated by an ampersand character.
            Unless requested otherwise, this parameter should not be set by application developers as it may have adverse effect on the application.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IClientApplicationBase.ValidateAuthority">
            <summary>
            Gets a boolean value telling the application if the authority needs to be verified against a list of known authorities. The default
            value is <c>true</c>. It should currently be set to <c>false</c> for Azure AD B2C authorities as those are customer specific
            (a list of known B2C authorities cannot be maintained by MSAL.NET)
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IClientApplicationBase.RedirectUri">
            <summary>
            The redirect URI (also known as Reply URI or Reply URL), is the URI at which Azure AD will contact back the application with the tokens.
            This redirect URI needs to be registered in the app registration (https://aka.ms/msal-net-register-app)
            In MSAL.NET, <see cref="T:PublicClientApplication"/> define the following default RedirectUri values:
            <list type="bullet">
            <item><description><c>urn:ietf:wg:oauth:2.0:oob</c> for desktop (.NET Framework and .NET Core) applications</description></item>
            <item><description><c>msal{ClientId}</c> for Xamarin iOS and Xamarin Android (as this will be used by the system web browser by default on these
            platforms to call back the application)
            </description></item>
            </list>
            These default URIs could change in the future.
            In <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication"/>, this can be the URL of the web application / web API.
            </summary>
            <remarks>This is especially important when you deploy an application that you have initially tested locally;
            you then need to add the reply URL of the deployed application in the application registration portal.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilentAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)">
            <summary>
            Attempts to acquire an access token for the <paramref name="account"/> from the user token cache.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account for which the token is requested. <see cref="T:Microsoft.Identity.Client.IAccount"/></param>
            <returns>An <see cref="T:Microsoft.Identity.Client.AuthenticationResult"/> containing the requested token</returns>
            <exception cref="T:Microsoft.Identity.Client.MsalUiRequiredException">can be thrown in the case where an interaction is required with the end user of the application,
            for instance so that the user consents, or re-signs-in (for instance if the password expired), or performs two factor authentication</exception>
            <remarks>
            The access token is considered a match if it contains <b>at least</b> all the requested scopes.
            This means that an access token with more scopes than requested could be returned as well. If the access token is expired or
            close to expiration (within 5 minute window), then the cached refresh token (if available) is used to acquire a new access token by making a silent network call.
            See https://aka.ms/msal-net-acuiretokensilent for more details
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilentAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,System.String,System.Boolean)">
            <summary>
            Attempts to acquire and access token for the <paramref name="account"/> from the user token cache, with advanced parameters making a network call.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account for which the token is requested. <see cref="T:Microsoft.Identity.Client.IAccount"/></param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured in the application constructor
            narrows down the selection of tenants for which to get a tenant, but does not change the configured value</param>
            <param name="forceRefresh">If <c>true</c>, the will ignore the access token in the cache and attempt to acquire new access token
            using the refresh token for the account if this one is available. This can be useful in the case when the application developer wants to make
            sure that conditional access policies are applies immediately, rather than after the expiration of the access token</param>
            <returns>An <see cref="T:Microsoft.Identity.Client.AuthenticationResult"/> containing the requested token</returns>
            <exception cref="T:Microsoft.Identity.Client.MsalUiRequiredException">can be thrown in the case where an interaction is required with the end user of the application,
            for instance, if no refresh token was in the cache, or the user needs to consents, or re-sign-in (for instance if the password expired),
            or performs two factor authentication</exception>
            <remarks>
            The access token is considered a match if it contains <b>at least</b> all the requested scopes. This means that an access token with more scopes than
            requested could be returned as well. If the access token is expired or close to expiration (within 5 minute window),
            then the cached refresh token (if available) is used to acquire a new access token by making a silent network call.
            See https://aka.ms/msal-net-acquiretokensilent for more details
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.IClientApplicationBase.ClientId">
            <summary>
            Gets the Client ID (also known as Application ID) of the application as registered in the application registration portal (https://aka.ms/msal-net-register-app)
            and as passed in the constructor of the application.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.IConfidentialClientApplication">
            <summary>
            Represents confidential client applications - web apps, web APIs, daemon applications.
            </summary>
            <remarks>
            Confidential client applications are typically applications which run on servers (web apps, web API, or even service/daemon applications).
            They are considered difficult to access, and therefore capable of keeping an application secret (hold configuration
            time secrets as these values would be difficult for end users to extract).
            A web app is the most common confidential client. The client ID is exposed through the web browser, but the secret is passed only in the back channel
            and never directly exposed. For details, see <see href="https://aka.ms/msal-net-client-applications">Client Applications</see>.
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.IConfidentialClientApplication.AppTokenCache">
            <summary>
            Application token cache which holds access tokens for this application. It's maintained
            and updated silently when calling <see cref="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})"/>
            </summary>
            <remarks>On .NET Framework and .NET Core you can also customize the token cache serialization.
            See <see href="https://aka.ms/msal-net-token-cache-serialization">Token Cache Serialization</see>. This is taken care of by MSAL.NET on other platforms.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenByAuthorizationCode(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Acquires a token from the authority configured in the app using the authorization code
            previously received from the identity provider using the OAuth 2.0 authorization code flow.
            See <see href="https://aka.ms/msal-net-authorization-code">Authorization Code Flow</see>.
            This flow is usually used in web apps (for instance, ASP.NET and ASP.NET Core web apps)
            which sign-in users and can request an authorization code.
            This method does not look in the token cache, but stores the result in it. Before calling this method, use other methods 
            such as <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/> to check the token cache.
            </summary>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <param name="authorizationCode">The authorization code received from the service authorization endpoint.</param>
            <returns>A builder enabling you to add optional parameters before executing the token request.</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenForClient(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Acquires a token from the authority configured in the app for the confidential client itself (not for a user)
            using the client credentials flow. See <see href="https://aka.ms/msal-net-client-credentials">Client Credentials Flow</see>.
            During this operation MSAL will first search in the cache for an unexpired token before acquiring a new one from Microsoft Entra ID.
            </summary>
            <param name="scopes">Scopes requested to access a protected API. For this flow (client credentials), the scopes
            should be in the form of "{ResourceIdUri/.default}" for instance <c>https://management.azure.net/.default</c> or, for Microsoft
            Graph, <c>https://graph.microsoft.com/.default</c> as the requested scopes are defined statically in the application registration
            in the portal, and cannot be overridden in the application.</param>
            <returns>A builder enabling you to add optional parameters before executing the token request.</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenOnBehalfOf(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)">
            <summary>
            Acquires an access token for this application (usually a web API) from the authority configured in the application,
            in order to access another downstream protected web API on behalf of a user using the OAuth 2.0 On-Behalf-Of flow.
            During this operation MSAL will first search in the cache for an unexpired token before acquiring a new one from Microsoft Entra ID.
            See <see href="https://aka.ms/msal-net-on-behalf-of">On-Behalf-Of Flow</see>.
            </summary>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <param name="userAssertion">Instance of <see cref="T:Microsoft.Identity.Client.UserAssertion"/> containing credential information about
            the user on behalf of whom to get a token.</param>
            <returns>A builder enabling you to add optional parameters before executing the token request.</returns>
            <remarks>
            Pass an access token (not an ID token) which was used to access this application in the
            <paramref name="userAssertion">userAssertion</paramref> parameter.
            For long-running or background processes in web API, see <see href="https://aka.ms/msal-net-long-running-obo">Long-running OBO in MSAL.NET</see>.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.GetAuthorizationRequestUrl(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Computes the URL of the authorization request letting the user sign-in and consent to the application accessing specific scopes in
            the user's name. The URL targets the /authorize endpoint of the authority configured in the application.
            </summary>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <returns>A builder enabling you to add optional parameters before executing the token request to get the
            URL of the authorization endpoint with the specified parameters.</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            In confidential client apps use <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/> instead.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.GetAccountsAsync">
            <summary>
            Use <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.GetAccountAsync(System.String)"/> in web apps and web APIs, and use a token cache serializer for better security and performance. See https://aka.ms/msal-net-cca-token-cache-serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenOnBehalfOfAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)">
            <summary>
            [V3 API] Acquires token using On-Behalf-Of flow. (See https://aka.ms/msal-net-on-behalf-of)
            </summary>
            <param name="scopes">Array of scopes requested for resource</param>
            <param name="userAssertion">Instance of UserAssertion containing user's token.</param>
            <returns>Authentication result containing token of the user for the requested scopes</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenOnBehalfOfAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion,System.String)">
            <summary>
            [V3 API] Acquires token using On-Behalf-Of flow. (See https://aka.ms/msal-net-on-behalf-of)
            </summary>
            <param name="scopes">Array of scopes requested for resource</param>
            <param name="userAssertion">Instance of UserAssertion containing user's token.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <returns>Authentication result containing token of the user for the requested scopes</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenByAuthorizationCodeAsync(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            [V2 API] Acquires security token from the authority using authorization code previously received.
            This method does not lookup token cache, but stores the result in it, so it can be looked up using other methods such as <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilentAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/>.
            </summary>
            <param name="authorizationCode">The authorization code received from service authorization endpoint.</param>
            <param name="scopes">Array of scopes requested for resource</param>
            <returns>Authentication result containing token of the user for the requested scopes</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenForClientAsync(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            [V2 API] Acquires token from the service for the confidential client. This method attempts to look up valid access token in the cache.
            </summary>
            <param name="scopes">Array of scopes requested for resource</param>
            <returns>Authentication result containing application token for the requested scopes</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenForClientAsync(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            [V2 API] Acquires token from the service for the confidential client. This method attempts to look up valid access token in the cache.
            </summary>
            <param name="scopes">Array of scopes requested for resource</param>
            <param name="forceRefresh">If TRUE, API will ignore the access token in the cache and attempt to acquire new access token using client credentials</param>
            <returns>Authentication result containing application token for the requested scopes</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.GetAuthorizationRequestUrlAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            [V2 API] URL of the authorize endpoint including the query parameters.
            </summary>
            <param name="scopes">Array of scopes requested for resource</param>
            <param name="loginHint">Identifier of the user. Generally a UPN.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority. The parameter can be null.</param>
            <returns>URL of the authorize endpoint including the query parameters.</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplication.GetAuthorizationRequestUrlAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            [V2 API] Gets URL of the authorize endpoint including the query parameters.
            </summary>
            <param name="scopes">Array of scopes requested for resource</param>
            <param name="redirectUri">Address to return to upon receiving a response from the authority.</param>
            <param name="loginHint">Identifier of the user. Generally a UPN.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority. The parameter can be null.</param>
            <param name="extraScopesToConsent">Array of scopes for which a developer can request consent upfront.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <returns>URL of the authorize endpoint including the query parameters.</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.ILongRunningWebApi">
            <summary>
            Methods for long-running or background processes in web APIs.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.ILongRunningWebApi.InitiateLongRunningProcessInWebApi(System.Collections.Generic.IEnumerable{System.String},System.String,System.String@)">
            <summary>
            Acquires an access token for this web API from the authority configured in the application,
            in order to access another downstream protected web API on behalf of a user using the OAuth 2.0 On-Behalf-Of flow.
            See <see href="https://aka.ms/msal-net-long-running-obo">Long-running OBO in MSAL.NET</see>.
            Pass an access token (not an ID token) which was used to call this confidential client application in the
            <paramref name="userToken">userToken</paramref> parameter.
            Use <seealso cref="M:Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationExtensions.StopLongRunningProcessInWebApiAsync(Microsoft.Identity.Client.ILongRunningWebApi,System.String,System.Threading.CancellationToken)"/> to stop the long running process
            and remove the associated tokens from the cache.
            </summary>
            <remarks>
            This method should be called once when the long-running session is started.
            </remarks>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <param name="userToken">A JSON Web Token which was used to call this web API and contains the credential information
            about the user on behalf of whom to get a token.</param>
            <param name="longRunningProcessSessionKey">Key by which to look up the token in the cache.
            If null, it will be set to the assertion hash of the <paramref name="userToken">userToken</paramref> by default.</param>
            <returns>A builder enabling you to add other parameters before executing the token request.</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.ILongRunningWebApi.AcquireTokenInLongRunningProcess(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Retrieves an access token from the cache using the provided cache key that can be used to
            access another downstream protected web API on behalf of a user using the OAuth 2.0 On-Behalf-Of flow.
            See <see href="https://aka.ms/msal-net-long-running-obo">Long-running OBO in MSAL.NET</see>.
            Use <seealso cref="M:Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationExtensions.StopLongRunningProcessInWebApiAsync(Microsoft.Identity.Client.ILongRunningWebApi,System.String,System.Threading.CancellationToken)"/> to stop the long running process
            and remove the associated tokens from the cache.
            </summary>
            <remarks>
            This method should be called during the long-running session to retrieve the token from the cache.
            </remarks>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <param name="longRunningProcessSessionKey">Key by which to look up the token in the cache.</param>
            <returns>A builder enabling you to add other parameters before executing the token request.</returns>
            <exception cref="T:Microsoft.Identity.Client.MsalClientException"> The token cache does not contain a token
            with an OBO cache key that matches the <paramref name="longRunningProcessSessionKey"/>.</exception>
        </member>
        <member name="T:Microsoft.Identity.Client.IManagedIdentityApplication">
            <summary>
            Component to be used with managed identity applications for Azure resources.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.IManagedIdentityApplication.AcquireTokenForManagedIdentity(System.String)">
            <summary>
            Acquires token for a managed identity configured on Azure resource. See https://aka.ms/msal-net-managed-identity.
            </summary>
            <param name="resource">resource requested to access the protected API. For this flow (managed identity), the resource
            should be of the form "{ResourceIdUri}" or {ResourceIdUri/.default} for instance <c>https://management.azure.net</c> or, for Microsoft
            Graph, <c>https://graph.microsoft.com/.default</c>.</param>
            <returns>A builder enabling you to add optional parameters before executing the token request</returns>
            <remarks>You can also chain the following optional parameters:
            <see cref="M:Microsoft.Identity.Client.AcquireTokenForManagedIdentityParameterBuilder.WithForceRefresh(System.Boolean)"/>
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.Instance.AdfsAuthority.GetTenantedAuthority(System.String,System.Boolean)">
            <summary>
            ADFS seems to support tenanted authorities, but the tenant ID is fixed so for all intents and purposes 
            it remains constant
            </summary>
            <param name="tenantId"></param>
            <param name="forceSpecifiedTenant"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:Microsoft.Identity.Client.Instance.Authority">
            <remarks>
            Must be kept immutable
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.Instance.Authority.CreateAuthorityForRequestAsync(Microsoft.Identity.Client.Internal.RequestContext,Microsoft.Identity.Client.AuthorityInfo,Microsoft.Identity.Client.IAccount)">
             <summary>
             Figures out the authority based on the authority from the config and the authority from the request,
             and optionally the homeAccountTenantId, which has an impact on AcquireTokenSilent
            
             The algorithm is:
            
             1. If there is no request authority (i.e. no authority override), use the config authority.
                 1.1. For AAD, if the config authority is "common" etc, try to use the tenanted version with the home account tenant ID
             2. If there is a request authority, try to use it.
                 2.1. If the request authority is not "common", then use it
                 2.2  If the request authority is "common", ignore it, and use 1.1
            
             Special cases:
            
             - if the authority is not defined at the application level and the request level is not AAD, use the request authority
             - if the authority is defined at app level, and the request level authority of is of different type, throw an exception
            
             </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Instance.Authority.GetTenantedAuthority(System.String,System.Boolean)">
            <summary>
            Changes the tenant ID of the authority, if the authority supports tenants. If not, throws exception.
            </summary>
            <param name="tenantId">The new tenant ID</param>
            <param name="forceSpecifiedTenant">Forces the change, even if the current tenant is not "common" or "organizations" or "consumers"</param>
        </member>
        <member name="T:Microsoft.Identity.Client.Instance.AuthorityManager">
            <summary>
            This object is at REQUEST level.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Instance.CiamAuthority.TransformAuthority(System.Uri)">
            <summary>
            Translates CIAM authorities into a usable form. This is needed only until ESTS is updated to support the north star format
            North star format: https://idgciamdemo.ciamlogin.com
            Transformed format: https://idgciamdemo.ciamlogin.com/idgciamdemo.onmicrosoft.com
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Instance.Discovery.IInstanceDiscoveryManager">
            <summary>
            Provides instance metadata across all authority types. Deals with metadata caching.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryManager">
            <summary>
            Priority order of metadata providers: 
            
            If user provided metadata via <see cref="M:Microsoft.Identity.Client.AbstractApplicationBuilder`1.WithInstanceDiscoveryMetadata(System.String)"/> use it exclusively. Otherwise:
            
            1. Static cache (this is populated from the network)
            2. Well-known cache if all environments present in the token cache are known (this is hard-coded into MSAL)
            3. Cache stored in token cache (Not currently implemented)
            5. AAD discovery endpoint 
            6. If going to the network fails with an error different than "invalid_instance" (i.e.authority validation failed), use the well-known instance metadata entry for the given authority
            7. On failure, use the authority itself(i.e.preferred cache = preferred network = aliases = configured_authority)
            
            Spec: https://identitydivision.visualstudio.com/DevEx/_git/AuthLibrariesApiReview?path=%2FInstance%20Discovery%20Caching%2Fdesktop_web_caching.md
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Instance.Validation.AadAuthorityValidator.ValidateAuthorityAsync(Microsoft.Identity.Client.AuthorityInfo)">
            <summary>
            AAD performs authority validation by calling the instance metadata endpoint. This is a bit unfortunate, 
            because instance metadata is used for aliasing, and authority validation is orthogonal to that. 
            MSAL must figure out aliasing even if ValidateAuthority is set to false.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Instance.Validation.IAuthorityValidator.ValidateAuthorityAsync(Microsoft.Identity.Client.AuthorityInfo)">
            <summary>
            Validates the authority. This is specific to each authority type.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Instance.Validation.NullAuthorityValidator.ValidateAuthorityAsync(Microsoft.Identity.Client.AuthorityInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.Region.IRegionManager.GetAzureRegionAsync(Microsoft.Identity.Client.Internal.RequestContext)">
            <summary>
            Gets the azure region and adds telemetry to the ApiEvents
            </summary>        
            <returns>Returns null if region should not be used or cannot be discovered.</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.Region.RegionAutodetectionSource">
            <summary>
            Indicates where the region information came from. 
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionAutodetectionSource.None">
            <summary>
            Indicates that the API .WithAzureRegion() was not used
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionAutodetectionSource.FailedAutoDiscovery">
            <summary>
            Auto-detection failed, fallback to global
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionAutodetectionSource.Cache">
            <summary>
            Auto-detected from MSAL's static cache
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionAutodetectionSource.EnvVariable">
            <summary>
            Auto-detected from Env Variable
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionAutodetectionSource.Imds">
            <summary>
            Auto-detected from IMDS
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Region.RegionOutcome">
            <summary>
            Indicates where the region information came from. 
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionOutcome.None">
            <summary>
            Indicates that the API .WithAzureRegion() was not used
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionOutcome.UserProvidedValid">
            <summary>
            Region provided by the user, matches auto detected region
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionOutcome.UserProvidedAutodetectionFailed">
            <summary>
            Region provided by the user, auto detection cannot be done
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionOutcome.UserProvidedInvalid">
            <summary>
            Region provided by the user, does not match auto detected region
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionOutcome.AutodetectSuccess">
            <summary>
            Region autodetect requested and was successful
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Region.RegionOutcome.FallbackToGlobal">
            <summary>
            Region autodetect requested but failed. Fallback to global
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Internal.Broker.BrokerResponseConst">
            <summary>
            For Android there are from: https://github.com/AzureAD/microsoft-authentication-library-common-for-android/blob/dev/common/src/main/java/com/microsoft/identity/common/internal/broker/BrokerResult.java
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Internal.Broker.IBroker.HandleInstallUrl(System.String)">
            <summary>
            If device auth is required but the broker is not enabled, AAD will
            signal this by returning an URL pointing to the broker app that needs to be installed.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Internal.Broker.NullBroker">
            <summary>
            For platforms that do not support a broker
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.IdToken.ObjectId">
            <summary>
            The OID claim is a unique identifier (GUID) for the user object in Azure AD.
            Guest Users have different OID.
            This is a stable ID across all apps.
            
            IMPORTANT: There are rare cases where this is missing! 
            </summary>
            <remarks>
            Avoid using as it is not guaranteed non-null. Use <see cref="M:Microsoft.Identity.Client.Internal.IdToken.GetUniqueId"/> instead.
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.IdToken.Subject">
            <summary>
            The sub claim is a unique identifier for user + app. 
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.IServiceBundle.ApplicationLogger">
            <summary>
            When outside of a request, the normal logger (requestContext.Logger) is not available. 
            This logger is at the app level - it is just not tied to a correlation ID.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Internal.JsonWebTokenConstants.Algorithm">
            <summary>
            Encryption algorithm used, e.g. ES256
            https://tools.ietf.org/html/rfc7515#section-4.1.1
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Internal.JsonWebTokenConstants.Type">
            <summary>
            The type of token e.g. JWT
            https://tools.ietf.org/html/rfc7519#section-5.1
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Internal.JsonWebTokenConstants.KeyId">
            <summary>
            Key ID, can be an X509 cert thumbprint. When used with a JWK, the "kid" value is used to match a JWK "kid"
            parameter value
            https://tools.ietf.org/html/rfc7515#section-4.1.4
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Internal.MsalIdParameter.Product">
            <summary>
                MSAL Flavor: .NET or WinRT
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Internal.MsalIdParameter.Version">
            <summary>
                MSAL assembly version
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Internal.MsalIdParameter.OS">
            <summary>
                Version of the operating system. This will not be sent on WinRT
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Internal.MsalIdParameter.DeviceModel">
            <summary>
                Device model. This will not be sent on .NET
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Internal.MsalIdHelper">
            <summary>
                This class adds additional query parameters or headers to the requests sent to STS. This can help us in
                collecting statistics and potentially on diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.RequestContext.ApiEvent">
            <summary>
            One and only one ApiEvent is associated with each request.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters">
            <summary>
            This class is responsible for merging app level and request level parameters. 
            Not all parameters need to be merged - app level parameters can be accessed via AppConfig property
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters.Authority">
            <summary>
            Authority is the URI used by MSAL for communication and storage
            During a request it can be updated: 
            - with the preferred environment
            - with actual tenant
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters.Claims">
            <summary>
            Indicates if the user configured claims via .WithClaims. Not affected by Client Capabilities
            </summary>
            <remarks>If user configured claims, request should bypass cache</remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters.OnBeforeTokenRequestHandler">
            <summary>
            If set, MSAL should add the key / value pairs from the provider to the token endpoint instead of generating a client assertion
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters.UserAssertion">
            <remarks>
            User assertion is null when <see cref="M:Microsoft.Identity.Client.ILongRunningWebApi.AcquireTokenInLongRunningProcess(System.Collections.Generic.IEnumerable{System.String},System.String)"/> is called.
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters.LongRunningOboCacheKey">
            <summary>
            User-provided cache key for long-running OBO flow.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Internal.Requests.IntegratedWindowsAuthRequest">
            <summary>
                Handles requests that are non-interactive. Currently MSAL supports Integrated Windows Auth (IWA).
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Internal.Requests.InteractiveRequest">
            <summary>
            This class decides the workflow of an interactive request. The business rules are: 
            
            1. If WithBroker is set to true
            1.1. Attempt to invoke the broker and get the token
            1.2. If this fails, e.g. if broker is not installed, the use a web view (goto 2)
            
            2. Use a webview and get an auth code and look at the auth code
            2.1. If the auth code has a special format, showing that a broker is needed then. Invoke the broker flow (step 1) with a broker installation URL
            2.2. Otherwise exchange the auth code for tokens (normal authorize_code grant)
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Internal.Requests.RequestBase">
            <summary>
            Base class for all flows. Use by implementing <see cref="M:Microsoft.Identity.Client.Internal.Requests.RequestBase.ExecuteAsync(System.Threading.CancellationToken)"/>
            and optionally calling protected helper methods such as SendTokenRequestAsync, which know
            how to use all params when making the request.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Internal.Requests.RequestBase.GetOverriddenScopes(System.Collections.Generic.ISet{System.String})">
            <summary>
            Return a custom set of scopes to override the default MSAL logic of merging
            input scopes with reserved scopes (openid, profile etc.)
            Leave as is / return null otherwise
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Internal.Requests.RequestBase.CreateRegionDetails(Microsoft.Identity.Client.TelemetryCore.Internal.Events.ApiEvent)">
            <summary>
            Creates the region Details
            </summary>
            <param name="apiEvent"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest">
            <summary>
                Handles requests that are non-interactive. Currently MSAL supports Integrated Windows Auth.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Internal.AuthCodeRequestComponent">
            <summary>
            Responsible for getting an auth code
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Internal.SilentRequestHelper.ProcessFetchInBackground(Microsoft.Identity.Client.Cache.Items.MsalAccessTokenCacheItem,System.Func{System.Threading.Tasks.Task{Microsoft.Identity.Client.AuthenticationResult}},Microsoft.Identity.Client.Core.ILoggerAdapter,Microsoft.Identity.Client.Internal.IServiceBundle,Microsoft.Identity.Client.TelemetryCore.Internal.Events.ApiEvent.ApiIds)">
            <summary>
            Fire and forget the fetch action on a background thread.
            Do not change to Task and do not await it.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.ServiceBundle.ApplicationLogger">
            <summary>
            This logger does not contain a correlation ID and should be used only when the correlation ID is not available
            i.e. before a request exists
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.ServiceBundle.HttpManager">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.ServiceBundle.WsTrustWebRequestManager">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.ServiceBundle.PlatformProxy">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Identity.Client.Internal.ServiceBundle.Config">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.Core.ILoggerAdapter.IsLoggingEnabled(Microsoft.Identity.Client.LogLevel)">
            <summary>
            For expensive logging messages (e.g. when the log message evaluates a variable), 
            it is better to check the log level ahead of time so as not to evaluate the expensive message and then discard it.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Core.MsalLoggerExtensions">
            <summary>
            Extension methods for ILoggerAdapter
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Core.MsalLoggerExtensions.Info(Microsoft.Identity.Client.Core.ILoggerAdapter,System.Func{System.String})">
            <summary>
            This method is used to avoid string concatenation when the log level is not enabled.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Core.MsalLoggerExtensions.InfoPii(Microsoft.Identity.Client.Core.ILoggerAdapter,System.Func{System.String},System.Func{System.String})">
            <summary>
            This method is used to avoid string concatenation when the log level is not enabled.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.IntuneAppProtectionPolicyRequiredException">
            <summary>
            This exception is thrown when Intune requires app protection policy.
            The information in this exception can be used by app to obtain the required 
            enrollment ID from Mobile App Management (MAM) SDK.
            See https://aka.ms/msal-net-trueMAM
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IntuneAppProtectionPolicyRequiredException.Upn">
            <summary>
            UPN of the user
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IntuneAppProtectionPolicyRequiredException.AccountUserId">
            <summary>
            Local account id
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IntuneAppProtectionPolicyRequiredException.TenantId">
            <summary>
            Tenant ID of the App
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IntuneAppProtectionPolicyRequiredException.AuthorityUrl">
            <summary>
            Authority URL
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.IntuneAppProtectionPolicyRequiredException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the exception class with a specified
            error code and error message.
            </summary>
            <param name="errorCode">
            The error code returned by the service or generated by the client. This is the code you can rely on
            for exception handling.
            </param>
            <param name="errorMessage">The error message that explains the reason for the exception.</param>
        </member>
        <member name="T:Microsoft.Identity.Client.IPublicClientApplication">
            <summary>
            Represents public client applications - desktop and mobile applications.
            </summary>
            <remarks>
            Public client applications are not trusted to safely keep application secrets and therefore they can only access web APIs in the name of the authenticating user.
            See <see href="https://aka.ms/msal-net-client-applications">Client Applications</see>.
            <para>
            Unlike <see cref="T:Microsoft.Identity.Client.IConfidentialClientApplication"/>, public clients are unable to securely store secrets on a client device and as a result do not require the use of a client secret.
            </para>
            <para>
            The redirect URI needed for interactive authentication is automatically determined by the library. It does not need to be passed explicitly in the constructor. Depending
            on the authentication strategy (e.g., through the <see href="https://aka.ms/msal-net-wam">Web Account Manager</see>, the Authenticator app, web browser, etc.), different redirect URIs will be used by MSAL. Redirect URIs must always be configured for the application in the Azure Portal.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.IPublicClientApplication.IsSystemWebViewAvailable">
            <summary>
            Tells if the application can use the system web browser, therefore enabling single-sign-on with web applications.
            By default, MSAL will try to use a system browser on the mobile platforms, if it is available.
            See <see href="https://aka.ms/msal-net-uses-web-browser">our documentation</see> for more details.
            </summary>
            <remarks>
            On Windows, macOS, and Linux a system browser can always be used, except in cases where there is no UI (e.g., a SSH session).
            On Android, the browser must support tabs.
            </remarks>
            <returns>Returns <c>true</c> if MSAL can use the system web browser.</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Acquires a token interactively for the specified scopes. Either a system browser, an embedded browser, or a broker will 
            handle this request, depending on the version of .NET framework used and on configuration. 
            For Microsoft Entra applications, a broker is recommended. See <see href="https://aka.ms/msal-net-wam">Windows Broker</see>.
            This method does not look in the token cache, but stores the result in it. Before calling this method, use other methods 
            such as <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/> to check the token cache.
            See <see href="https://aka.ms/adal-to-msal-net/interactive">Interactive Authentication</see>.
            </summary>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <returns>A builder enabling you to add optional parameters before executing the token request.</returns>
            <remarks>The user will be signed-in interactively and will consent to scopes, as well as perform a multi-factor authentication step if such a policy was enabled in the Azure AD tenant.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenWithDeviceCode(System.Collections.Generic.IEnumerable{System.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})">
            <summary>
            Acquires a token on a device without a web browser by letting the user authenticate on
            another device.
            This method does not look in the token cache, but stores the result in it. Before calling this method, use other methods 
            such as <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/> to check the token cache.
            </summary>
            <remarks>
            The token acquisition is done in two steps:
            <list type="bullet">
            <item><description>The method first acquires a device code from the authority and returns it to the caller via
            the <paramref name="deviceCodeResultCallback"/>. This callback takes care of interacting with the user
            to direct them to authenticate (i.e., to a specific URL, with a code).</description></item>
            <item><description>The method then proceeds to poll for the security
            token which is granted upon successful login by the user based on the device code information.</description></item>
            </list>
            See <see href="https://aka.ms/msal-device-code-flow">Device Code Flow</see>.
            </remarks>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <param name="deviceCodeResultCallback">Callback containing information to show the user about how to authenticate and enter the device code.</param>
            <returns>A builder enabling you to add optional parameters before executing the token request.</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            <para>
            This API is no longer recommended and will be deprecated in future versions in favor of 
            similar functionality via <see href="https://aka.ms/msal-net-wam">the Windows broker (WAM)</see>.
            WAM does not require any setup for desktop apps to login with the Windows account.
            </para>
            <para>
            Acquires a token non-interactively for the signed-in user in Windows
            via Integrated Windows Authentication.
            The account used in this overrides is pulled from the operating system as the current user principal name.
            This method does not look in the token cache, but stores the result in it. Before calling this method, use other methods 
            such as <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/> to check the token cache.
            </para>
            </summary>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <returns>A builder enabling you to add optional parameters before executing the token request.</returns>
            <remarks>
            See <see href="https://aka.ms/msal-net-iwa">our documentation</see> for more details.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)">
            <summary>
            Non-interactive request to acquire a token via username and password authentication.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="username">Identifier of the user application requests token on behalf.
            Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="password">User password as a secure string.</param>
            <returns>A builder enabling you to add optional parameters before executing the token request</returns>
            <remarks>
            Available only for .NET Framework and .NET Core applications. See <see href="https://aka.ms/msal-net-up">our documentation</see> for details.       
            .NET no longer recommends using SecureString and MSAL puts the plaintext value of the password on the wire, as required by the OAuth protocol. See <see href="https://docs.microsoft.com/dotnet/api/system.security.securestring?view=net-6.0#remarks">SecureString documentation</see> for details.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Acquires a token without user interaction using username and password authentication.
            This method does not look in the token cache, but stores the result in it. Before calling this method, use other methods 
            such as <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/> to check the token cache.
            </summary>
            <param name="scopes">Scopes requested to access a protected API.</param>
            <param name="username">Identifier of the user application requests token on behalf.
            Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="password">User password as a string.</param>
            <returns>A builder enabling you to add optional parameters before executing the token request.</returns>
            <remarks>
            Available only for .NET Framework and .NET Core applications. See <see href="https://aka.ms/msal-net-up">our documentation</see> for details.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Interactive request to acquire token for the specified scopes. The user is required to select an account
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
            <remarks>The user will be signed-in interactively if needed,
            and will consent to scopes and do multi-factor authentication if such a policy was enabled in the Azure AD tenant.</remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Interactive request to acquire token for the specified scopes. The user will need to sign-in but an account will be proposed
            based on the <paramref name="loginHint"/>
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)">
            <summary>
            Interactive request to acquire token for the specified scopes. The user will need to sign-in but an account will be proposed
            based on the provided <paramref name="account"/>
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.Prompt,System.String)">
            <summary>
            Interactive request to acquire token for a login with control of the UI behavior and possibility of passing extra query parameters like additional claims
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,Microsoft.Identity.Client.Prompt,System.String)">
            <summary>
            Interactive request to acquire token for an account with control of the UI behavior and possibility of passing extra query parameters like additional claims
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.Prompt,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Interactive request to acquire token for a given login, with the possibility of controlling the user experience, passing extra query
            parameters, providing extra scopes that the user can pre-consent to, and overriding the authority pre-configured in the application
            </summary>
            <param name="scopes">scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="extraScopesToConsent">scopes that you can request the end user to consent upfront, in addition to the scopes for the protected web API
            for which you want to acquire a security token.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,Microsoft.Identity.Client.Prompt,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Interactive request to acquire token for a given account, with the possibility of controlling the user experience, passing extra query
            parameters, providing extra scopes that the user can pre-consent to, and overriding the authority pre-configured in the application
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="extraScopesToConsent">Scopes that you can request the end user to consent upfront, in addition to the scopes for the protected web API
            for which you want to acquire a security token.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for the specified scopes. The interactive window will be parented to the specified
            window. The user will be required to select an account
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
            <remarks>The user will be signed-in interactively if needed,
            and will consent to scopes and do multi-factor authentication if such a policy was enabled in the Azure AD tenant.</remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for the specified scopes. The interactive window will be parented to the specified
            window. . The user will need to sign-in but an account will be proposed
            based on the <paramref name="loginHint"/>
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and login</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for the specified scopes. The user will need to sign-in but an account will be proposed
            based on the provided <paramref name="account"/>
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.Prompt,System.String,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for a login with control of the UI behavior and possibility of passing extra query parameters like additional claims
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,Microsoft.Identity.Client.Prompt,System.String,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for an account with control of the UI behavior and possibility of passing extra query parameters like additional claims
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.Prompt,System.String,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for a given login, with the possibility of controlling the user experience, passing extra query
            parameters, providing extra scopes that the user can pre-consent to, and overriding the authority pre-configured in the application
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="extraScopesToConsent">Scopes that you can request the end user to consent upfront, in addition to the scopes for the protected web API
            for which you want to acquire a security token.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,Microsoft.Identity.Client.Prompt,System.String,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for a given account, with the possibility of controlling the user experience, passing extra query
            parameters, providing extra scopes that the user can pre-consent to, and overriding the authority pre-configured in the application
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="extraScopesToConsent">Scopes that you can request the end user to consent upfront, in addition to the scopes for the protected web API
            for which you want to acquire a security token.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePasswordAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)">
            <summary>
            Non-interactive request to acquire a security token from the authority, via Username/Password Authentication.
            See https://aka.ms/msal-net-up.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="username">Identifier of the user application requests token on behalf.
            Generally in UserPrincipalName (UPN) format, e.g. john.doe@contoso.com</param>
            <param name="securePassword">User password.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenWithDeviceCodeAsync(System.Collections.Generic.IEnumerable{System.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})">
            <summary>
            Acquires a security token on a device without a web browser, by letting the user authenticate on
            another device. This is done in two steps:
            <list type="bullet">
            <item><description>the method first acquires a device code from the authority and returns it to the caller via
            the <paramref name="deviceCodeResultCallback"/>. This callback takes care of interacting with the user
            to direct them to authenticate (to a specific URL, with a code)</description></item>
            <item><description>The method then proceeds to poll for the security
            token which is granted upon successful login by the user based on the device code information</description></item>
            </list>
            See https://aka.ms/msal-device-code-flow.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="deviceCodeResultCallback">Callback containing information to show the user about how to authenticate and enter the device code.</param>
            <returns>Authentication result containing a token for the requested scopes and for the user who has authenticated on another device with the code</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenWithDeviceCodeAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})">
            <summary>
            Acquires a security token on a device without a web browser, by letting the user authenticate on
            another device, with possibility of passing extra parameters. This is done in two steps:
            <list type="bullet">
            <item><description>the method first acquires a device code from the authority and returns it to the caller via
            the <paramref name="deviceCodeResultCallback"/>. This callback takes care of interacting with the user
            to direct them to authenticate (to a specific URL, with a code)</description></item>
            <item><description>The method then proceeds to poll for the security
            token which is granted upon successful login by the user based on the device code information</description></item>
            </list>
            See https://aka.ms/msal-device-code-flow.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="deviceCodeResultCallback">Callback containing information to show the user about how to authenticate and enter the device code.</param>
            <returns>Authentication result containing a token for the requested scopes and for the user who has authenticated on another device with the code</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenWithDeviceCodeAsync(System.Collections.Generic.IEnumerable{System.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Acquires a security token on a device without a web browser, by letting the user authenticate on
            another device, with possibility of cancelling the token acquisition before it times out. This is done in two steps:
            <list type="bullet">
            <item><description>the method first acquires a device code from the authority and returns it to the caller via
            the <paramref name="deviceCodeResultCallback"/>. This callback takes care of interacting with the user
            to direct them to authenticate (to a specific URL, with a code)</description></item>
            <item><description>The method then proceeds to poll for the security
            token which is granted upon successful login by the user based on the device code information. This step is cancelable</description></item>
            </list>
            See https://aka.ms/msal-device-code-flow.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="deviceCodeResultCallback">The callback containing information to show the user about how to authenticate and enter the device code.</param>
            <param name="cancellationToken">A CancellationToken which can be triggered to cancel the operation in progress.</param>
            <returns>Authentication result containing a token for the requested scopes and for the user who has authenticated on another device with the code</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenWithDeviceCodeAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Acquires a security token on a device without a web browser, by letting the user authenticate on
            another device, with possibility of passing extra query parameters and cancelling the token acquisition before it times out. This is done in two steps:
            <list type="bullet">
            <item><description>the method first acquires a device code from the authority and returns it to the caller via
            the <paramref name="deviceCodeResultCallback"/>. This callback takes care of interacting with the user
            to direct them to authenticate (to a specific URL, with a code)</description></item>
            <item><description>The method then proceeds to poll for the security
            token which is granted upon successful login by the user based on the device code information. This step is cancelable</description></item>
            </list>
            See https://aka.ms/msal-device-code-flow.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="deviceCodeResultCallback">The callback containing information to show the user about how to authenticate and enter the device code.</param>
            <param name="cancellationToken">A CancellationToken which can be triggered to cancel the operation in progress.</param>
            <returns>Authentication result containing a token for the requested scopes and for the user who has authenticated on another device with the code</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuthAsync(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Non-interactive request to acquire a security token for the signed-in user in Windows, via Integrated Windows Authentication.
            See https://aka.ms/msal-net-iwa.
            The account used in this overrides is pulled from the operating system as the current user principal name
            </summary>
            <remarks>
            On Windows Universal Platform, the following capabilities need to be provided:
            Enterprise Authentication, Private Networks (Client and Server), User Account Information
            </remarks>
            <param name="scopes">Scopes requested to access a protected API</param>
            <returns>Authentication result containing a token for the requested scopes and for the currently signed-in user in Windows</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuthAsync(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Non-interactive request to acquire a security token for the signed-in user in Windows, via Integrated Windows Authentication.
            See https://aka.ms/msal-net-iwa.
            The account used in this overrides is pulled from the operating system as the current user principal name
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="username">Identifier of the user account for which to acquire a token with Integrated Windows authentication.
            Generally in UserPrincipalName (UPN) format, e.g. john.doe@contoso.com</param>
            <returns>Authentication result containing a token for the requested scopes and for the currently signed-in user in Windows</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.TokenCacheCallback">
            <summary>
            Notification for certain token cache interactions during token acquisition. This delegate is
            used in particular to provide a custom token cache serialization.
            See https://aka.ms/aka.ms/msal-net-token-cache-serialization
            </summary>
            <param name="args">Arguments related to the cache item impacted</param>
        </member>
        <member name="T:Microsoft.Identity.Client.ITokenCache">
            <summary>
            This is the interface that implements the public access to cache operations.
            With CacheV2, this should only be necessary if the caller is persisting
            the cache in their own store, since this will provide the serialize/deserialize
            and before/after notifications used in that scenario.
            See https://aka.ms/aka.ms/msal-net-token-cache-serialization
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.SetBeforeAccess(Microsoft.Identity.Client.TokenCacheCallback)">
            <summary>
            Sets a delegate to be notified before any library method accesses the cache. This gives an option to the
            delegate to deserialize a cache entry for the application and accounts specified in the <see cref="T:Microsoft.Identity.Client.TokenCacheNotificationArgs"/>.
            See https://aka.ms/msal-net-token-cache-serialization.
            If you need async/task-based callbacks, please use SetBeforeAccessAsync instead.
            </summary>
            <param name="beforeAccess">Delegate set in order to handle the cache deserialization</param>
            <remarks>When the delegate is used to deserialize the cache, it might
            want to call <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/></remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.SetAfterAccess(Microsoft.Identity.Client.TokenCacheCallback)">
            <summary>
            Sets a delegate to be notified after any library method accesses the cache. This gives an option to the
            delegate to serialize a cache entry for the application and accounts specified in the <see cref="T:Microsoft.Identity.Client.TokenCacheNotificationArgs"/>.
            See https://aka.ms/msal-net-token-cache-serialization.
            If you need async/task-based callbacks, please use SetAfterAccessAsync instead.
            </summary>
            <param name="afterAccess">Delegate set in order to handle the cache serialization in the case where the <see cref="P:Microsoft.Identity.Client.TokenCache.HasStateChanged"/>
            member of the cache is <c>true</c></param>
            <remarks>In the case where the delegate is used to serialize the cache entirely (not just a row), it might
            want to call <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/></remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.SetBeforeWrite(Microsoft.Identity.Client.TokenCacheCallback)">
            <summary>
            Sets a delegate called before any library method writes to the cache. This gives an option to the delegate
            to reload the cache state from a row in database and lock that row. That database row can then be unlocked in the delegate
            registered with <see cref="M:Microsoft.Identity.Client.ITokenCache.SetAfterAccess(Microsoft.Identity.Client.TokenCacheCallback)"/>
            If you need async/task-based callbacks, please use SetBeforeWriteAsync instead.
            </summary>
            <param name="beforeWrite">Delegate set in order to prepare the cache serialization</param>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.SetBeforeAccessAsync(System.Func{Microsoft.Identity.Client.TokenCacheNotificationArgs,System.Threading.Tasks.Task})">
            <summary>
            Sets a delegate to be notified before any library method accesses the cache. This gives an option to the
            delegate to deserialize a cache entry for the application and accounts specified in the <see cref="T:Microsoft.Identity.Client.TokenCacheNotificationArgs"/>.
            See https://aka.ms/msal-net-token-cache-serialization.
            This provides the same functionality as SetBeforeAccess but it provides for an async/task-based callback.
            </summary>
            <param name="beforeAccess">Delegate set in order to handle the cache deserialization</param>
            <remarks>In the case where the delegate is used to deserialize the cache, it might
            want to call <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/></remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.SetAfterAccessAsync(System.Func{Microsoft.Identity.Client.TokenCacheNotificationArgs,System.Threading.Tasks.Task})">
            <summary>
            Sets a delegate to be notified after any library method accesses the cache. This gives an option to the
            delegate to serialize a cache entry for the application and accounts specified in the <see cref="T:Microsoft.Identity.Client.TokenCacheNotificationArgs"/>.
            See https://aka.ms/msal-net-token-cache-serialization.
            This provides the same functionality as SetAfterAccess but it provides for an async/task-based callback.
            </summary>
            <param name="afterAccess">Delegate set in order to handle the cache serialization in the case where the <see cref="P:Microsoft.Identity.Client.TokenCache.HasStateChanged"/>
            member of the cache is <c>true</c></param>
            <remarks>In the case where the delegate is used to serialize the cache entirely (not just a row), it might
            want to call <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/></remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.SetBeforeWriteAsync(System.Func{Microsoft.Identity.Client.TokenCacheNotificationArgs,System.Threading.Tasks.Task})">
            <summary>
            Sets a delegate called before any library method writes to the cache. This gives an option to the delegate
            to reload the cache state from a row in database and lock that row. That database row can then be unlocked in the delegate
            registered with <see cref="M:Microsoft.Identity.Client.ITokenCache.SetAfterAccess(Microsoft.Identity.Client.TokenCacheCallback)"/>
            This provides the same functionality as SetBeforeWrite but it provides for an async/task-based callback.
            </summary>
            <param name="beforeWrite">Delegate set in order to prepare the cache serialization</param>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.SerializeMsalV3">
            <summary>
            Functionality replaced by <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/> and is accessible in TokenCacheNotificationArgs.
            </summary>
            <returns>Byte stream representation of the cache</returns>
            <remarks>
            This is the recommended format for maintaining SSO state between applications.
            <see cref="M:Microsoft.Identity.Client.ITokenCache.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCache.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.DeserializeMsalV3(System.Byte[],System.Boolean)">
            <summary>
            Functionality replaced by <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> and is accessible in TokenCacheNotificationArgs.
            </summary>
            <param name="msalV3State">Byte stream representation of the cache</param>
            <param name="shouldClearExistingCache">
            Set to true to clear MSAL cache contents.  Defaults to false.
            You would want to set this to true if you want the cache contents in memory to be exactly what's on disk.
            You would want to set this to false if you want to merge the contents of what's on disk with your current in memory state.
            </param>
            <remarks>
            This is the recommended format for maintaining SSO state between applications.
            <see cref="M:Microsoft.Identity.Client.ITokenCache.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCache.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.SerializeMsalV2">
            <summary>
            Functionality replaced by <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2"/> and is accessible in TokenCacheNotificationArgs.
            </summary>
            <returns>Byte stream representation of the cache</returns>
            <remarks>
            <see cref="M:Microsoft.Identity.Client.ITokenCache.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCache.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.DeserializeMsalV2(System.Byte[])">
            <summary>
            Functionality replaced by <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV2(System.Byte[])"/> and is accessible in TokenCacheNotificationArgs.
            </summary>
            <param name="msalV2State">Byte stream representation of the cache</param>
            <remarks>
            <see cref="M:Microsoft.Identity.Client.ITokenCache.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCache.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.SerializeAdalV3">
            <summary>
            Functionality replaced by <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/> and is accessible in TokenCacheNotificationArgs.
            </summary>
            <returns>Byte stream representation of the cache</returns>
            <remarks>
            <see cref="M:Microsoft.Identity.Client.ITokenCache.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCache.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.DeserializeAdalV3(System.Byte[])">
            <summary>
            Functionality replaced by <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/> and is accessible in TokenCacheNotificationArgs.
            See https://aka.ms/msal-net-4x-cache-breaking-change
            </summary>
            <param name="adalV3State">Byte stream representation of the cache</param>
            <remarks>
            <see cref="M:Microsoft.Identity.Client.ITokenCache.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCache.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.Serialize">
            <summary>
            Functionality replaced by <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2"/>. See https://aka.ms/msal-net-4x-cache-breaking-change
            /// </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.Deserialize(System.Byte[])">
            <summary>
            Functionality replaced by <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV2(System.Byte[])"/>.  See https://aka.ms/msal-net-4x-cache-breaking-change        /// </summary>
            <param name="msalV2State"></param>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.SerializeUnifiedAndAdalCache">
            <summary>
            Functionality replaced by <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2"/> and <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/>
            See https://aka.ms/msal-net-4x-cache-breaking-change
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCache.DeserializeUnifiedAndAdalCache(Microsoft.Identity.Client.Cache.CacheData)">
            <summary>
            Functionality replaced by <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV2(System.Byte[])"/> and <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/>
            See https://aka.ms/msal-net-4x-cache-breaking-change
            </summary>
            <param name="cacheData"></param>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCacheInternal.FindRefreshTokenAsync(Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters,System.String)">
            <summary>
            Returns a RT for the request. If familyId is specified, it tries to return the FRT.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCacheInternal.IsFociMemberAsync(Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters,System.String)">
            <summary>
            FOCI - check in the app metadata to see if the app is part of the family
            </summary>
            <returns>null if unknown, true or false if app metadata has details</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCacheInternal.HasTokensNoLocks">
            <summary>
            Shows if MSAL's in-memory token cache has any kind of RT or non-expired AT. Does not trigger a cache notification.
            Ignores ADAL's cache.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCacheInternal.IsAppSubscribedToSerializationEvents">
            <summary>
            True when MSAL has been configured to fire the serialization events i.e. external token caching is enabled.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.ITokenCacheSerializer">
            <summary>
            This interface will be available in TokenCacheNotificationArgs callback to enable serialization/deserialization of the cache.
            </summary>
            <remarks>
            The methods in this class are not thread safe. It is expected that they will be called from the token cache callbacks, 
            registered via SetBeforeAccess, SetAfterAccess. These callbacks thread safe because they are triggered sequentially.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3">
            <summary>
            Serializes the token cache to the MSAL.NET 3.x cache format, which is compatible with other MSAL desktop libraries, including MSAL.NET 4.x, MSAL for Python and MSAL for Java.
            If you need to maintain SSO between an application using ADAL 3.x and this application using MSAL 3.x or later,
            you might also want to serialize and deserialize with <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/>,
            otherwise just use <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/>.
            </summary>
            <returns>Byte stream representation of the cache</returns>
            <remarks>
            This is the recommended format for maintaining SSO state between applications.
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)">
            <summary>
            Deserializes the token cache to the MSAL.NET 3.x cache format, which is compatible with other MSAL desktop libraries, including MSAL.NET 4.x, MSAL for Python and MSAL for Java.
            If you need to maintain SSO between an application using ADAL 3.x and this application using MSAL 3.x or later,
            you might also want to serialize and deserialize with <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/>,
            otherwise just use <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/>.
            </summary>
            <param name="msalV3State">Byte stream representation of the cache</param>
            <param name="shouldClearExistingCache">
            Set to true to clear MSAL cache contents.  Defaults to false.
            You would want to set this to true if you want the cache contents in memory to be exactly what's on disk.
            You would want to set this to false if you want to merge the contents of what's on disk with your current in memory state.
            </param>
            <remarks>
            This is the recommended format for maintaining SSO state between applications.
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3">
             <summary>
             Serializes a part of the token cache - the refresh tokens - to the ADAL.NET 3.x cache format. 
             If you need to maintain SSO between an application using ADAL 3.x and this application using MSAL 3.x or later,
             use <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/> in addition to <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/>.
            
             See https://aka.ms/adal-to-msal-net/cache for details on how to use this advanced API correctly.
             </summary>
             <returns>Byte stream representation of the cache</returns>
             <remarks>
             Do not use <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/> without also using <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/>, 
             because only refresh tokens are exported in this format. Your applications will not cache access token and id tokens, 
             and will instead need to get them from the identity provider (AAD), which will eventually throttle you.
             Later versions of ADAL (4.x and 5.x) use the same cache format as MSAL.
             Only <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
             ADAL to MSAL cache interop is only available for public client scenarios and for web site scenario. 
             </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])">
            <summary>
            Deserializes a part of the token cache - the refresh tokens - to the ADAL.NET 3.x cache format.         
            This API should only be used to maintain SSO between an application using ADAL 3.x and this application using MSAL 3.x or later.
            Use <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/> in addition to <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/>.
            
            See https://aka.ms/adal-to-msal-net/cache for details on how to use this advanced API correctly.
            </summary>
            <param name="adalV3State">Byte stream representation of the cache</param>
            <remarks>
            Do not use <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/> without also using <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/>, 
            because only refresh tokens are exported in this format. Your applications will not cache access token and id tokens, 
            and will instead need to get them from the identity provider (AAD), which will eventually throttle you.
            Later versions of ADAL (4.x and 5.x) use the same cache format as MSAL.
            Only <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            ADAL to MSAL cache interop is only available for public client scenarios and for web site scenario. 
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2">
            <summary>
            Serializes the token cache to the MSAL.NET 2.x unified cache format, which is compatible with ADAL.NET v4 and other MSAL.NET v2 applications.
            If you need to maintain SSO between an application using ADAL 3.x or MSAL 2.x and this application using MSAL 3.x,
            you might also want to serialize and deserialize with <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/> or <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV2(System.Byte[])"/>,
            otherwise just use <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/>.
            </summary>
            <returns>Byte stream representation of the cache</returns>
            <remarks>
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV2(System.Byte[])">
            <summary>
            Deserializes the token cache to the MSAL.NET 2.x cache format, which is compatible with ADAL.NET v4 and other MSAL.NET v2 applications.
            If you need to maintain SSO between an application using ADAL 3.x or MSAL 2.x and this application using MSAL 3.x,
            you might also want to serialize and deserialize with <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/> or <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV2(System.Byte[])"/>,
            otherwise just use <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/>.
            </summary>
            <param name="msalV2State">Byte stream representation of the cache</param>
            <remarks>
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="T:Microsoft.Identity.Client.Kerberos.KerberosKeyTypes">
            <summary>
            The Kerberos key types used in this assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Kerberos.KerberosKeyTypes.None">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Kerberos.KerberosKeyTypes.DecCbcCrc">
            <summary>
            dec-cbc-crc ([RFC3961] section 6.2.3)
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Kerberos.KerberosKeyTypes.DesCbcMd5">
            <summary>
            des-cbc-md5 ([RFC3961] section 6.2.1)
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Kerberos.KerberosKeyTypes.Aes128CtsHmacSha196">
            <summary>
            aes128-cts-hmac-sha1-96 ([RFC3962] section 6)
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Kerberos.KerberosKeyTypes.Aes256CtsHmacSha196">
            <summary>
            aes256-cts-hmac-sha1-96 ([RFC3962] section 6)
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket">
            <summary>
            Class for Kerberos tickets that are included as claims and used as a supplemental token in an OAuth/OIDC
            protocol response.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket.ClientKey">
            <summary>
            Get or Sets the client key used to encrypt the client portion of the ticket.
            This is optional. This will be null if KeyType is null.
            This MUST be protected in the protocol response.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket.KeyType">
            <summary>
            Get or Sets the client key type.This is optional.This will be null if ClientKey is null.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket.KerberosMessageBuffer">
            <summary>
            Get or Sets the Base64 encoded KERB_MESSAGE_BUFFER
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket.ErrorMessage">
            <summary>
            Get or Sets the error message that server encountered when creating a ticket granting ticket.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket.Realm">
            <summary>
            Get or Sets the Kerberos realm/domain name.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket.ServicePrincipalName">
            <summary>
            Get or Sets the target service principal name (SPN).
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket.ClientName">
            <summary>
            Get or Sets the client name. Depending on the ticket, this can be either a UserPrincipalName or SamAccountName.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket"/> class with error message.
            </summary>
            <param name="errorMessage">Error message to be set.</param>
        </member>
        <member name="M:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket.ToString">
            <summary>
            Creates a string representation of the data captured in the Kerberos supplemental ticket.
            </summary>
            <returns>A string containing the realm, service principal name, client name, and key type.</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicketManager">
            <summary>
            Helper class to manage Kerberos Ticket Claims.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicketManager.FromIdToken(System.String)">
            <summary>
            Creates a <see cref="T:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket"/> object from given ID token string..
            </summary>
            <param name="idToken">ID token string.</param>
            <returns>A <see cref="T:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket"/> object if a Kerberos Ticket Claim exists in the given
            idToken parameter and is parsed correctly. Null, otherwise.</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicketManager.SaveToWindowsTicketCache(Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket)">
            <summary>
            Save current Kerberos Ticket to current user's Ticket Cache.
            </summary>
            <param name="ticket">Kerberos ticket object to save.</param>
            <remarks>Throws <see cref="T:System.ArgumentException"/> when given ticket parameter is not a valid Kerberos supplemental ticket.
            Throws <see cref="T:System.ComponentModel.Win32Exception"/> if error occurs while saving ticket information into Ticket Cache.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicketManager.SaveToWindowsTicketCache(Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket,System.Int64)">
            <summary>
            Save current Kerberos Ticket to current user's Ticket Cache. Windows only.
            </summary>
            <param name="ticket">Kerberos ticket object to save.</param>
            <param name="logonId">The Logon Id of the user owning the ticket cache.
            The default of 0 represents the currently logged on user.</param>
            <remarks>Throws <see cref="T:System.ArgumentException"/> when given ticket parameter is not a valid Kerberos supplemental ticket.
            Throws <see cref="T:System.ComponentModel.Win32Exception"/> if error occurs while saving ticket information into Ticket Cache.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicketManager.GetKerberosTicketFromWindowsTicketCache(System.String)">
            <summary>
            Reads a Kerberos Service Ticket associated with given service principal name from
            current user's Ticket Cache. Windows only.
            </summary>
            <param name="servicePrincipalName">Service principal name to find associated Kerberos Ticket.</param>
            <returns>Byte stream of searched Kerberos Ticket information if exists. Null, otherwise.</returns>
            <remarks>
            Throws <see cref="T:System.ComponentModel.Win32Exception"/> if error occurs while searching ticket information from Ticket Cache.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicketManager.GetKerberosTicketFromWindowsTicketCache(System.String,System.Int64)">
            <summary>
            Reads a Kerberos Service Ticket associated with given service principal name from
            current user's Ticket Cache.
            </summary>
            <param name="servicePrincipalName">Service principal name to find associated Kerberos Ticket.</param>
            <param name="logonId">The Logon Id of the user owning the ticket cache.
            The default of 0 represents the currently logged on user.</param>
            <returns>Byte stream of searched Kerberos Ticket information if exists. Null, otherwise.</returns>
            <remarks>
            Throws <see cref="T:System.ComponentModel.Win32Exception"/> if error occurs while searching ticket information from Ticket Cache.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicketManager.GetKrbCred(Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket)">
            <summary>
            Gets the KRB-CRED Kerberos Ticket information as byte stream.
            </summary>
            <param name="ticket">Kerberos ticket object to save.</param>
            <returns>Byte stream representation of KRB-CRED Kerberos Ticket if it contains valid ticket information.
            Null, otherwise.</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicketManager.GetKerberosTicketClaim(System.String,Microsoft.Identity.Client.Kerberos.KerberosTicketContainer)">
            <summary>
            Generate a Kerberos Ticket Claim string.
            </summary>
            <param name="servicePrincipalName">Service principal name to use.</param>
            <param name="ticketContainer">Ticket container to use.</param>
            <returns>A Kerberos Ticket Claim string if valid service principal name was given. Empty string, otherwise.</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.Kerberos.KerberosTicketContainer">
            <summary>
            Declares the type of container to use for Kerberos Ticket Claim.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Kerberos.KerberosTicketContainer.IdToken">
            <summary>
            Use the Id token as the Kerberos Ticket container.
            (NOTE) MSAL will read out Kerberos Service Ticket from received id token, cache into current user's
            ticket cache, and return it as KerberosSupplementalTicket object in AuthenticationResult.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.Kerberos.KerberosTicketContainer.AccessToken">
            <summary>
            Use the Access Token as the Kerberos Ticket container.
            (NOTE) MSAL will not read out Kerberos Service Ticket from received access token. Caller should handle
            received access token directly to use for next service request.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.LogCallback">
            <summary>
            Callback delegate that allows application developers to consume logs, and handle them in a custom manner. This
            callback is set using <see cref="M:Microsoft.Identity.Client.BaseAbstractApplicationBuilder`1.WithLogging(Microsoft.Identity.Client.LogCallback,System.Nullable{Microsoft.Identity.Client.LogLevel},System.Nullable{System.Boolean},System.Nullable{System.Boolean})"/>.
            If <c>PiiLoggingEnabled</c> is set to <c>true</c>, when registering the callback this method will receive the messages twice:
            once with the <c>containsPii</c> parameter equals <c>false</c> and the message without PII,
            and a second time with the <c>containsPii</c> parameter equals to <c>true</c> and the message might contain PII.
            In some cases (when the message does not contain PII), the message will be the same.
            For details see https://aka.ms/msal-net-logging
            </summary>
            <param name="level">Log level of the log message to process</param>
            <param name="message">Pre-formatted log message</param>
            <param name="containsPii">Indicates if the log message contains Organizational Identifiable Information (OII)
            or Personally Identifiable Information (PII) nor not.
            If <see cref="P:Microsoft.Identity.Client.Logger.PiiLoggingEnabled"/> is set to <c>false</c> then this value is always false.
            Otherwise it will be <c>true</c> when the message contains PII.</param>
            <seealso cref="T:Microsoft.Identity.Client.Logger"/>
        </member>
        <member name="T:Microsoft.Identity.Client.LogLevel">
            <summary>
            Represents log level in MSAL.
            For details, see <see href="https://aka.ms/msal-net-logging">MSAL logging</see>.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.LogLevel.Always">
            <summary>
            Includes logs of important health metrics to help with diagnostics of MSAL operations.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.LogLevel.Error">
            <summary>
            Includes logs when something has gone wrong and an error was generated. Used for debugging and identifying problems.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.LogLevel.Warning">
            <summary>
            Includes logs in scenarios when there hasn't necessarily been an error or failure, but are intended for diagnostics and pinpointing problems.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.LogLevel.Info">
            <summary>
            Default. Includes logs of general events intended for informational purposes, not necessarily intended for debugging.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.LogLevel.Verbose">
            <summary>
            Includes logs of the full details of library behavior.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.ManagedIdentityApplication">
            <summary>
            Class to be used for managed identity applications (on Azure resources like App Services, Virtual Machines, Azure Arc, Service Fabric and Cloud Shell).
            </summary>
            <remarks>
            Managed identity can be enabled on Azure resources as a system assigned managed identity or a user assigned managed identity.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ManagedIdentityApplication.AcquireTokenForManagedIdentity(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.ManagedIdentityApplication.GetManagedIdentitySource">
            <summary>
            Detects and returns the managed identity source available on the environment.
            </summary>
            <returns>Managed identity source detected on the environment if any.</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.ManagedIdentity.AbstractManagedIdentity">
            <summary>
            Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ManagedIdentitySource.cs
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.ManagedIdentity.AppServiceManagedIdentitySource">
            <summary>
            Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/AppServiceManagedIdentitySource.cs
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.ManagedIdentity.AzureArcManagedIdentitySource">
            <summary>
            Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/AzureArcManagedIdentitySource.cs
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.ManagedIdentity.CloudShellManagedIdentitySource">
            <summary>
            Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/CloudShellManagedIdentitySource.cs
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.ManagedIdentity.ImdsManagedIdentitySource">
            <summary>
            Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ImdsManagedIdentitySource.cs
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityClient">
            <summary>
            Class to initialize a managed identity and identify the service.
            Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ManagedIdentityClient.cs
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityResponse.AccessToken">
            <summary>
            The requested access token.
            </summary>
            <remarks>When you call a secured REST API, the token is embedded in the Authorization 
            request header field as a "bearer" token, 
            allowing the API to authenticate the caller.</remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityResponse.ExpiresOn">
            <summary>
            The timespan when the access token expires.
            </summary>
            <remarks>The date is represented as the number of seconds from "1970-01-01T0:0:0Z UTC" 
            (corresponds to the token's exp claim).</remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityResponse.Resource">
            <summary>
            The resource the access token was requested for.
            </summary>
            <remarks>Which matches the resource query string parameter of the request.</remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityResponse.TokenType">
            <summary>
            The type of token returned by the Managed Identity endpoint.
            </summary>
            <remarks>which is a "Bearer" access token, which means the resource 
            can give access to the bearer of this token.</remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityResponse.ClientId">
            <summary>
            A unique identifier generated by Azure AD for the Azure Resource.
            </summary>
            <remarks>The Client ID is a GUID value that uniquely identifies the application 
            and its configuration within the identity platform</remarks>
        </member>
        <member name="T:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource">
            <summary>
            Managed identity sources supported. The library will handle these internally. 
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource.None">
            <summary>
            Default.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource.Imds">
            <summary>
            The source to acquire token for managed identity is IMDS.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource.AppService">
            <summary>
            The source to acquire token for managed identity is App Service.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource.AzureArc">
            <summary>
            The source to acquire token for managed identity is Azure Arc.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource.CloudShell">
            <summary>
            The source to acquire token for managed identity is Cloud Shell.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource.ServiceFabric">
            <summary>
            The source to acquire token for managed identity is Service Fabric.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource.DefaultToImds">
            <summary>
            Indicates that the source is defaulted to IMDS since no environment variables are set.
            This is used to detect the managed identity source.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.ManagedIdentity.ServiceFabricManagedIdentitySource">
            <summary>
            Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ServiceFabricManagedIdentitySource.cs
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Metrics">
            <summary>
            MSAL-wide metrics.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Metrics.TotalAccessTokensFromIdP">
            <summary>
            Total tokens obtained by MSAL from the identity provider.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Metrics.TotalAccessTokensFromCache">
            <summary>
            Total tokens obtained by MSAL from cache.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Metrics.TotalAccessTokensFromBroker">
            <summary>
            Total tokens obtained by MSAL from broker.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Metrics.TotalDurationInMs">
            <summary>
            Total time, in milliseconds, spent in MSAL for all requests.  Aggregate of <see cref="P:Microsoft.Identity.Client.AuthenticationResultMetadata.DurationTotalInMs"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.IUser">
            <summary>
            In MSAL.NET 1.x, was representing a User. From MSAL 2.x use <see cref="T:Microsoft.Identity.Client.IAccount"/> which represents an account
            (a user has several accounts). See https://aka.ms/msal-net-2-released for more details.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IUser.DisplayableId">
            <summary>
            In MSAL.NET 1.x was the displayable ID of a user. From MSAL 2.x use the <see cref="P:Microsoft.Identity.Client.IAccount.Username"/> of an account.
            See https://aka.ms/msal-net-2-released for more details
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IUser.Name">
            <summary>
            In MSAL.NET 1.x was the name of the user (which was not very useful as the concatenation of
            some claims). From MSAL 2.x rather use <see cref="P:Microsoft.Identity.Client.IAccount.Username"/>. See https://aka.ms/msal-net-2-released for more details.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IUser.IdentityProvider">
            <summary>
            In MSAL.NET 1.x was the URL of the identity provider (e.g. `https://login.microsoftonline.com/tenantId`).
            From MSAL.NET 2.x use <see cref="P:Microsoft.Identity.Client.IAccount.Environment"/> which retrieves the host only (e.g. login.microsoftonline.com).
            See https://aka.ms/msal-net-2-released for more details.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.IUser.Identifier">
            <summary>
            In MSAL.NET 1.x was an identifier for the user in the guest tenant.
            From MSAL.NET 2.x, use <see cref="P:Microsoft.Identity.Client.IAccount.HomeAccountId"/><see cref="P:Microsoft.Identity.Client.AccountId.Identifier"/> to get
            the user identifier (globally unique across tenants). See https://aka.ms/msal-net-2-released for more details.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.TokenCacheNotificationArgs">
            <summary>
            Contains parameters used by the MSAL call accessing the cache.
            See also <see cref="T:Microsoft.Identity.Client.ITokenCacheSerializer"/> which contains methods
            to customize the cache serialization.
            For more details about the token cache see https://aka.ms/msal-net-web-token-cache
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.User">
            <summary>
            In MSAL.NET 1.x, returned the user who signed in to get the authentication result. From MSAL 2.x
            rather use <see cref="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.Account"/> instead. See https://aka.ms/msal-net-2-released for more details.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCacheNotificationArgs.#ctor(Microsoft.Identity.Client.ITokenCacheSerializer,System.String,Microsoft.Identity.Client.IAccount,System.Boolean,System.Boolean,System.String,System.Boolean,System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)">
            <summary>
            This constructor is for test purposes only. It allows apps to unit test their MSAL token cache implementation code.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCacheNotificationArgs.#ctor(Microsoft.Identity.Client.ITokenCacheSerializer,System.String,Microsoft.Identity.Client.IAccount,System.Boolean,System.Boolean,System.String,System.Boolean,System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken,System.Guid)">
            <summary>
            This constructor is for test purposes only. It allows apps to unit test their MSAL token cache implementation code.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCacheNotificationArgs.#ctor(Microsoft.Identity.Client.ITokenCacheSerializer,System.String,Microsoft.Identity.Client.IAccount,System.Boolean,System.Boolean,System.String,System.Boolean,System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken,System.Guid,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            This constructor is for test purposes only. It allows apps to unit test their MSAL token cache implementation code.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCacheNotificationArgs.#ctor(Microsoft.Identity.Client.ITokenCacheSerializer,System.String,Microsoft.Identity.Client.IAccount,System.Boolean,System.Boolean,System.String,System.Boolean,System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken,System.Guid,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.IdentityModel.Abstractions.IIdentityLogger,System.Boolean,Microsoft.Identity.Client.TelemetryCore.TelemetryClient.TelemetryData)">
            <summary>
            This constructor is for test purposes only. It allows apps to unit test their MSAL token cache implementation code.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.TokenCache">
            <summary>
            Gets the <see cref="T:Microsoft.Identity.Client.ITokenCacheSerializer"/> involved in the transaction
            </summary>
            <remarks><see cref="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.TokenCache" > objects</see> implement this interface.</remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.ClientId">
            <summary>
            Gets the ClientId (application ID) of the application involved in the cache transaction
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.Account">
            <summary>
            Gets the account involved in the cache transaction.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.HasStateChanged">
            <summary>
            Indicates whether the state of the cache has changed, for example when tokens are being added or removed.
            Not all cache operations modify the state of the cache.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.IsApplicationCache">
            <summary>
            Indicates whether the cache change occurred in the UserTokenCache or in the AppTokenCache.
            </summary>
            <remarks>
            The Application Cache is used in Client Credential grant,  which is not available on all platforms.
            See https://aka.ms/msal-net-app-cache-serialization for details.
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.SuggestedCacheKey">
            <summary>
            A suggested token cache key, which can be used with general purpose storage mechanisms that allow 
            storing key-value pairs and key based retrieval. Useful in applications that store one token cache per user, 
            the recommended pattern for web apps.
            
            The value is: 
            
            <list type="bullet">
            <item><description><c>homeAccountId</c> for <c>AcquireTokenSilent</c>, <c>GetAccount(homeAccountId)</c>, <c>RemoveAccount</c> and when writing tokens on confidential client calls</description></item>
            <item><description><c>"{clientId}__AppTokenCache"</c> for <c>AcquireTokenForClient</c></description></item>
            <item><description><c>"{clientId}_{tenantId}_AppTokenCache"</c> for <c>AcquireTokenForClient</c> when using a tenant specific authority</description></item>
            <item><description>the hash of the original token for <c>AcquireTokenOnBehalfOf</c></description></item>
            </list>
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.HasTokens">
            <summary>
            Is true when at least one non-expired access token exists in the cache. 
            </summary>
            <remarks>  
            If this flag is false in the OnAfterAccessAsync notification - the node can be deleted from the underlying storage (e.g. IDistributedCache).
            MSAL takes into consideration access tokens expiration when computing this flag. Use in conjunction with SuggestedCacheExpiry.
            If a refresh token exists in the cache, this property will always be true.
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.CancellationToken">
            <summary>
            The cancellation token that was passed to AcquireToken* flow via ExecuteAsync(CancellationToken). Can be passed
            along to the custom token cache implementation.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.CorrelationId">
            <summary>
            The correlation id associated with the request. See <see cref="M:Microsoft.Identity.Client.BaseAbstractAcquireTokenParameterBuilder`1.WithCorrelationId(System.Guid)"/>
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.RequestScopes">
            <summary>
            Scopes specified in the AcquireToken* method. 
            </summary>
            <remarks>
            Note that Azure Active Directory may return more scopes than requested, however this property will only contain the scopes requested.
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.RequestTenantId">
            <summary>
            Tenant Id specified in the AcquireToken* method, if any.         
            </summary>
            <remarks>
            Note that if "common" or "organizations" is specified, Azure Active Directory discovers the host tenant for the user, and the tokens 
            are associated with it. This property is not impacted.</remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.SuggestedCacheExpiry">
            <summary>
            Suggested value of the expiry, to help determining the cache eviction time. 
            This value is <b>only</b> set on the <code>OnAfterAccess</code> delegate, on a cache write
            operation (that is when <code>args.HasStateChanged</code> is <code>true</code>) and when the cache node contains only access tokens.        
            In all other cases it's <code>null</code>. 
            </summary> 
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.IdentityLogger">
            <summary>
            Identity Logger provided at the time of application creation Via WithLogging(IIdentityLogger, bool)/>
            Calling the log function will automatically add MSAL formatting to the message. For details see https://aka.ms/msal-net-logging
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.PiiLoggingEnabled">
            <summary>
            Boolean used to determine if Personally Identifiable Information (PII) logging is enabled.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCacheNotificationArgs.TelemetryData">
            <summary>
            Cache Details contains the details of L1/ L2 cache for telemetry logging.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.PublicClientApplication">
            <inheritdoc cref="T:Microsoft.Identity.Client.IPublicClientApplication"/>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.#ctor(System.String)">
            <summary>
            Constructor of the application. It will use `https://login.microsoftonline.com/common` as the default authority.
            </summary>
            <param name="clientId">Client ID (also known as App ID) of the application as registered in the
            application registration portal (https://aka.ms/msal-net-register-app)/. REQUIRED</param>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.#ctor(System.String,System.String)">
            <summary>
            Constructor of the application.
            </summary>
            <param name="clientId">Client ID (also named Application ID) of the application as registered in the
            application registration portal (https://aka.ms/msal-net-register-app)/. REQUIRED</param>
            <param name="authority">Authority of the security token service (STS) from which MSAL.NET will acquire the tokens.
            Usual authorities are:
            <list type="bullet">
            <item><description><c>https://login.microsoftonline.com/tenant/</c>, where <c>tenant</c> is the tenant ID of the Azure AD tenant
            or a domain associated with this Azure AD tenant, in order to sign-in user of a specific organization only</description></item>
            <item><description><c>https://login.microsoftonline.com/common/</c> to signing users with any work and school accounts or Microsoft personal account</description></item>
            <item><description><c>https://login.microsoftonline.com/organizations/</c> to signing users with any work and school accounts</description></item>
            <item><description><c>https://login.microsoftonline.com/consumers/</c> to signing users with only personal Microsoft account (live)</description></item>
            </list>
            Note that this setting needs to be consistent with what is declared in the application registration portal
            </param>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Interactive request to acquire token for the specified scopes. The user is required to select an account
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
            <remarks>The user will be signed-in interactively if needed,
            and will consent to scopes and do multi-factor authentication if such a policy was enabled in the Azure AD tenant.</remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Interactive request to acquire token for the specified scopes. The user will need to sign-in but an account will be proposed
            based on the <paramref name="loginHint"/>
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)">
            <summary>
            Interactive request to acquire token for the specified scopes. The user will need to sign-in but an account will be proposed
            based on the provided <paramref name="account"/>
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.Prompt,System.String)">
            <summary>
            Interactive request to acquire token for a login with control of the UI prompt and possibility of passing extra query parameters like additional claims
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,Microsoft.Identity.Client.Prompt,System.String)">
            <summary>
            Interactive request to acquire token for an account with control of the UI prompt and possibility of passing extra query parameters like additional claims
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.Prompt,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Interactive request to acquire token for a given login, with the possibility of controlling the user experience, passing extra query
            parameters, providing extra scopes that the user can pre-consent to, and overriding the authority pre-configured in the application
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="extraScopesToConsent">Scopes that you can request the end user to consent upfront, in addition to the scopes for the protected web API
            for which you want to acquire a security token.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,Microsoft.Identity.Client.Prompt,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Interactive request to acquire token for a given account, with the possibility of controlling the user experience, passing extra query
            parameters, providing extra scopes that the user can pre-consent to, and overriding the authority pre-configured in the application
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="extraScopesToConsent">Scopes that you can request the end user to consent upfront, in addition to the scopes for the protected web API
            for which you want to acquire a security token.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for the specified scopes. The interactive window will be parented to the specified
            window. The user will be required to select an account
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
            <remarks>The user will be signed-in interactively if needed,
            and will consent to scopes and do multi-factor authentication if such a policy was enabled in the Azure AD tenant.</remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for the specified scopes. The interactive window will be parented to the specified
            window. The user will need to sign-in but an account will be proposed
            based on the <paramref name="loginHint"/>
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and login</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for the specified scopes. The user will need to sign-in but an account will be proposed
            based on the provided <paramref name="account"/>
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.Prompt,System.String,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for a login with control of the UI prompt and possibility of passing extra query parameters like additional claims
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,Microsoft.Identity.Client.Prompt,System.String,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for an account with control of the UI prompt and possibility of passing extra query parameters like additional claims
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.Prompt,System.String,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for a given login, with the possibility of controlling the user experience, passing extra query
            parameters, providing extra scopes that the user can pre-consent to, and overriding the authority pre-configured in the application
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="loginHint">Identifier of the user. Generally in UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c></param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="extraScopesToConsent">scopes that you can request the end user to consent upfront, in addition to the scopes for the protected web API
            for which you want to acquire a security token.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount,Microsoft.Identity.Client.Prompt,System.String,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.Identity.Client.UIParent)">
            <summary>
            Interactive request to acquire token for a given account, with the possibility of controlling the user experience, passing extra query
            parameters, providing extra scopes that the user can pre-consent to, and overriding the authority pre-configured in the application
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="account">Account to use for the interactive token acquisition. See <see cref="T:Microsoft.Identity.Client.IAccount"/> for ways to get an account</param>
            <param name="prompt">Designed interactive experience for the user.</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="extraScopesToConsent">scopes that you can request the end user to consent upfront, in addition to the scopes for the protected web API
            for which you want to acquire a security token.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <param name="parent">Object containing a reference to the parent window/activity. REQUIRED for Xamarin.Android only.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenByUsernamePasswordAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)">
            <summary>
            Non-interactive request to acquire a security token from the authority, via Username/Password Authentication.
            Available only on .net desktop and .net core. See https://aka.ms/msal-net-up for details.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="username">Identifier of the user application requests token on behalf.
            Generally in UserPrincipalName (UPN) format, e.g. john.doe@contoso.com</param>
            <param name="securePassword">User password.</param>
            <returns>Authentication result containing a token for the requested scopes and account</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenWithDeviceCodeAsync(System.Collections.Generic.IEnumerable{System.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})">
            <summary>
            Acquires a security token on a device without a web browser, by letting the user authenticate on
            another device. This is done in two steps:
            <list type="bullet">
            <item><description>the method first acquires a device code from the authority and returns it to the caller via
            the <paramref name="deviceCodeResultCallback"/>. This callback takes care of interacting with the user
            to direct them to authenticate (to a specific URL, with a code)</description></item>
            <item><description>The method then proceeds to poll for the security
            token which is granted upon successful login by the user based on the device code information</description></item>
            </list>
            See https://aka.ms/msal-device-code-flow.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="deviceCodeResultCallback">Callback containing information to show the user about how to authenticate and enter the device code.</param>
            <returns>Authentication result containing a token for the requested scopes and for the user who has authenticated on another device with the code</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenWithDeviceCodeAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})">
            <summary>
            Acquires a security token on a device without a web browser, by letting the user authenticate on
            another device, with possibility of passing extra parameters. This is done in two steps:
            <list type="bullet">
            <item><description>the method first acquires a device code from the authority and returns it to the caller via
            the <paramref name="deviceCodeResultCallback"/>. This callback takes care of interacting with the user
            to direct them to authenticate (to a specific URL, with a code)</description></item>
            <item><description>The method then proceeds to poll for the security
            token which is granted upon successful login by the user based on the device code information</description></item>
            </list>
            See https://aka.ms/msal-device-code-flow.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="deviceCodeResultCallback">Callback containing information to show the user about how to authenticate and enter the device code.</param>
            <returns>Authentication result containing a token for the requested scopes and for the user who has authenticated on another device with the code</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenWithDeviceCodeAsync(System.Collections.Generic.IEnumerable{System.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Acquires a security token on a device without a web browser, by letting the user authenticate on
            another device, with possibility of cancelling the token acquisition before it times out. This is done in two steps:
            <list type="bullet">
            <item><description>the method first acquires a device code from the authority and returns it to the caller via
            the <paramref name="deviceCodeResultCallback"/>. This callback takes care of interacting with the user
            to direct them to authenticate (to a specific URL, with a code)</description></item>
            <item><description>The method then proceeds to poll for the security
            token which is granted upon successful login by the user based on the device code information. This step is cancelable</description></item>
            </list>
            See https://aka.ms/msal-device-code-flow.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="deviceCodeResultCallback">The callback containing information to show the user about how to authenticate and enter the device code.</param>
            <param name="cancellationToken">A CancellationToken which can be triggered to cancel the operation in progress.</param>
            <returns>Authentication result containing a token for the requested scopes and for the user who has authenticated on another device with the code</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenWithDeviceCodeAsync(System.Collections.Generic.IEnumerable{System.String},System.String,System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Acquires a security token on a device without a web browser, by letting the user authenticate on
            another device, with possibility of passing extra query parameters and cancelling the token acquisition before it times out. This is done in two steps:
            <list type="bullet">
            <item><description>the method first acquires a device code from the authority and returns it to the caller via
            the <paramref name="deviceCodeResultCallback"/>. This callback takes care of interacting with the user
            to direct them to authenticate (to a specific URL, with a code)</description></item>
            <item><description>The method then proceeds to poll for the security
            token which is granted upon successful login by the user based on the device code information. This step is cancelable</description></item>
            </list>
            See https://aka.ms/msal-device-code-flow.
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="extraQueryParameters">This parameter will be appended as is to the query string in the HTTP authentication request to the authority.
            This is expected to be a string of segments of the form <c>key=value</c> separated by an ampersand character.
            The parameter can be null.</param>
            <param name="deviceCodeResultCallback">The callback containing information to show the user about how to authenticate and enter the device code.</param>
            <param name="cancellationToken">A CancellationToken which can be triggered to cancel the operation in progress.</param>
            <returns>Authentication result containing a token for the requested scopes and for the user who has authenticated on another device with the code</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.Microsoft#Identity#Client#IByRefreshToken#AcquireTokenByRefreshTokenAsync(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Acquires an access token from an existing refresh token and stores it and the refresh token into
            the application user token cache, where it will be available for further AcquireTokenSilentAsync calls.
            This method can be used in migration to MSAL from ADAL v2 and in various integration
            scenarios where you have a RefreshToken available.
            (see https://aka.ms/msal-net-migration-adal2-msal2)
            </summary>
            <param name="scopes">Scope to request from the token endpoint.
            Setting this to null or empty will request an access token, refresh token and ID token with default scopes</param>
            <param name="refreshToken">The refresh token (for example previously obtained from ADAL 2.x)</param>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenByIntegratedWindowsAuthAsync(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Non-interactive request to acquire a security token for the signed-in user in Windows, via Integrated Windows Authentication.
            See https://aka.ms/msal-net-iwa.
            The account used in this overrides is pulled from the operating system as the current user principal name
            </summary>
            <remarks>
            On Windows Universal Platform, the following capabilities need to be provided:
            Enterprise Authentication, Private Networks (Client and Server), User Account Information
            Supported on .net desktop 
            </remarks>
            <param name="scopes">Scopes requested to access a protected API</param>
            <returns>Authentication result containing a token for the requested scopes and for the currently signed-in user in Windows</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenByIntegratedWindowsAuthAsync(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Non-interactive request to acquire a security token for the signed-in user in Windows, via Integrated Windows Authentication.
            See https://aka.ms/msal-net-iwa.
            The account used in this overrides is pulled from the operating system as the current user principal name
            </summary>
            <param name="scopes">Scopes requested to access a protected API</param>
            <param name="username">Identifier of the user account for which to acquire a token with Integrated Windows authentication.
            Generally in UserPrincipalName (UPN) format, e.g. john.doe@contoso.com</param>
            <returns>Authentication result containing a token for the requested scopes and for the currently signed-in user in Windows</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.#ctor(System.String,System.String,Microsoft.Identity.Client.TokenCache)">
            <summary>
            Constructor to create application instance. This constructor is only available for Desktop and NetCore apps
            </summary>
            <param name="clientId">Client id of the application</param>
            <param name="authority">Default authority to be used for the application</param>
            <param name="userTokenCache">Instance of TokenCache.</param>
        </member>
        <member name="P:Microsoft.Identity.Client.PublicClientApplication.OperatingSystemAccount">
            <summary>
            A special account value that indicates that the current operating system account should be used 
            to log the user in. Not all operating systems and authentication flows support this concept, in which 
            case calling <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/> will throw an <see cref="T:Microsoft.Identity.Client.MsalUiRequiredException"/>. 
            </summary>
            <remarks>
            Currently only the Windows broker is able to login with the current operating system user. For additional details, see <see href="https://aka.ms/msal-net-wam">the documentation on the Windows broker</see>.
            </remarks>
        </member>
        <member name="P:Microsoft.Identity.Client.PublicClientApplication.IsSystemWebViewAvailable">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.IsEmbeddedWebViewAvailable">
            <summary>
            Returns <c>true</c> if MSAL can use an embedded web view (web browser).
            </summary>
            <remarks>
            All .NET Framework applications will use the legacy web view. .NET 6 and .NET Core applications must use the <see href="https://www.nuget.org/packages/Microsoft.Identity.Client.Desktop">Microsoft.Identity.Client.Desktop</see> package with WebView2. .NET 6 for Windows comes with WebView2 by default.
            WebView2 UI is only shown for non-AAD authorities.
            Refer to <see href="https://aka.ms/msal-net-webview2">our documentation</see> for additional details.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.IsUserInteractive">
            <summary>
            Returns <c>false</c> when the application runs in headless mode (e.g., when SSH-d into a Linux machine).
            Browsers (web views) and brokers cannot be used if there is no UI support. For those scenarios, use <see cref="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenWithDeviceCode(System.Collections.Generic.IEnumerable{System.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.IsBrokerAvailable">
            <summary>
            Returns <c>true</c> if an authentication broker can be used.
            This method is only needed for mobile scenarios which support Mobile Application Management (MAM). In other cases, use <c>WithBroker</c>, which will fall back to use a browser if an authentication broker is unavailable.
            </summary>
            <remarks>
            <list type="bullet">
            <item><description>On Windows, the broker (WAM) can be used on Windows 10 and is always installed. See https://aka.ms/msal-net-wam </description></item>
            <item><description>On Mac, Linux, and older versions of Windows a broker is not available.</description></item>
            <item><description>In .NET 6 apps, target <c>net6.0-windows10.0.17763.0</c> for all Windows versions and target <c>net6.0</c> for Linux and Mac.</description></item>
            <item><description>In .NET classic or .NET Core 3.1 apps, install Microsoft.Identity.Client.Desktop first and call <c>WithDesktopFeatures()</c>.</description></item>
            <item><description>In mobile apps, the device must be Intune joined and Authenticator or Company Portal must be installed. See https://aka.ms/msal-brokers </description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenWithDeviceCode(System.Collections.Generic.IEnumerable{System.String},System.Func{Microsoft.Identity.Client.DeviceCodeResult,System.Threading.Tasks.Task})">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.Microsoft#Identity#Client#IByRefreshToken#AcquireTokenByRefreshToken(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.Security.SecureString)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Identity.Client.PublicClientApplication.IsProofOfPossessionSupportedByClient">
            <summary>
            Used to determine if the currently available broker is able to perform Proof-of-Possession.
            </summary>
            <returns>Boolean indicating if Proof-of-Possession is supported</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate">
            <summary>
            Component to be used with confidential client applications like web apps/APIs.
            This component supports Subject Name + Issuer authentication in order to help, in the future,
            Azure AD certificates rollover.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            [V2 API] Acquires token from the service for the confidential client using the client credentials flow. (See https://aka.ms/msal-net-client-credentials)
            This method enables application developers to achieve easy certificates roll-over
            in Azure AD: this method will send the public certificate to Azure AD
            along with the token request, so that Azure AD can use it to validate the subject name based on a trusted issuer policy.
            This saves the application admin from the need to explicitly manage the certificate rollover
            (either via portal or PowerShell/CLI operation).
            </summary>
            <param name="scopes">Array of scopes requested for resource</param>
            <returns>Authentication result containing application token for the requested scopes</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            [V2 API] Acquires token from the service for the confidential client using the client credentials flow. (See https://aka.ms/msal-net-client-credentials)
            This method attempts to look up valid access token in the cache unless<paramref name="forceRefresh"/> is true
            This method enables application developers to achieve easy certificates roll-over
            in Azure AD: this method will send the public certificate to Azure AD
            along with the token request, so that Azure AD can use it to validate the subject name based on a trusted issuer policy.
            This saves the application admin from the need to explicitly manage the certificate rollover
            (either via portal or PowerShell/CLI operation)
            </summary>
            <param name="scopes">Array of scopes requested for resource</param>
            <param name="forceRefresh">If TRUE, API will ignore the access token in the cache and attempt to acquire new access token using client credentials</param>
            <returns>Authentication result containing application token for the requested scopes</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)">
             <summary>
            [V2 API] Acquires token using On-Behalf-Of flow. (See https://aka.ms/msal-net-on-behalf-of)
             </summary>
             <param name="scopes">Array of scopes requested for resource</param>
             <param name="userAssertion">Instance of UserAssertion containing user's token.</param>
             <returns>Authentication result containing token of the user for the requested scopes</returns>
        </member>
        <member name="M:Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion,System.String)">
            <summary>
            [V2 API] Acquires token using On-Behalf-Of flow. (See https://aka.ms/msal-net-on-behalf-of)
            </summary>
            <param name="scopes">Array of scopes requested for resource</param>
            <param name="userAssertion">Instance of UserAssertion containing user's token.</param>
            <param name="authority">Specific authority for which the token is requested. Passing a different value than configured does not change the configured value</param>
            <returns>Authentication result containing token of the user for the requested scopes</returns>
        </member>
        <member name="T:Microsoft.Identity.Client.UIBehavior">
            <summary>
            Structure containing static members that you can use to specify how the interactive overrides
            of AcquireTokenAsync in <see cref="T:Microsoft.Identity.Client.PublicClientApplication"/> should prompt the user.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Logger">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Logger.LogCallback">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Logger.Level">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Logger.PiiLoggingEnabled">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Logger.DefaultLoggingEnabled">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Telemetry">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.Telemetry.Receiver">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Telemetry.GetInstance">
            <summary>
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.Telemetry.TelemetryOnFailureOnly">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Telemetry.RegisterReceiver(Microsoft.Identity.Client.Telemetry.Receiver)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Telemetry.HasRegisteredReceiver">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.Telemetry.Microsoft#Identity#Client#TelemetryCore#ITelemetryReceiver#HandleTelemetryEvents(System.Collections.Generic.List{System.Collections.Generic.Dictionary{System.String,System.String}})">
            <summary>
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.ClientAssertionCertificate">
            <summary>
            Certificate for a client assertion. This class is used in one of the constructors of <see cref="T:Microsoft.Identity.Client.ClientCredential"/>. ClientCredential
            is itself used in the constructor of <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication"/> to pass to Azure AD a shared secret (registered in the
            Azure AD application)
            </summary>
            <seealso cref="T:Microsoft.Identity.Client.ClientCredential"/> for the constructor of <seealso cref="T:Microsoft.Identity.Client.ClientCredential"/>
            with a certificate, and <seealso cref="T:Microsoft.Identity.Client.ConfidentialClientApplication"/>
            <remarks>To understand the difference between public client applications and confidential client applications, see https://aka.ms/msal-net-client-applications</remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.ClientAssertionCertificate.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Constructor to create certificate information used in <see cref="T:Microsoft.Identity.Client.ClientCredential"/>
            to instantiate a <see cref="T:Microsoft.Identity.Client.ClientCredential"/> used in the constructors of <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication"/>
            </summary>
            <param name="certificate">The X509 certificate used as credentials to prove the identity of the application to Azure AD.</param>
        </member>
        <member name="P:Microsoft.Identity.Client.ClientAssertionCertificate.MinKeySizeInBits">
            <summary>
            Gets minimum X509 certificate key size in bits
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.ClientAssertionCertificate.Certificate">
            <summary>
            Gets the X509 certificate used as credentials to prove the identity of the application to Azure AD.
            </summary>
        </member>
        <member name="T:Microsoft.Identity.Client.ClientCredential">
            <summary>
            Meant to be used in confidential client applications, an instance of <c>ClientCredential</c> is passed
            to the constructors of (<see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication"/>)
            as credentials proving that the application (the client) is what it claims it is. These credentials can be
            either a client secret (an application password) or a certificate.
            This class has one constructor for each case.
            These credentials are added in the application registration portal (in the secret section).
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.ClientCredential.#ctor(Microsoft.Identity.Client.ClientAssertionCertificate)">
            <summary>
            Constructor of client (application) credentials from a <see cref="T:Microsoft.Identity.Client.ClientAssertionCertificate"/>
            </summary>
            <param name="certificate">contains information about the certificate previously shared with AAD at application
            registration to prove the identity of the application (the client) requesting the tokens.</param>
        </member>
        <member name="M:Microsoft.Identity.Client.ClientCredential.#ctor(System.String)">
            <summary>
            Constructor of client (application) credentials from a client secret, also known as the application password.
            </summary>
            <param name="secret">Secret string previously shared with AAD at application registration to prove the identity
            of the application (the client) requesting the tokens.</param>
        </member>
        <member name="T:Microsoft.Identity.Client.UIParent">
             <summary>
            
             </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.UIParent.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.UIParent.#ctor(System.Object,System.Boolean)">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.UIParent.IsSystemWebviewAvailable">
            <summary>
            Checks Android device for chrome packages.
            Returns true if chrome package for launching system webview is enabled on device.
            Returns false if chrome package is not found.
            </summary>
            <example>
            The following code decides, in a Xamarin.Forms app, which browser to use based on the presence of the
            required packages.
            <code>
            bool useSystemBrowser = UIParent.IsSystemWebviewAvailable();
            App.UIParent = new UIParent(Xamarin.Forms.Forms.Context as Activity, !useSystemBrowser);
            </code>
            </example>
        </member>
        <member name="T:Microsoft.Identity.Client.TokenCache">
            <summary>
            Token cache storing access and refresh tokens for accounts
            This class is used in the constructors of <see cref="T:Microsoft.Identity.Client.PublicClientApplication"/> and <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication"/>.
            In the case of ConfidentialClientApplication, two instances are used, one for the user token cache, and one for the application
            token cache (in the case of applications using the client credential flows).
            </summary>
            <summary>
            IMPORTANT: this class is performance critical; any changes must be benchmarked using Microsoft.Identity.Test.Performance.
            More information about how to test and what data to look for is in https://aka.ms/msal-net-performance-testing.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCache.HasStateChanged">
            <summary>
            Gets or sets the flag indicating whether the state of the cache has changed.
            MSAL methods set this flag after any change.
            Caller applications should reset the flag after serializing and persisting the state of the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SerializeUnifiedAndAdalCache">
            <summary>
            Serializes the entire token cache in both the ADAL V3 and unified cache formats.
            </summary>
            <returns>Serialized token cache <see cref="T:Microsoft.Identity.Client.Cache.CacheData"/></returns>
            <remarks>
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.DeserializeUnifiedAndAdalCache(Microsoft.Identity.Client.Cache.CacheData)">
            <summary>
            Deserializes the token cache from a serialization blob in both format (ADAL V3 format, and unified cache format)
            </summary>
            <param name="cacheData">Array of bytes containing serialize cache data</param>
            <remarks>
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.Serialize">
            <summary>
            Serializes using the <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2"/> serializer.
            Obsolete: Please use specialized Serialization methods.
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2"/> replaces <see cref="M:Microsoft.Identity.Client.TokenCache.Serialize"/>.
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> Is our recommended way of serializing/deserializing.
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3"/> For interoperability with ADAL.NET v3.
            </summary>
            <returns>array of bytes, <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2"/></returns>
            <remarks>
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.Deserialize(System.Byte[])">
            <summary>
            Deserializes the token cache from a serialization blob in the unified cache format
            Obsolete: Please use specialized Deserialization methods.
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV2(System.Byte[])"/> replaces <see cref="M:Microsoft.Identity.Client.TokenCache.Deserialize(System.Byte[])"/>
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> Is our recommended way of serializing/deserializing.
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(System.Byte[])"/> For interoperability with ADAL.NET v3
            </summary>
            <param name="msalV2State">Array of bytes containing serialized MSAL.NET V2 cache data</param>
            <remarks>
            <see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3"/>/<see cref="M:Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(System.Byte[],System.Boolean)"/> is compatible with other MSAL libraries such as MSAL for Python and MSAL for Java.
            <paramref name="msalV2State"/>Is a Json blob containing access tokens, refresh tokens, id tokens and accounts information.
            </remarks>
        </member>
        <member name="T:Microsoft.Identity.Client.TokenCache.TokenCacheNotification">
            <summary>
            Notification for certain token cache interactions during token acquisition. This delegate is
            used in particular to provide a custom token cache serialization
            </summary>
            <param name="args">Arguments related to the cache item impacted</param>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SerializeAdalV3">
            <summary>
            This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.DeserializeAdalV3(System.Byte[])">
            <summary>
            This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SerializeMsalV2">
            <summary>
            This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.DeserializeMsalV2(System.Byte[])">
            <summary>
            This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SerializeMsalV3">
            <summary>
            This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.DeserializeMsalV3(System.Byte[],System.Boolean)">
            <summary>
            This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.#ctor">
            <summary>
            Constructor of a token cache. This constructor is left for compatibility with MSAL 2.x.
            The recommended way to get a cache is by using <see cref="P:Microsoft.Identity.Client.IClientApplicationBase.UserTokenCache"/>
            and <c>IConfidentialClientApplication.AppTokenCache</c> once the app is created.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SetIosKeychainSecurityGroup(System.String)">
            <summary>
            Sets the security group to be used with the iOS Keychain. This function should not be used by external customers. It <see href="https://github.com/AzureAD/microsoft-authentication-library-for-dotnet/issues/2121">will be removed</see> in a future version of MSAL.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.DeleteAccessTokensWithIntersectingScopes(Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters,System.Collections.Generic.IEnumerable{System.String},System.String,System.Collections.Generic.HashSet{System.String},System.String,System.String)">
            <summary>
            delete all cache entries with intersecting scopes.
            this should not happen but we have this as a safe guard
            against multiple matches.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.CalculateSuggestedCacheExpiry(Microsoft.Identity.Client.Cache.ITokenCacheAccessor,Microsoft.Identity.Client.Core.ILoggerAdapter)">
            <summary>
            Important note: we should not be suggesting expiration dates that are in the past, as it breaks some cache implementations.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.Microsoft#Identity#Client#ITokenCacheInternal#FindAccessTokenAsync(Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters)">
            <summary>
            IMPORTANT: this class is performance critical; any changes must be benchmarked using Microsoft.Identity.Test.Performance.
            More information about how to test and what data to look for is in https://aka.ms/msal-net-performance-testing.
            
            Scenario: client_creds with default in-memory cache can get to ~500k tokens
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.ExpireAllAccessTokensForTestAsync">
            <summary>
            For testing purposes only. Expires ALL access tokens in memory and fires OnAfterAccessAsync event with no cache key
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.Microsoft#Identity#Client#ITokenCacheInternal#GetAccountsAsync(Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters)">
            <remarks>
            Get accounts should not make a network call, if possible. This can be achieved if
            all the environments in the token cache are known to MSAL, as MSAL keeps a list of
            known environments in <see cref="T:Microsoft.Identity.Client.Instance.Discovery.KnownMetadataProvider"/>
            </remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.RemoveOboTokensInternal(System.String,Microsoft.Identity.Client.Internal.RequestContext)">
            <summary>
            Removes OBO tokens stored in the cache. Note that the cache is internally and externally partitioned by the oboKey.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCache.BeforeAccess">
            <summary>
            Notification method called before any library method accesses the cache.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCache.BeforeWrite">
            <summary>
            Notification method called before any library method writes to the cache. This notification can be used to reload
            the cache state from a row in database and lock that row. That database row can then be unlocked in the
            <see cref="P:Microsoft.Identity.Client.TokenCache.AfterAccess"/>notification.
            </summary>
        </member>
        <member name="P:Microsoft.Identity.Client.TokenCache.AfterAccess">
            <summary>
            Notification method called after any library method accesses the cache.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SetBeforeAccess(Microsoft.Identity.Client.TokenCacheCallback)">
            <summary>
            Sets a delegate to be notified before any library method accesses the cache. This gives an option to the
            delegate to deserialize a cache entry for the application and accounts specified in the <see cref="T:Microsoft.Identity.Client.TokenCacheNotificationArgs"/>.
            See https://aka.ms/msal-net-token-cache-serialization
            </summary>
            <param name="beforeAccess">Delegate set in order to handle the cache deserialization</param>
            <remarks>In the case where the delegate is used to deserialize the cache, it might
            want to call <see cref="M:Microsoft.Identity.Client.TokenCache.Deserialize(System.Byte[])"/></remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SetAfterAccess(Microsoft.Identity.Client.TokenCacheCallback)">
            <summary>
            Sets a delegate to be notified after any library method accesses the cache. This gives an option to the
            delegate to serialize a cache entry for the application and accounts specified in the <see cref="T:Microsoft.Identity.Client.TokenCacheNotificationArgs"/>.
            See https://aka.ms/msal-net-token-cache-serialization
            </summary>
            <param name="afterAccess">Delegate set in order to handle the cache serialization in the case where the <see cref="P:Microsoft.Identity.Client.TokenCache.HasStateChanged"/>
            member of the cache is <c>true</c></param>
            <remarks>In the case where the delegate is used to serialize the cache entirely (not just a row), it might
            want to call <see cref="M:Microsoft.Identity.Client.TokenCache.Serialize"/></remarks>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SetBeforeWrite(Microsoft.Identity.Client.TokenCacheCallback)">
            <summary>
            Sets a delegate called before any library method writes to the cache. This gives an option to the delegate
            to reload the cache state from a row in database and lock that row. That database row can then be unlocked in the delegate
            registered with <see cref="M:Microsoft.Identity.Client.TokenCache.SetAfterAccess(Microsoft.Identity.Client.TokenCacheCallback)"/>
            </summary>
            <param name="beforeWrite">Delegate set in order to prepare the cache serialization</param>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SetBeforeAccessAsync(System.Func{Microsoft.Identity.Client.TokenCacheNotificationArgs,System.Threading.Tasks.Task})">
            <summary>
            
            </summary>
            <param name="beforeAccess"></param>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SetAfterAccessAsync(System.Func{Microsoft.Identity.Client.TokenCacheNotificationArgs,System.Threading.Tasks.Task})">
            <summary>
            
            </summary>
            <param name="afterAccess"></param>
        </member>
        <member name="M:Microsoft.Identity.Client.TokenCache.SetBeforeWriteAsync(System.Func{Microsoft.Identity.Client.TokenCacheNotificationArgs,System.Threading.Tasks.Task})">
            <summary>
            
            </summary>
            <param name="beforeWrite"></param>
        </member>
        <member name="T:Microsoft.Identity.Client.MsalClaimsChallengeException">
            <summary>
            This exception indicates that claims have been returned from the endpoint that need to be resolved. This can be achieved by using them in the next authentication request.
            See <see href="https://aka.ms/msal-conditional-access-claims">Conditional Access and claims challenges</see>.
            See <see href="https://aka.ms/msal-conditional-access-claims-obo">Handling multifactor auth (MFA), Conditional Access, and incremental consent</see>.
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.MsalClaimsChallengeException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the exception class with a specified
            error code and error message.
            </summary>
            <param name="errorCode">
            The error code returned by the service or generated by the client. This is the code you can rely on
            for exception handling.
            </param>
            <param name="errorMessage">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Microsoft.Identity.Client.MsalClaimsChallengeException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the exception class with a specified
            error code, error message and inner exception indicating the root cause.
            </summary>
            <param name="errorCode">
            The error code returned by the service or generated by the client. This is the code you can rely on
            for exception handling.
            </param>
            <param name="errorMessage">The error message that explains the reason for the exception.</param>
            <param name="innerException">Represents the root cause of the exception.</param>
        </member>
        <member name="M:Microsoft.Identity.Client.MsalClaimsChallengeException.#ctor(System.String,System.String,System.Exception,Microsoft.Identity.Client.UiRequiredExceptionClassification)">
            <summary>
            Initializes a new instance of the exception class with a specified
            error code, error message and inner exception indicating the root cause.
            </summary>
            <param name="errorCode">
            The error code returned by the service or generated by the client. This is the code you can rely on
            for exception handling.
            </param>
            <param name="errorMessage">The error message that explains the reason for the exception.</param>
            <param name="innerException">Represents the root cause of the exception.</param>
            <param name="classification">A higher level description for this exception, that allows handling code to 
            understand what type of action it needs to take to resolve the issue. </param>
        </member>
        <member name="T:Microsoft.Identity.Client.MsalClientException">
            <summary>
            This exception class represents errors that are local to the library or the device. Contrary to
            <see cref="T:Microsoft.Identity.Client.MsalServiceException"/> which represent errors happening from the Azure AD service or
            the network. For more details, see https://aka.ms/msal-net-exceptions
            </summary>
        </member>
        <member name="M:Microsoft.Identity.Client.MsalClientException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the exception class with a specified
            error code.
            </summary>
            <param name="errorCode">
            The error code returned by the service or generated by client. This is the code you can rely on
            for exception handling.</param>
        </member>
        <member name="M:Microsoft.Identity.Client.MsalClientException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the exception class with a specified
            error code and error message.
            </summary>
            <param name="errorCode">
            The error code returned by the service or generated by client. This is the code you can rely on
            for exception handling.
            </param>
            <param name="errorMessage">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:Microsoft.Identity.Client.MsalClientException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the exception class with a specified
            error code, error message and inner exception.
            </summary>
            <param name="errorCode">
            The error code returned by the service or generated by client. This is the code you can rely on
            for exception handling.
            </param>
            <param name="errorMessage">The error message that explains the reason for the exception.</param>
            <param name="innerException"></param>
        </member>
        <member name="T:Microsoft.Identity.Client.MsalError">
            <summary>
            Error code returned as a property in MsalException
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.InvalidGrantError">
            <summary>
            Standard OAuth2 protocol error code. It indicates that the application needs to expose the UI to the user
            so that the user does an interactive action in order to get a new token.
            <para>Mitigation:</para> If your application is a <see cref="T:Microsoft.Identity.Client.IPublicClientApplication"/> call <c>AcquireTokenInteractive</c>
            perform an interactive authentication. If your application is a <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication"/> chances are that the Claims member
            of the exception is not empty. See <see cref="P:MsalServiceException.Claims"/> for the right mitigation
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.InteractionRequired">
            <summary>
            Standard OAuth2 protocol error code. It indicates that the application needs to expose the UI to the user
            so the user can do an interactive log-in to get a token with updated claims.
            <para>Mitigation:</para> If your application is a <see cref="T:Microsoft.Identity.Client.IPublicClientApplication"/> call <c>AcquireTokenInteractive</c>
            perform an interactive authentication. If your application is a <see cref="T:Microsoft.Identity.Client.ConfidentialClientApplication"/> chances are that the Claims member
            of the exception is not empty. See <see cref="P:Microsoft.Identity.Client.MsalServiceException.Claims"/> for the right mitigation
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.NoTokensFoundError">
            <summary>
            No token was found in the token cache.
            <para>Mitigation:</para> If your application is a <see cref="T:Microsoft.Identity.Client.IPublicClientApplication"/> call <c>AcquireTokenInteractive</c> so
            that the user of your application signs-in and accepts consent.
            <list type="bullet">
            <item><description>
            If it's a web app you should have previously called IConfidentialClientApplication.AcquireTokenByAuthorizationCode
            as described in https://aka.ms/msal-net-authorization-code. You need to make sure that you have requested the right scopes. For details
            See https://github.com/Azure-Samples/ms-identity-aspnetcore-webapp-tutorial
            </description></item>
            <item><description>This error should not happen in web APIs</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UserNullError">
            <summary>
            This error code comes back from <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/> calls when a null user is
            passed as the <c>account</c> parameter. This can be because you have called AcquireTokenSilent with an <c>account</c> parameter
            set to <c>accounts.FirstOrDefault()</c> but <c>accounts</c> is empty.
            <para>Mitigation</para>
            Pass a different account, or otherwise call <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})"/>
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UserAssertionNullError">
            <summary>
            This error code comes back from <see cref="M:Microsoft.Identity.Client.IConfidentialClientApplication.AcquireTokenOnBehalfOf(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.UserAssertion)"/> 
            calls when a null user assertion is passed as the <c>UserAssertion</c> parameter. 
            <para>Mitigation</para>
            Pass a valid value for user assertion
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.CurrentBrokerAccount">
            <summary>
            This error code comes back from <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/> calls when the 
            <see cref="P:Microsoft.Identity.Client.PublicClientApplication.OperatingSystemAccount"/> user is passed as the <c>account</c> parameter. Only some brokers (WAM) can login the current user.
            <para>Mitigation</para>
            On Windows, use the broker via .WithBroker(true), use a different account, or otherwise call <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})"/>
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.NoAccountForLoginHint">
            <summary>
            This error code denotes that no account was found having the given login hint.
            <para>What happens?</para>
            <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},System.String)"/>
            or <see cref="M:Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder.WithLoginHint(System.String)"/>
            was called with a <c>loginHint</c> parameter which does not match any account in <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.GetAccountsAsync"/>
            <para>Mitigation</para>
            If you are certain about the loginHint, call <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})"/>
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.MultipleAccountsForLoginHint">
            <summary>
            This error code denotes that multiple accounts were found having the same login hint and MSAL
            cannot choose one. Please use <see cref="M:Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder.WithAccount(Microsoft.Identity.Client.IAccount)"/> to specify the account
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.TokenCacheNullError">
            <summary>
            This error code comes back from <see cref="M:Microsoft.Identity.Client.ClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/> calls when
            the user cache had not been set in the application constructor. This should never happen in MSAL.NET 3.x as the cache is created by the application
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.NoPromptFailedError">
            <summary>
            One of two conditions was encountered:
            <list type="bullet">
            <item><description>The <c>Prompt.NoPrompt</c> was passed in an interactive token call, but the constraint could not be honored because user interaction is required,
            for instance because the user needs to re-sign-in, give consent for more scopes, or perform multiple factor authentication.
            </description></item>
            <item><description>
            An error occurred during a silent web authentication that prevented the authentication flow from completing in a short enough time frame.
            </description></item>
            </list>
            <para>Remediation:</para>call <c>AcquireTokenInteractive</c> so that the user of your application signs-in and accepts consent.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.ServiceNotAvailable">
            <summary>
            Service is unavailable and returned HTTP error code within the range of 500-599
            <para>Mitigation</para> you can retry after a delay.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.RequestTimeout">
            <summary>
            The HTTP Request to the STS timed out.
            <para>Mitigation</para> you can retry after a delay.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.RequestThrottled">
            <summary>
            Service returned HTTP error code 429 which indicates the request has been throttled.
            For more details see https://aka.ms/msal-net-throttling
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UpnRequired">
            <summary>
            loginHint should be a UPN
            <para>What happens?</para> An override of a token acquisition operation was called in <see cref="T:Microsoft.Identity.Client.IPublicClientApplication"/> which
            takes a <c>loginHint</c> as a parameters, but this login hint was not using the UserPrincipalName (UPN) format, e.g. <c>john.doe@contoso.com</c>
            expected by the service
            <para>Remediation</para> Make sure in your code that you enforce <c>loginHint</c> to be a UPN
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.MissingPassiveAuthEndpoint">
            <summary>
            No passive auth endpoint was found in the OIDC configuration of the authority
            <para>What happens?</para> When the libraries go to the authority and get its open id connect configuration
            it expects to find a Passive Auth Endpoint entry, and could not find it.
            <para>remediation</para> Check that the authority configured for the application, or passed on some overrides of token acquisition tokens
            supporting authority override is correct
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.InvalidAuthority">
            <summary>
            Invalid authority
            <para>What happens</para> When the library attempts to discover the authority and get the endpoints it needs to
            acquire a token, it got an un-authorize HTTP code or an unexpected response
            <para>remediation</para> Check that the authority configured for the application, or passed on some overrides of token acquisition tokens
            supporting authority override is correct
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.InvalidAuthorityType">
            <summary>
            Invalid authority type.
            MSAL.NET does not know how to interact with the authority specified when the application was built.
            <para>Mitigation</para>
            Use a different authority
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UnauthorizedClient">
            <summary>
            The client is unauthorized to access resource.
            This commonly happens when Mobile App Management (MAM) policies are enabled. MSAL will throw an exception in that case with <c>protection_policy_required</c> sub-error.
            <para>Mitigation</para>
            Catch the exception and use the properties in it to obtain the right parameters from Intune SDK.
            <see href="https://aka.ms/msal-net-trueMAM">IntuneAppProtectionPolicyRequiredException</see>
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UnknownError">
            <summary>
            Unknown Error occurred.
            <para>Mitigation</para> None. You might want to inform the end user.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UnknownBrokerError">
            <summary>
            Unknown broker error occurred.
            <para>Mitigation</para> None. You might want to inform the end user.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.WamFailedToSignout">
            <summary>
            WAM Signout failed.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.AuthenticationFailed">
            <summary>
            Authentication failed.
            <para>What happens?</para>
            The authentication failed. For instance the user did not enter the right password
            <para>Mitigation</para>
            Inform the user to retry.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.AuthorityValidationFailed">
            <summary>
            Authority validation failed.
            <para>What happens?</para>
            The validation of the authority failed. This might be because the authority is not
            compliant with the OIDC standard, or there might be a security issue
            <para>Mitigation</para>
            Use a different authority. If you are absolutely sure that you can trust the authority
            you can use the <see cref="M:Microsoft.Identity.Client.AbstractApplicationBuilder`1.WithAuthority(Microsoft.Identity.Client.AadAuthorityAudience,System.Boolean)"/> passing
            the <c>validateAuthority</c> parameter to <c>false</c> (not recommended)
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.InvalidOwnerWindowType">
            <summary>
            Invalid owner window type.
            <para>What happens?</para>
            You used <c>"AcquireTokenInteractiveParameterBuilder.WithParentActivityOrWindow(object)</c>
            but the parameter you passed is invalid.
            <para>Remediation</para>
            On .NET Standard, the expected object is an <c>Activity</c> on Android, a <c>UIViewController</c> on iOS,
            a <c>NSWindow</c> on MAC, and a <c>IWin32Window</c> or <c>IntPr</c> on Windows.
            If you are in a WPF application, you can use <c>WindowInteropHelper(wpfControl).Handle</c> to get the window
            handle associated with a WPF control
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.EncodedTokenTooLong">
            <summary>
            Encoded token too long.
            <para>What happens</para>
            In a confidential client application call, the client assertion built by MSAL is longer than
            the max possible length for a JWT token.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UserMismatch">
            <summary>
            User Mismatch.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.FailedToRefreshToken">
            <summary>
            Failed to refresh token.
            <para>What happens?</para>
            The token could not be refreshed. This can be because the user has not used the application for a long time.
            and therefore the refresh token maintained in the token cache has expired
            <para>Mitigation</para>
            If you are in a public client application, that supports interactivity, send an interactive request
            <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})"/>. Otherwise,
            use a different method to acquire tokens.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.FailedToAcquireTokenSilentlyFromBroker">
            <summary>
            Failed to acquire token silently. Used in broker scenarios.
            <para>What happens</para>
            you called <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},Microsoft.Identity.Client.IAccount)"/>
            or <see cref="M:Microsoft.Identity.Client.IClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerable{System.String},System.String)"/> and your
            mobile (Xamarin) application leverages the broker (Microsoft Authenticator or Microsoft Company Portal), but the broker
            was not able to acquire the token silently.
            <para>Mitigation</para>
            Call <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenInteractive(System.Collections.Generic.IEnumerable{System.String})"/>
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.RedirectUriValidationFailed">
            <summary>
            RedirectUri validation failed.
            <para>What happens?</para>
            The redirect URI / reply URI is invalid
            <para>How to fix</para>
            Pass a valid redirect URI.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.AuthenticationUiFailed">
            <summary>
            The request could not be preformed because of an unknown failure in the UI flow.*
            <para>Mitigation</para>
            Inform the user.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.InternalError">
            <summary>
            Internal error
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.AccessingWsMetadataExchangeFailed">
            <summary>
            Accessing WS Metadata Exchange Failed.
            <para>What happens?</para>
            You tried to use <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)"/>
            and the account is a federated account.
            <para>Mitigation</para>
            None. The WS metadata was not found or does not correspond to what was expected.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.FederatedServiceReturnedError">
            <summary>
            Federated service returned error.
            <para>Mitigation</para>
            None. The federated service returned an error. You can try to look at the
            Body of the exception for a better understanding of the error and choose
            the mitigation
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UserRealmDiscoveryFailed">
            <summary>
            User Realm Discovery Failed.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.RopcDoesNotSupportMsaAccounts">
            <summary>
            Resource Owner Password Credential (ROPC) grant attempted with an MSA (Microsoft personal) account.
            ROPC does not support MSA accounts.
            See https://aka.ms/msal-net-ropc for details.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.MissingFederationMetadataUrl">
            <summary>
            Federation Metadata URL is missing for federated user.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.ParsingWsMetadataExchangeFailed">
            <summary>
            Parsing WS Metadata Exchange Failed.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.WsTrustEndpointNotFoundInMetadataDocument">
            <summary>
            WS-Trust Endpoint Not Found in Metadata Document.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.ParsingWsTrustResponseFailed">
            <summary>
            You can get this error when using <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)"/>
            In the case of a Federated user (that is owned by a federated IdP, as opposed to a managed user owned in an Azure AD tenant)
            ID3242: The security token could not be authenticated or authorized.
            The user does not exist or has entered the wrong password
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.IntegratedWindowsAuthenticationFailed">
            <summary>
            This can occur if there is an configuration issue in the ADFS environment where this is authenticating. See https://aka.ms/msal-net-iwa-troubleshooting for more details
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UnknownUserType">
            <summary>
            <para>What happens</para>
            You can get this error when using <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)"/>
            The user is not recognized as a managed user, or a federated user. Azure AD was not
            able to identify the IdP that needs to process the user
            <para>Mitigation</para>
            Inform the user. the login that the user provided might be incorrect.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UnknownUser">
            <summary>
            <para>What happens</para>
            You can get this error when using <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)"/>
            The user is not known by the IdP
            <para>Mitigation</para>
            Inform the user. The login that the user provided might be incorrect (for instance empty)
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.GetUserNameFailed">
            <summary>
            Failed to get user name.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.PasswordRequiredForManagedUserError">
            <summary>
            Password is required for managed user.
            <para>What happens?</para>
            If can got this error when using <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)"/>
            and you (or the user) did not provide a password.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.InvalidRequest">
            <summary>
            Request is invalid.
            <para>What happens?</para>
            This can happen because you are using a token acquisition method which is not compatible with the authority. For instance:
            you called <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)"/>
            but you used an authority ending with '/common' or '/consumers' as this requires a tenanted authority or '/organizations'.
            <para>Mitigation</para>
            Adjust the authority to the AcquireTokenXX method you use (don't use 'common' or 'consumers' with <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByUsernamePassword(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)"/>
            <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})"/>
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UapCannotFindDomainUser">
             <summary>
             Cannot access the user from the OS (UWP)
             <para>What happens</para>
             You called <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})"/>, but the domain user
             name could not be found.
            <para>Mitigation</para>
             This might be because you need to add more capabilities to your UWP application in the Package.appxmanifest.
             See https://aka.ms/msal-net-uwp
             </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.UapCannotFindUpn">
             <summary>
             Cannot get the user from the OS (UWP)
             <para>What happens</para>
             You called <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})"/>, but the domain user
             name could not be found.
            <para>Mitigation</para>
             This might be because you need to add more capabilities to your UWP application in the Package.appxmanifest.
             See https://aka.ms/msal-net-uwp
             </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.NonParsableOAuthError">
            <summary>
            An error response was returned by the OAuth2 server and it could not be parsed
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.CodeExpired">
            <summary>
            <para>What happens?</para>
            In the context of Device code flow (See https://aka.ms/msal-net-device-code-flow),
            this error happens when the device code expired before the user signed-in on another device (this is usually after 15 mins).
            <para>Mitigation</para>
            None. Inform the user that they took too long to sign-in at the provided URL and enter the provided code.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.IntegratedWindowsAuthNotSupportedForManagedUser">
            <summary>
            Integrated Windows Auth is only supported for "federated" users
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.ActivityRequired">
            <summary>
            On Android, you need to call <c>AcquireTokenInteractiveParameterBuilder.WithParentActivityOrWindow(object)</c> passing
            the activity. See https://aka.ms/msal-interactive-android
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.BrokerResponseHashMismatch">
            <summary>
            Broker response hash did not match
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.BrokerResponseReturnedError">
            <summary>
            Broker response returned an error
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.BrokerNonceMismatch">
            <summary>
            Broker response nonce does not match the request nonce sent by MSAL.NET for iOS broker >= v6.3.19
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.CannotInvokeBroker">
            <summary>
            MSAL is not able to invoke the broker. Possible reasons are the broker is not installed on the user's device,
            or there were issues with the UiParent or CallerViewController being null. See https://aka.ms/msal-brokers
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.NoAndroidBrokerAccountFound">
            <summary>
            MSAL is not able to find a suitable account to use with broker
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.NoAndroidBrokerInstalledOnDevice">
            <summary>
            MSAL cannot find the broker application to authenticate accounts.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.NullIntentReturnedFromAndroidBroker">
            <summary>
            Null intent was returned so broker activity cannot be launched
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.AndroidBrokerSignatureVerificationFailed">
            <summary>
            Failed to validate android broker signature
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.AndroidBrokerOperationFailed">
            <summary>
            Failed To Complete Android Broker Operation
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.NoUsernameOrAccountIDProvidedForSilentAndroidBrokerAuthentication">
            <summary>
            Unable to query the Android account manager because no username or home account ID is provided in the silent authentication request.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.HttpStatusNotFound">
            <summary>
            Error code used when the HTTP response returns HttpStatusCode.NotFound
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.HttpStatusCodeNotOk">
            <summary>
            ErrorCode used when the HTTP response returns something different from 200 (OK)
            </summary>
            <remarks>
            HttpStatusCode.NotFound have a specific error code. <see cref="F:Microsoft.Identity.Client.MsalError.HttpStatusNotFound"/>
            </remarks>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.CustomWebUiReturnedInvalidUri">
            <summary>
            Error code used when the <see cref="T:Microsoft.Identity.Client.Extensibility.ICustomWebUi"/> has returned a URI, but it is invalid - it is either null or has no code.
            Consider throwing an exception if you are unable to intercept the URI containing the code.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.CustomWebUiRedirectUriMismatch">
            <summary>
            Error code used when the CustomWebUI has returned a URI, but it does not match the Authority and AbsolutePath of
            the configured redirect URI.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.AccessDenied">
            <summary>
            Access denied.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.CannotAccessUserInformationOrUserNotDomainJoined">
            <summary>
            Cannot Access User Information or the user is not a user domain.
            <para>What happens?</para>
            You tried to use <see cref="M:Microsoft.Identity.Client.IPublicClientApplication.AcquireTokenByIntegratedWindowsAuth(System.Collections.Generic.IEnumerable{System.String})"/>
            but the user is not a domain user (the machine is not domain or AAD joined)
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.DefaultRedirectUriIsInvalid">
            <summary>
            RedirectUri validation failed.
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.NoRedirectUri">
            <summary>
            No Redirect URI.
            <para>What happens?</para>
            You need to provide a Reply URI / Redirect URI, but have not called <see cref="M:Microsoft.Identity.Client.AbstractApplicationBuilder`1.WithRedirectUri(System.String)"/>
            </summary>
        </member>
        <member name="F:Microsoft.Identity.Client.MsalError.MultipleTokensMatchedError">
            <summary>
            Multiple Tokens were matched.
            <para>What happens?</para>This exception happens in the case of applications managing several identities,
            when calling <see cref="M:Microsoft.Identity.Client.ClientApplicationBase.AcquireTokenSilent(System.Collections.Generic.IEnumerab