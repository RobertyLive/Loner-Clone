须出现在所有固定参数都已指定完毕后。请使用语言版本 {0} 或更高版本，以允许非尾随命名参数。W命名参数规范必须出现在已在动态调用中指定所有固定参数之后。<命名参数“{0}”指定的形参已被赋予位置参数=Extension members are not allowed as an argument to 'nameof'.4扩展方法组不允许作为 "nameof" 的参数。F类型参数不允许在方法组中作为 "nameof" 的参数使用。*无法在脚本代码中声明命名空间E命名空间不能直接包含字段、方法或语句之类的成员$无法创建大小为负值的数组'无法对 stackalloc 采用负值大小H存储在“{1}”中的模块名“{0}”必须与其文件名匹配。Z模块“{0}”已在此程序集中定义。每个模块必须具有唯一的文件名。9new() 约束必须是指定的最后一个限制性约束6"new()" 约束不能与 "unmanaged" 约束一起使用3"new()" 约束不能与 "struct" 约束一起使用B无法嵌入互操作类型“{0}”。请改用适用的接口。u'{2}' 无法满足泛型类型或方法 '{1}'中参数 '{0}'的 'new()' 约束，因为 '{2}'具有必需的成员。“{2}”必须是具有公共的无参数构造函数的非抽象类型，才能用作泛型类型或方法“{0}”中的参数“{1}”;“{0}”: 创建变量类型的实例时无法提供参数6“{0}”是密封类型“{1}”中新的虚拟成员N"new" 不能与元组类型共同使用。请改用元组字面量表达式。常量中有换行符eC# {0}不支持非逐字内插字符串内的换行符。请使用语言版本 {1} 或更高版本。0“using static”指令不能用于声明别名"base" 引用需要基类'没有要中断或继续的封闭循环d找不到与嵌入互操作类型“{0}”相匹配的互操作类型。是否缺少程序集引用?$类型“{0}”未定义构造函数~'{0}': 异步 using 语句中使用的类型必须实现 'System.IAsyncDisposable' 或实现适用的 'DisposeAsync' 方法。'{0}': 异步 using 语句中使用的类型必须实现 'System.IAsyncDisposable' 或实现适用的 'DisposeAsync' 方法。是否希望使用 'using' 而非 'await using'?I'{0}': using 语句中使用的类型必须实现 'System.IDisposable'。y'{0}': using 语句中使用的类型必须实现 'System.IDisposable'。是否希望使用 'await using' 而非 'using'?i无法应用 CallerFilePathAttribute，因为不存在从类型“{0}”到类型“{1}”的标准转换i无法应用 CallerFilePathAttribute，因为不存在从类型“{0}”到类型“{1}”的标准转换k无法应用 CallerLineNumberAttribute，因为不存在从类型“{0}”到类型“{1}”的标准转换k无法应用 CallerMemberNameAttribute，因为不存在从类型“{0}”到类型“{1}”的标准转换`不能将“{0}”类型的值用作默认参数，因为没有到类型“{1}”的标准转换{无法将类型为“{0}”的值用作可以为 null 的参数“{1}”的默认参数，因为“{0}”不是简单类型B在基类型“{0}”中找不到可访问的复制构造函数。<未提供与“{1}”的所需参数“{0}”对应的参数T关键字 \"delegate\" 不能用作约束。你的意思是 \"System.Delegate\" 吗?需要动态调度对方法“{0}”的调用，但无法实现，因为该调用是基访问表达式的一部分。请考虑强制转换动态参数或消除基访问。构造函数调用需要进行动态调度，但无法如此，因为它是构造函数初始值的一部分。请考虑强制转换动态参数。索引器访问需要进行动态调度，但未能如此，因为它是基访问表达式的一般分。请考虑强制转换动态参数或消除基访问。8程序不包含适合于入口点的静态 "Main" 方法T关键字 \"enum\" 不能用作约束。你的意思是 \"struct, System.Enum\" 吗?无法通过引用转换、装箱转换、取消装箱转换、包装转换或 null 类型转换将类型“{0}”转换为“{1}”*无法将类型“{0}”转换为“{1}”!“{0}”选项缺少文件规范I“{0}”: 无法重写，因为“{1}”没有可重写的 get 访问器0无法将类型“{0}”隐式转换为“{1}”f无法将类型“{0}”隐式转换为“{1}”。存在一个显式转换(是否缺少强制转换?)语言版本 {0} 中的条件表达式无效，因为在“{1}”和“{2}”之间未找到通用类型。如需使用目标类型转换，请升级到语言版本 {3} 或更高版本。,“{0}”没有合适的静态 'Main' 方法0如果生成模块或库，则无法指定 /main$未能找到元数据文件“{0}”0修饰符不能放置在事件访问器声明上(修饰符不能放置在 using 声明上:类“{0}”不能具有多个基类:“{1}”和“{2}”r命名空间中定义的元素无法显式声明为 private、protected、protected internal 或 private protected<无法在使用 /refout 或 /refonly 时编译 Net 模块。3无法创建抽象类型或接口“{0}”的实例O变量类型“{0}”没有 new() 约束，因此无法创建该类型的实例无法确定输出目录Z无法嵌入来自程序集“{0}”的互操作类型，因为它缺少“{1}”特性。l无法嵌入来自程序集“{0}”的互操作类型，因为它缺少“{1}”特性或“{2}”特性。x无法嵌入类型“{0}”，因为它是嵌套类型。请考虑将“嵌入互操作类型”属性设置为 false。+不要在使用 refonly 时使用 refout。I“{0}”: 无法重写，因为“{1}”没有可重写的 set 访问器$无法打开源文件“{0}”-- {1}$“{0}”未包含“{1}”的定义“{0}”未包含“{1}”的定义，并且找不到可接受第一个“{0}”类型参数的可访问扩展方法“{1}”(是否缺少 using 指令或程序集引用?)“{0}”不包含“{1}”的定义，并且找不到可接受类型为“{0}”的第一个参数的扩展方法“{1}”(是否缺少针对“{2}”的 using 指令?)`类型“{0}”在未引用的程序集中定义。必须添加对程序集“{1}”的引用。N类型“{0}”在未添加的模块中定义。必须添加模块“{1}”。/关键字 "void" 不能在此上下文中使用参数类型 "void" 无效-接口列表中的类型“{0}”不是接口<不可调用的成员“{0}”不能像方法一样使用。-记录成员“{0}”必须是非公开的。$必须保护记录成员“{0}”。*记录成员“{0}”必须是公共的。0参数结构构造函数必须是“public”。2返回入口点的 void 或 int 不能是异步的“{0}”不是特性类-指派给“{0}”的表达式必须是常量d内插必须以与原始字符串字面量开始的 \"$\" 字符数相同的右大括号数结束。*原始字符串字面量的引号不足。T“{0}”不是实例方法，接收器不能是内插字符串处理程序参数。q“{0}”的类型为“{1}”。只能用 Null 对引用类型(字符串除外)的常量字段进行初始化。q“{0}”的类型为“{1}”。只能用 Null 对引用类型(字符串除外)的默认参数值进行初始化?“{0}”必须允许替代，因为包含的记录未密封。类型 "{2}" 不能是 ref 结构或允许 ref 结构的类型参数，以便在泛型类型或方法 "{0}" 中将其用作参数 "{1}")尚未实现此语言功能(“{0}”)。null 不是有效的参数名称。若要获取对实例方法接收器的访问权限，请使用空字符串作为参数名。$在此上下文中使用 null 无效5表达式树 Lambda 不能包含空传播运算符。)应为 "enable"、"disable" 或 "restore"0应为“警告”、“注释”或指令结束U无效的 {0} 值: C# {2} 的“{1}”。请使用语言版本 {3} 或更高版本。可以为 null 的类型参数必须已知为值类型或不可以为 null 的引用类型，除非使用了语言版本“{0}”或更高版本。请考虑更改语言版本或添加 "class"、"struct" 或类型约束。3“{0}”没有基类，无法调用基构造函数6类 System.Object 不能有基类也不能实现接口N对象和集合初始值设定项表达式不能应用于委托创建表达式Q无法使用实例引用来访问成员“{0}”；请改用类型名来限定它K对象引用对于非静态的字段、方法或属性“{0}”是必需的-当前上下文中不允许省略类型参数一个声明外部别名的 /reference 选项只能有一个文件名。要指定多个别名或文件名，请使用多个 /reference 选项。'只有类类型才能包含析构函数6运算符 True 或 False 的返回类型必须是 bool 发现文件尾，应输入 "*/"$打开响应文件“{0}”时出错7用户定义的运算符 '{0}' 无法声明为已验证)用户定义的运算符不能返回 voidQAn extension block extending a static class cannot contain user-defined operators8“{0}”: 静态类不能包含用户定义的运算符U'{0}': cannot override inherited member '{1}' because one of them is not an operator..The return type for this operator must be void?运算符“{0}”要求也要定义匹配的运算符“{1}”3User-defined operator '{0}' must be declared public>User-defined operator '{0}' must be declared static and public'选项“{0}”必须是绝对路径。#in 参数不能具有 Out 特性。J不可在 ref 参数上指定 Out 特性，除非同时指定 In 特性。-ref readonly 参数不能具有 Out 属性。*out 变量无法声明为 ref 局部变量-必须为没有源的输出指定 /out 选项,未能写入输出文件“{0}”--“{1}”[“{0}”不能定义仅在参数修饰符“{2}”和“{3}”上存在区别的重载 {1}方法“{0}”为类型参数“{1}”指定了 "default" 约束，但被替代的或显式实现的方法“{3}”的对应类型参数“{2}” 仅限于引用类型或值类型。C请不要重写 object.Finalize，而是提供一个析构函数。;必须需要'{0}'，因为它会覆盖必需的成员 '{1}'/“{0}”: 没有找到适合的方法来重写D标记为 override 的成员“{0}”不能标记为 new 或 virtual方法 "{0}" 为类型参数 "{1}" 指定了 "class" 约束，但重写的或显式实现的方法 "{3}" 的对应类型参数 "{2}" 不是引用类型。方法 "{0}" 为类型参数 "{1}" 指定了 "struct" 约束，但重写的或显式实现的方法 "{3}" 的相应类型参数 "{2}" 不是不可为 null 的值类型。重写和显式接口实现方法的约束是从基方法继承的，因此不能直接指定这些约束，除非指定 "class" 或 "struct" 约束。$应输入可重载的二元运算符应输入可重载运算符$应输入可重载的一元运算符N不能在文件的第一个标记之后定义或取消定义预处理器符号应输入预处理器指令/'#:' directives cannot be after '#if' directive3'#:' directives cannot be after first token in fileV'#:' directives can be only used in file-based programs ('-features:FileBasedProgram')3文件中的第一个令牌后面不得使用 #load0不能在文件的第一个标记之后使用 #rB'#!' directives can be only used in scripts or file-based programs'参数具有多个不同的默认值。A控制离开当前方法之前必须对 out 参数“{0}”赋值)“{0}”: 静态类型不能用作参数*参数对于指定非托管类型无效。 params 参数不能声明为 {0}<构造函数“{0}”的必需成员“{1}”未初始化。G表达式树不能包含非数组 params 集合参数的展开形式。9“{0}”不包含适合的实例“Add”方法的定义M创建 params 集合“{0}”导致构造函数“{1}”调用的无限链。t非数组 params 集合类型必须拥有适用的构造函数，且该函数可以在无参数的情况下调用。:params 参数必须是参数列表中的最后一个参数P方法“{0}”的可见性不能小于具有 params 集合“{1}”的成员。.Params 参数必须具有有效的集合类型Y'{0}': only the implementing declaration of a partial constructor can have an initializer,'{0}': partial event cannot have initializerH这两个分部成员声明必须具有相同的可访问性修饰符。-分部成员不能具有 "abstract" 修饰符APartial member '{0}' may not have multiple defining declarations.EPartial member '{0}' may not have multiple implementing declarations.o这两个分部成员声明必须具有 "virtual"、"override"、"sealed" 和 "new" 修饰符的相同组合。_这两个分部成员声明(“{0}”和“{1}”)都必须使用相同的元组元素名称。1Partial member '{0}' must have a definition part.6Partial member '{0}' must have an implementation part.*分部成员不能显式实现接口成员*分部成员必须在分部类型内声明J这两个分部成员声明必须都使用或者都不使用 params 参数B这两个分部成员声明必须都是或者都不是只读声明9分部成员声明必须具有匹配的引用返回值。B这两个分部成员声明必须都是或者都不是静态声明9Both partial member declarations must have the same type.E这两个分部成员声明必须都是或者都不是不安全声明Q两个分部方法声明都必须是扩展方法，或者都不能是扩展方法Z不能在表达式树中使用只有定义声明的分部方法或已移除的条件方法H“{0}”的分部方法声明对类型参数“{1}”的约束不一致?没有为分部方法“{0}”的实现声明找到定义声明'分部方法不能有多个实现声明'分部方法不能有多个定义声明<两个分部方法声明必须具有相同的返回类型。]无法通过方法“{0}”创建委托，因为该方法是没有实现声明的分部方法W分部方法“{0}”必须具有实现部分，因为它具有可访问性修饰符。分部方法“{0}”必须具有可访问性修饰符，因为它具有 "virtual"、"override"、"sealed"、"new" 或 "extern" 修饰符。`分部方法“{0}”必须具有可访问性修饰符，因为它具有非 void 返回类型。X分部方法“{0}”必须具有可访问性修饰符，因为它具有 "out" 参数。y"partial" 修饰符的后面只能紧跟 "class"、"record"、"struct"、"interface" 或者方法或属性返回类型。<“{0}”的分部声明包含冲突的可访问性修饰符9“{0}”的分部声明一定不能指定不同的基类H分部属性不能有多个定义声明，并且不能是自动属性。'分部属性不能有多个实现声明K一个部分属性不能同时具有定义和实现的初始值设定项。B属性访问器“{0}”必须为“{1}”才能匹配定义部分N必须实现属性访问器“{0}”，因为它是在定义部分上声明的0分部属性“{0}”必须具有定义部分。0分布属性“{0}”必须具有实现部分。B这两个分部属性声明必须都是或者都不是必需声明K属性访问器“{0}”未实现在定义部分上声明的任何访问器i'{0}' 的部分声明必须为所有类、所有记录、所有结构、所有记录结构或所有接口H“{0}”的分部声明对类型参数“{1}”具有不一致的约束H“{0}”的分部声明必须具有顺序相同的相同类型参数名l“{0}”的分部声明必须具有相同类型的参数名和变型修饰符，同时顺序也必须相同6在模式中使用类型“动态”是不合法的。d在模式中使用可以为 null 的类型“{0}?”是非法的；请改用基础类型“{0}”。T不支持将字符串 'null' 常量作为 '{0}' 的模式。请改用空字符串。在 C# {2} 中，“{1}”类型的模式无法处理“{0}”类型的表达式。请使用语言版本 {3} 或更高版本。B“{1}”类型的模式无法处理“{0}”类型的表达式。#写入输出文件时出错: {0}。a读取为 PermissionSet 特性的命名参数“{1}”指定的文件“{0}”时出错:“{2}”Z无法解析为 PermissionSet 特性的命名参数“{1}”指定的文件路径“{0}”)"is" 和 "as" 在指针类型上都无效*指针类型不允许进行模式匹配。<async-iterator 方法的主体必须包含 "yield" 语句。async-iterator 方法的主体必须包含 "yield" 语句。请考虑从方法声明中删除 "async" 或添加 "yield" 语句。<若要强制转换负值，必须将该值放在括号内。Y已在多个引用的程序集(“{1}”和“{2}”)中声明了预定义类型“{0}”H未在程序集“{2}”中找到类型“{1}”上的成员“{0}”。*预定义类型“{0}”未定义或导入0预定义类型“{0}”必须是一个结构。*预定义类型“{0}”未定义或导入BSecurityAction 值“{0}”对于 PrincipalPermission 特性无效2“{0}”: 抽象属性不能具有专用访问器5“{0}”: 属性或索引器不能具有 void 类型V属性或索引器“{0}”不能用在此上下文中，因为它缺少 get 访问器S属性子模式需要引用要匹配的属性或字段，例如，"{{ Name: {0} }}";“{0}”: 属性或索引器必须至少有一个访问器:'{0}': new protected member declared in an extension block,“{0}”: 静态类不能包含保护成员/“{0}”: 结构中已声明新的保护成员'* 或 -> 运算符只能应用于指针*指针必须只根据一个值进行索引C使用来自容器“{0}”的公钥对输出签名时出错 -- {1}C使用来自文件“{0}”的公钥对输出签名时出错 -- {1}<指定了公共签名并需要公钥，但未指定公钥。"netmodule 不支持公共签名。已声明范围变量“{0}”f名称“{0}”不在“equals”右侧的范围中。请考虑交换“equals”两侧的表达式。W找到源类型“{0}”的多个查询模式实现。对“{1}”的调用不明确。N未能找到源类型“{0}”的查询模式的实现。未找到“{1}”。未能找到源类型“{0}”的查询模式的实现。未找到“{1}”。请考虑显式指定范围变量“{2}”的类型。未能找到源类型“{0}”的查询模式的实现。未找到“{1}”。是否缺少必需的程序集引用或用于 "System.Linq" 的 using 指令?:无法作为 out 或 ref 参数传递范围变量“{0}”f名称“{0}”不在“equals”左侧的范围中。请考虑交换“equals”两侧的表达式。 无法将 {0} 赋给范围变量6范围变量“{0}”与“{0}”的以前声明冲突7无法对范围变量“{0}”赋值 -- 它是只读的?范围变量“{0}”的名称不能与方法类型参数相同a{0} 子句中的表达式的类型不正确。在对“{1}”的调用中，类型推理失败。j{0} 子句中其中一个表达式的类型不正确。在对“{1}”的调用中，类型推理失败。在源类型为“{1}”的查询表达式中，不允许在后面的 from 子句中使用类型“{0}”的表达式。在对“{2}”的调用中，类型推理失败。B原始字符串字面量分隔符必须位于其自己的行上。K只允许在逐字内插字符串中使用多行原始字符串字面量。?多行原始字符串字面量必须至少包含一行内容。?预处理器指令中不允许使用原始字符串字面量。应输入 }无法嵌入类型“{0}”，因为它有基本接口成员的重新抽象。请考虑将“嵌入互操作类型”属性设置为 false。w“{0}”: 仅当属性或索引器同时具有 get 访问器和 set 访问器时，才能对访问器使用 "readonly"x无法使用对象初始值设定项为类型为“{1}”的只读字段“{0}”的成员赋值，因为它是值类型;An extension container can have only one receiver parameter^'{0}': a receiver parameter cannot have the same name as an extension container type parameter6主构造函数与合成的复制构造函数冲突。在带有参数列表的“struct”中声明的构造函数必须具有调用主构造函数或显式声明的构造函数的“this”初始化表达式。'构造函数“{0}”不能调用自身Z无法推理“{0}”类型，因为其初始值设定项直接或间接地引用定义。f无法将“{1}”重新赋值为“{0}”，因为“{1}”具有比“{0}”更窄的转义范围。r无法将“{1}”ref 分配给“{0}”，因为“{1}”只能通过 return 语句对当前方法进行转义。无法将“{1}”ref-assign 给“{0}”，因为“{1}”比“{0}”具有更广的值转义范围，允许通过转义范围比“{1}”更窄的值的“{0}”进行赋值。?表达式必须为“{0}”类型，因为它通过引用赋值A'不能在包含 ref 条件运算符的表达式中使用 "await">表达式必须为与替代 ref 值相匹配的类型“{0}”I这两个条件运算符的值必须都是 ref 值或者都不是 ref 值c类型“{2}”必须是引用类型才能用作泛型类型或方法“{0}”中的参数“{1}”c"ref" 扩展方法“{0}”的第一个参数必须是值类型或受结构约束的泛型类型。pThe 'ref' receiver parameter of an extension block must be a value type or a generic type constrained to struct.$ref 字段不能引用 ref 结构。*ref 字段只能在 ref 结构中声明。@无法跨 "await" 或 "yield" 边界保留 "ref" 局部变量。*ref 赋值的左侧必须为 ref 变量。-ref 或 out