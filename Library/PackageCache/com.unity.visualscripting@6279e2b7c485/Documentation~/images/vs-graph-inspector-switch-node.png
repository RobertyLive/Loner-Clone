new 对象表达式可用作语句-此上下文中不允许使用抑制运算符?不安全代码只会在使用 /unsafe 编译的情况下出现"__arglist 在此上下文中无效T变型修饰符无效。只有接口和委托类型的参数可以指定为变量。方法“{1}”的类型参数“{0}”的约束必须与接口方法“{3}”的类型参数“{2}”的约束相匹配。请考虑改用显式接口实现。方法“{0}”的签名中的元组元素名称必须与接口方法“{1}”的元组元素名称匹配(包括返回类型)。?无法将“隐式”自定义转换运算符声明为已验证T"{0}" 不实现接口成员 "{1}"。"{2}" 无法隐式实现无法访问的成员。“{0}”未实现接口成员“{1}”。“{2}”无法采用 C# {3} 隐式地实现非公共成员。请使用语言版本“{4}”或更高版本。?无法通过对隐式索引索引器的调用为参数命名。,类型 "{0}" 不能用作 new() 目标类型"{0}" 没有目标类型%在此上下文中使用 new() 无效?无法通过对隐式范围索引器的调用为参数命名。*找不到隐式类型数组的最佳类型<隐式键入的 lambda 参数 "{0}" 不能具有默认值。-隐式类型的局部变量不能是固定值Z对隐式类型化出变量“{0}”的引用不允许出现在同一个参数列表中。JImplicitly typed lambda parameter '{0}' cannot have the 'params' modifier.E无法使用数组初始值设定项初始化隐式类型化的变量,无法将 {0} 赋予隐式类型化的变量'隐式类型化的变量不能是常量0隐式类型化的变量不能有多个声明符*隐式类型化的变量必须已初始化'引用的文件“{0}”不是程序集H导入的类型“{0}”无效。它包含循环的基类型依赖项。 out 参数不能具有 In 特性E带有 "in" 修饰符的参数不能用于动态调度的表达式。'应为 "in"f扩展方法“{0}”的第一个 "in" 或 "ref readonly" 参数必须是具体(非泛型)值类型。gThe 'in' or 'ref readonly' receiver parameter of extension must be a concrete (non-generic) value type.Y属性或索引器“{0}”不能用在此上下文中，因为 get 访问器不可访问Y属性或索引器“{0}”不能用在此上下文中，因为 set 访问器不可访问v两个索引器的名称不同；在类型中的每个索引器上的 IndexerName 特性都必须使用相同的名称Ulambda 参数的用法不一致；参数类型必须全部为显式或全部为隐式H递增或递减运算符的操作数必须是变量、属性或索引器3索引属性“{0}”的所有参数都必须可选9索引属性“{0}”具有必须提供的非可选参数索引器不能有 void 类型/“{0}”: 不能在静态类中声明索引器$索引器必须至少有一个参数?构造函数“{0}”无法通过另一构造函数调用自身wC# {0} 中不支持从包含密封 'Object.ToString' 的记录继承。请使用语言版本 '{1}’ 或更高版本。["init" 访问器不能标记为“只读”。请转而将“{0}”标记为“只读”。?'{0}': cannot declare init-only accessors in an extension block'无法使用值初始化按引用变量'无法使用引用初始化按值变量无法使用集合初始值设定项元素的最佳重载方法匹配项“{0}”。集合初始值设定项 "Add" 方法不能具有 ref 或 out 参数。与“{0}”最匹配的重载方法具有对于初始值设定项元素而言错误的签名。可初始化的 Add 必须是可访问的实例方法。Q没有显式构造函数的结构不能包含具有初始值设定项的成员。d只有自动实现的属性或使用 ‘field’ 关键字的属性才能具有初始值设定项。S属性 "System.Runtime.CompilerServices.InlineArray" 无法应用于记录结构。|只能通过可隐式转换为 "int"、"System.Index" 或 "System.Range" 的单个参数访问内联数组类型的元素。W无法将表达式转换为“{0}”，因为可能无法通过引用传递或返回它H无法将表达式转换为“{0}”，因为它不是可分配的变量?不支持类型为“{0}”的内联数组上的 foreach 语句$索引超出了内联数组的界限]不能将内联数组元素字段声明为必需、只读、可变或固定大小缓冲区。2“{0}”: 不能在静态类中声明实例成员_'{0}': cannot declare instance members in an extension block with an unnamed receiver parameteruCannot declare instance extension operator for a type that is not known to be a struct and is not known to be a classwCannot declare instance operator for a struct unless containing extension block receiver parameter is a 'ref' parameter9接口中的实例属性不能具有初始值设定项。'无法创建静态类“{0}”的实例0表达式太长或者过于复杂，无法编译被常数零除整数常量太大K应输入类型 byte、sbyte、short、ushort、int、uint、long 或 ulongH无法拦截“{0}”，因为它不是对普通成员方法的调用。[方法“{0}”必须是非泛型方法，或者具有匹配“{2}”的参数数量 {1}。B方法“{0}”必须是非泛型方法才能与“{1}”匹配。 无法截获 nameof 运算符。<侦听器不能用 "UnmanagedCallersOnlyAttribute" 标记。N给定的行有 {0} 个字符，这"this" 参数提供的字符数“{1}”。Q方法“{0}”不能用作侦听器，因为其包含类型具有类型参数。,侦听器不能具有 "null" 文件路径。0无法在全局命名空间中声明拦截器。M提供给 InterceptsLocationAttribute 的行数和字符数必须为正数。>给定文件具有 {0} 行，这少于提供的行数“{1}”-侦听器方法必须是普通成员方法。P侦听器必须具有与“{1}”上的参数“{0}”匹配的 "this" 参数。L侦听器不能具有 "this" 参数，因为“{0}”没有 "this" 参数。s提供的行数和字符数不引用标记“{0}”的开头。你是否想要使用行“{1}”和字符“{2}”?H无法截获可能的方法名称“{0}”，因为未调用此方法。f无法截获路径为“{0}”的文件中的调用，因为编译中的多个文件具有此路径。K无法使用“{0}”截获调用，因为无法在“{1}”中访问它。;无法截获: 编译不包含路径为“{0}”的文件。`无法截获: 编译不包含路径为“{0}”的文件。你是否想要使用路径“{1}”?]提供的行数和字符数不引用可截获的方法名称，而是引用令牌“{0}”。x由于 "scoped" 修饰符或 "[UnscopedRef]" 属性中存在差异，无法使用“{1}”截获对“{0}”的调用。N无法使用侦听器“{1}”截获方法“{0}”，因为签名不匹配。P此命名空间未启用“拦截器”功能。将 ‘{0}’ 添加到项目。@InterceptsLocationAttribute 的数据参数的格式不正确。SInterceptsLocationAttribute 的数据参数引用文件 "{0}" 中的无效位置。R无法截获文件 "{0}" 中的调用，因为它在编译的其他位置重复。U无法截获文件 "{0}" 中的调用，因为在编译中找不到匹配的文件。I不支持拦截器格式的版本 "{0}"。支持的最新版本为 "1"。>“{0}”: 接口中的实例事件不能有初始值设定项K条件成员“{0}”无法实现类型“{2}”中的接口成员“{1}”_“UnmanagedCallersOnly”方法“{0}”无法实现类型“{2}”中的接口成员“{1}”b“{0}”无法在类型“{2}”中实现接口成员“{1}”，因为它具有 __arglist 参数H在可实现的接口的成员中找不到显式接口声明中的 "{0}"$接口不能包含实例构造函数T在接口中声明的转换、等式或不等式运算符必须是抽象或虚拟的接口不能包含实例字段$C# 编译器中出现内部错误。-嵌入互操作方法“{0}”包含主体。?嵌入互操作结构“{0}”只能包含公共实例字段。Q无法嵌入互操作类型“{0}”，因为它缺少必需的“{1}”特性。无法嵌入在程序集“{1}”和“{2}”中同时找到的互操作类型“{0}”。请考虑将“嵌入互操作类型”属性设置为 false。应用于参数“{0}”的 InterpolatedStringHandlerArgumentAttribute 格式不正确，无法解释。请手动构建“{1}”的实例。FInterpolated string handler arguments are not allowed in this context.参数“{0}”是参数“{1}”上的内插字符串处理程序转换的参数，但在内插字符串表达式后面指定了相应的参数。请重新排序参数以将“{0}”移到“{1}”之前。未显式提供参数“{0}”，它用作参数“{1}”上的内插字符串处理程序转换的参数。请在“{1}”之前指定“{0}”的值。Z内插字符串处理程序构造不能使用动态。请手动构建“{0}”的实例。c内插字符串处理程序方法“{0}”具有不一致的返回类型。预期返回“{1}”。_内插字符串处理程序方法“{0}”格式错误。它不返回“void”或“bool”。u引用要编制索引的实例的内插字符串处理程序转换不能用于索引器成员初始化表达式中。$无法获取给定表达式的地址{无效的匿名类型成员声明符。匿名类型成员必须使用成员赋值、简单名称或成员访问来声明。.无效的秩说明符: 应为“,”或“]”A程序集区域性字符串可能不包含嵌入式 NUL 字符。B可执行文件不能是附属程序集；区域性应始终为空-程序集引用“{0}”无效，无法解析!“{0}”特性的参数值无效“{0}”的类型为“{1}”。在常量声明中指定的类型必须为 sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal、bool、string、枚举类型或引用类型。U无法从程序集“{2}”读取方法“{0}”(令牌 0x{1:X8})的调试信息: {3} 无效的调试信息格式: {0}c委托“{0}”没有调用方法，或调用方法有不受支持的返回类型或参数类型。c表达式必须可隐式转换为布尔值，或其类型“{0}”必须定义运算符“{1}”。K“Experimental” 属性的 diagnosticId 参数必须是有效的标识符表达式项“{0}”无效5Cannot use extension parameter '{0}' in this context.'无效的文件节对齐方式“{0}”-固定大小缓冲区的长度必须大于零F命令行语法错误: Guid 格式“{0}”对于选项“{1}”无效m“{0}”不是有效的函数指针返回类型修饰符。有效的修饰符为 "ref" 和 "ref readonly"。<“{0}”不是函数指针的有效调用约定说明符。8指定为 TypeForwardedTo 特性的参数的类型无效'goto case 只在 switch 语句中有效%无效的哈希算法名称:“{0}”'初始值设定项成员声明符无效E内联数组结构必须声明一个且仅声明一个实例字段。-内联数组结构不得具有显式布局。#内联数组长度必须大于 0。无效的检测类型: {0}6“{0}”不是来自“{1}”的有效参数名称。.为 #line 指令指定的行号缺少或无效E类、记录、结构或接口成员声明中的标记“{0}”无效a在 C# {1} 中，修饰符 "{0}" 对此项无效。请使用语言版本 "{2}" 或更高版本。-应为标识符或简单成员访问权限。'命名特性参数“{0}”的值无效无效数字对象创建无效无效输出名: {0}'路径映射选项的格式不正确。无效的预处理器表达式B预处理符号的名称无效；“{0}”不是有效的标识符?无法在此上下文中使用主构造函数参数“{0}”。c“{0}”访问器的可访问性修饰符必须比属性或索引器“{1}”具有更强的限制j不能在属性或索引器 "{0}" 及其访问器上指定 "readonly" 修饰符。请删除其中一个。Z无法确定条件表达式的类型，因为“{0}”和“{1}”之间没有隐式转换无效的实数。C在 AssemblySignatureKeyAttribute 中指定的签名公钥无效。'“{0}”不是有效的格式说明符'“无效的秩说明符: 应为“]”版本 {0} 对于 /subsystemversion 无效。对于 ARM 或 AppContainerExe，此版本必须是 6.02 或更高，其他情况下必须为 4.00 或更高T对于 "UnmanagedCallersOnly" 来说，“{0}”不是有效的调用约定类型。T指定版本字符串 '{0}' 不符合所需格式 - major[.minor[.build[.revision]]]c指定的版本字符串 '{0}' 不符合所需格式 - major.minor.build.revision (不带通配符)指定的版本字符串 '{0}' 包含通配符，这与确定性不兼容。请删除版本字符串中的通配符，或禁用此编译的确定性。7`with` 表达式的接收器必须具有非空类型。v在 is-type 表达式中使用可以为 null 的引用类型“{0}?”是非法的；请改用基础类型“{0}”。B类型“{0}”的表达式永远不会与提供的模式匹配。Z具有迭代器块的方法“{0}”必须是“异步的”，这样才能返回“{1}”O迭代器的元素类型不能是 ref 结构或允许 ref 结构的类型参数2goto 语句范围内没有“{0}”这样的标签Q在包含的范围中标签“{0}”遮盖了具有同样名称的另一个标签C上下文关键字 “var” 不能用作显式 lambda 返回类型i“is”或“as”运算符的第一个操作数不能是 lambda 表达式、匿名方法或方法组。>无法将具有属性的 lambda 表达式转换为表达式树0指定的语言版本“{0}”不能含前导零“{0}”无法在类型 "{2}" 中实现接口成员 "{1}", 因为功能 "{3}" 在 c # {4} 中不可用。请使用语言版本 "{5}" 或更高版本。应为 {0'不再支持 "id #" 语法。应使用 "$id"。M行包含的空格与原始字符串字面量的右行不同: '{0}' 与 '{1}'B行开头的空格与原始字符串字面量的右行不相同。9#line 指令结束位置必须大于或等于起始位置$#line 指令值缺失或超出范围e#line span 指令要求第一个圆括号之前、字符偏移量之前和文件名之前要有空格C链接 netmodule 元数据必须提供完整 PE 映像:“{0}”。c列表模式不能用于 '{0}' 类型的值。找不到合适的 \"Length\" 或 \"Count\" 属性。_无法将 Double 类型隐式转换为“{1}”类型；请使用“{0}”后缀创建此类型!只允许在脚本中使用 #load局部变量“{0}”或其成员的地址不能用作匿名方法的参数，也不能在匿名方法或 lambda 表达式内部使用?已在此范围定义了名为“{0}”的局部变量或函数X本地函数“{0}”必须声明一个正文，因为它未标记为 "static extern"。无法在此范围中声明名为“{0}”的局部变量或参数，因为该名称在封闭局部范围中用于定义局部变量或参数i'{0}': a parameter, local variable, or local function cannot have the same name as an extension parameterx'{0}': a parameter, local variable, or local function cannot have the same name as an extension container type parameterP“{0}”: 参数、局部变量或本地函数不能与方法类型参数同名嵌入来自程序集“{1}”的互操作类型“{0}”会导致当前程序集中发生名称冲突。请考虑将“嵌入互操作类型”属性设置为 false。0“{0}”不是 lock 语句要求的引用类型O由于 "{0}" 是一个类型参数，无法在其中执行非虚拟成员查找Q为 Main 方法指定的“{0}”必须是非泛型类、记录、结构或接口-未能找到为 Main 方法指定的“{0}”V无法获取托管类型(“{0}”)的地址和大小，或者声明指向它的指针-非托管类型“{0}”对于字段无效。-非托管类型“{0}”仅对字段有效。T类型“{1}”已定义了一个名为“{0}”的具有相同参数类型的成员!成员“{0}”的初始化重复<成员“{0}”无法初始化。它不是字段或属性。G'{0}': extension member names cannot be the same as their extended type8“{0}”: 成员名不能与它们的封闭类型相同方法必须具有返回类型T类型“{1}”已保留了一个名为“{0}”的具有相同参数类型的成员遇到合并冲突标记9名称“{0}”超出元数据中允许的最大长度。不支持元数据引用。0“{0}”没有与委托“{1}”匹配的重载6“{0}”没有与函数指针“{1}”匹配的重载[无法将方法组“{0}”转换为非委托类型“{1}”。是否希望调用此方法?'无法引用类型为“{0}”的变量['MethodImplAttribute.Async' cannot be manually applied to methods. Mark the method 'async'.d方法“{0}”无法实现类型“{2}”的接口访问器“{1}” 请使用显式接口实现。应输入方法名称?方法、委托或函数指针的返回类型不能是“{0}”Lref 条件运算符的分支不能引用具有不兼容声明范围的变量]An extension member syntax is disallowed in nested position within an extension member syntaxZ意外的关键字 \"record\"。你的意思是 \"record struct\" 还是 \"record class\"?H切片模式只能使用一次，并且直接在列表模式内使用。!意外的关键字“未选中”:无法将方法组转换为函数指针(是否缺少 "&"?)缺少参数<数组创建必须有数组大小或数组初始值设定项`无法找到接口“{1}”的托管组件类包装器类“{0}”(是否缺少程序集引用?)8要使用 /pdb 选项，必须同时使用 /debug 选项s找不到类型“{0}”适用的 Deconstruct 实例或扩展方法，输出参数为 {1}，返回类型为 void。1命令行语法错误: 选项“{1}”缺少 GuidZ源接口“{0}”缺少方法“{1}”，此方法对嵌入事件“{2}”是必需的。(缺少对“{0}”netmodule 的引用。0应是应用的文件名、单行注释或行尾Z类型“{0}”的声明上缺少 partial 修饰符；存在此类型的其他分部声明模式缺失+缺少编译器要求的成员“{0}.{1}”W接口“{0}”的源接口无效，该源接口是嵌入事件“{1}”所必需的。k“{0}”: 标记为 StructLayout(LayoutKind.Explicit) 的实例字段类型必须具有 FieldOffset 特性W对类型“{0}”的引用声称该类型是在“{1}”中定义的，但未能找到对类型“{0}”的引用声称在此程序集中定义了该类型，但源代码或任何添加的模块中并未定义该类型o“{0}”无法实现“{1}”，因为“{2}”是 Windows 运行时事件，“{3}”是常规 .NET 事件。ICannot use modifiers on the unnamed receiver parameter of extension block 未能发出模块“{0}”: {1}Q无法使用 "UnmanagedCallersOnly" 对模块初始值设定项进行特性化。]模块初始值设定项方法“{0}”不能是泛型的，且不得包含在泛型类型中H模块初始值设定项方法“{0}”必须可在模块级别被访问3模块初始值设定项必须是普通成员方法q模块初始化表达式方法 "{0}" 必须是静态且非虚拟的，不能有任何参数，必须返回 "void"V接口成员 "{0}" 没有最具体的实现。"{1}" 和 "{2}" 都不是最具体的。B在 for、using、fixed 或声明语句中不能使用多个类型>多个分析器配置文件不能位于同一目录({0})中。]程序定义了多个入口点。使用 /main (指定包含入口点的类型)进行编译。>不可在多个参数上使用 [EnumeratorCancellation] 属性B源文件只能包含一个文件范围内的命名空间声明。异步 foreach 语句实现“{1}”的多个实例化，因此不能在“{0}”类型的变量上运行；请尝试强制转换到特定的接口实例化foreach 语句实现“{1}”的多个实例化，因此不能在“{0}”类型的变量上运行；