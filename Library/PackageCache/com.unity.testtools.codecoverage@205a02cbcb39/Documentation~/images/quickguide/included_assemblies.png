) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function(prev, cur) {
    if (cur.indexOf('\n') >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isNull(arg) {
  return arg === null;
}

function isNullOrUndefined(arg) {
  return arg == null;
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isString(arg) {
  return typeof arg === 'string';
}

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

function isUndefined(arg) {
  return arg === void 0;
}

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}

function isBuffer(maybeBuf) {
  return isBuffer$1(maybeBuf);
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
function log() {
  console.log('%s - %s', timestamp(), format.apply(null, arguments));
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var util = {
  inherits: inherits$1,
  _extend: _extend,
  log: log,
  isBuffer: isBuffer,
  isPrimitive: isPrimitive,
  isFunction: isFunction,
  isError: isError,
  isDate: isDate,
  isObject: isObject,
  isRegExp: isRegExp,
  isUndefined: isUndefined,
  isSymbol: isSymbol,
  isString: isString,
  isNumber: isNumber,
  isNullOrUndefined: isNullOrUndefined,
  isNull: isNull,
  isBoolean: isBoolean,
  isArray: isArray,
  inspect: inspect,
  deprecate: deprecate,
  format: format,
  debuglog: debuglog
};

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return Buffer.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = Buffer.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};

// Copyright Joyent, Inc. and other Node contributors.
var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     };


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
function StringDecoder(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
}

// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

Readable.ReadableState = ReadableState;

var debug = debuglog('stream');
inherits$1(Readable, EventEmitter);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount (emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream) {

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  EventEmitter.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = Buffer.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!isBuffer$1(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false);

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners('data').length) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = EventEmitter.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

// A bit simpler than readable streams.
Writable.WritableState = WritableState;
inherits$1(Writable, EventEmitter);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Object.defineProperty(this, 'buffer', {
    get: deprecate(function () {
      return this.getBuffer();
    }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
  });
  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable(options) {

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  EventEmitter.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  nextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) nextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
        nextTick(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}

inherits$1(Duplex, Readable);

var keys = Object.keys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

// a transform stream is a readable/writable stream where you do
inherits$1(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('Not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

inherits$1(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

inherits$1(Stream, EventEmitter);
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EventEmitter.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EventEmitter.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

const init_state = (options) => {
  // State
  return {
    start_time: options.duration ? Date.now() : null,
    fixed_size_buffer: '',
    count_written: 0,
    count_created: 0,
  };
};

// Generate a random number between 0 and 1 with 2 decimals. The function is idempotent if it detect the "seed" option.
const random = function(options={}){
  if(options.seed){
    return options.seed = options.seed * Math.PI * 100 % 100 / 100;
  }else {
    return Math.random();
  }
};

const types = {
  // Generate an ASCII value.
  ascii: function({options}){
    const column = [];
    const nb_chars = Math.ceil(random(options) * options.maxWordLength);
    for(let i=0; i<nb_chars; i++){
      const char = Math.floor(random(options) * 32);
      column.push(String.fromCharCode(char + (char < 16 ? 65 : 97 - 16)));
    }
    return column.join('');
  },
  // Generate an integer value.
  int: function({options}){
    return Math.floor(random(options) * Math.pow(2, 52));
  },
  // Generate an boolean value.
  bool: function({options}){
    return Math.floor(random(options) * 2);
  }
};

const camelize = function(str){
  return str.replace(/_([a-z])/gi, function(_, match){
    return match.toUpperCase();
  });
};

const normalize_options = (opts) => {
  // Convert Stream Readable options if underscored
  if(opts.high_water_mark){
    opts.highWaterMark = opts.high_water_mark;
  }
  if(opts.object_mode){
    opts.objectMode = opts.object_mode;
  }
  // Clone and camelize options
  const options = {};
  for(const k in opts){
    options[camelize(k)] = opts[k];
  }
  // Normalize options
  const dft = {
    columns: 8,
    delimiter: ',',
    duration: null,
    encoding: null,
    end: null,
    eof: false,
    fixedSize: false,
    length: -1,
    maxWordLength: 16,
    rowDelimiter: '\n',
    seed: false,
    sleep: 0,
  };
  for(const k in dft){
    if(options[k] === undefined){
      options[k] = dft[k];
    }
  }
  // Default values
  if(options.eof === true){
    options.eof = options.rowDelimiter;
  }
  if(typeof options.columns === 'number'){
    options.columns = new Array(options.columns);
  }
  const accepted_header_types = Object.keys(types).filter((t) => (!['super_', 'camelize'].includes(t)));
  for(let i = 0; i < options.columns.length; i++){
    const v = options.columns[i] || 'ascii';
    if(typeof v === 'string'){
      if(!accepted_header_types.includes(v)){
        throw Error(`Invalid column type: got "${v}", default values are ${JSON.stringify(accepted_header_types)}`);
      }
      options.columns[i] = types[v];
    }
  }
  return options;
};

const read = (options, state, size, push, close) => {
  // Already started
  const data = [];
  let length = state.fixed_size_buffer.length;
  if(length !== 0){
    data.push(state.fixed_size_buffer);
  }
  // eslint-disable-next-line
  while(true){
    // Time for some rest: flush first and stop later
    if((state.count_created === options.length) || (options.end && Date.now() > options.end) || (options.duration && Date.now() > state.start_time + options.duration)){
      // Flush
      if(data.length){
        if(options.objectMode){
          for(const record of data){
            push(record);
          }
        }else {
          push(data.join('') + (options.eof ? options.eof : ''));
        }
        state.end = true;
      }else {
        close();
      }
      return;
    }
    // Create the record
    let record = [];
    let recordLength;
    for(const fn of options.columns){
      const result = fn({options: options, state: state});
      const type = typeof result;
      if(result !== null && type !== 'string' && type !== 'number'){
        return Error([
          'INVALID_VALUE:',
          'values returned by column function must be',
          'a string, a number or null,',
          `got ${JSON.stringify(result)}`
        ].join(' '));
      }
      record.push(result);
    }
    // Obtain record length
    if(options.objectMode){
      recordLength = 0;
      // recordLength is currently equal to the number of columns
      // This is wrong and shall equal to 1 record only
      for(const column of record){
        recordLength += column.length;
      }
    }else {
      // Stringify the record
      record = (state.count_created === 0 ? '' : options.rowDelimiter)+record.join(options.delimiter);
      recordLength = record.length;
    }
    state.count_created++;
    if(length + recordLength > size){
      if(options.objectMode){
        data.push(record);
        for(const record of data){
          push(record);
        }
      }else {
        if(options.fixedSize){
          state.fixed_size_buffer = record.substr(size - length);
          data.push(record.substr(0, size - length));
        }else {
          data.push(record);
        }
        push(data.join(''));
      }
      return;
    }
    length += recordLength;
    data.push(record);
  }
};

const Generator = function(options = {}){
  this.options = normalize_options(options);
  // Call parent constructor
  Stream.Readable.call(this, this.options);
  this.state = init_state(this.options);
  return this;
};
util.inherits(Generator, Stream.Readable);

// Stop the generation.
Generator.prototype.end = function(){
  this.push(null);
};
// Put new data into the read queue.
Generator.prototype._read = function(size){
  const self = this;
  const err = read(this.options, this.state, size, function(chunk) {
    self.__push(chunk);
  }, function(){
    self.push(null);
  });
  if(err){
    this.destroy(err);
  }
};
// Put new data into the read queue.
Generator.prototype.__push = function(record){
  // console.log('push', record)
  const push = () => {
    this.state.count_written++;
    this.push(record);
    if(this.state.end === true){
      return this.push(null);
    }
  };
  this.options.sleep > 0 ? setTimeout(push, this.options.sleep) : push();
};

const generate = function(options){
  if(typeof options === 'string' && /\d+/.test(options)){
    options = parseInt(options);
  }
  if(Number.isInteger(options)){
    options = {length: options};
  }else if(typeof options !== 'object' || options === null){
    throw Error('Invalid Argument: options must be an object or an integer');
  }
  if(!Number.isInteger(options.length)){
    throw Error('Invalid Argument: length is not defined');
  }
  const chunks = [];
  let work = true;
  // See https://nodejs.org/api/stream.html#stream_new_stream_readable_options
  options.highWaterMark = options.objectMode ? 16 : 16384;
  const generator = new Generator(options);
  generator.push = function(chunk){
    if(chunk === null){
      return work = false; 
    }
    if(options.objectMode){
      chunks.push(chunk);
    }else {
      chunks.push(chunk);  
    }
  };
  while(work){
    generator._read(options.highWaterMark);
  }
  if(!options.objectMode){
    return chunks.join('');
  }else {
    return chunks;
  }
};

export { generate };
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      MZ                @                                      	!L!This program cannot be run in DOS mode.
$       mHmHmHImHkHmHmHhHmHmHImHImHImHImHImHHmHHmHImHRichmH                        PE  d [         " & `                        
   
   
            "G  `A                                      P    `    0            p   8 p                           r H          s   x                    .text   G     P                   `fothk       `     `                `.rdata     p     p             @  @.data   p%                       @  .pdata     0                   @  @.didat  `    P     0             @  .rsrc      `     @             @  @.reloc     p     P             @  B                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        @SH H   3HE H6   WH W HG ^ f H [	  HF h	  H0  H H+ H H= H H+  H H\  H$  Hc  H  Hoc  H Hc  H  Hd  H  Ho  H  HL  H H/  HR HK)  H Hd  H. H-  H HB  H HT  H HeT  H HE   HE   H(   H"   H3H(H H H(HH3H(H(t9t(tt
   H(F    H(IH(   MH(   H\$Ht$H|$ AVH HL3       D$@@=         t  tOk  
  
  H"j Hj   u)	  t Hi Hi   x    @2  @u:
  HH8 tH  tL   IH8L 2    3H\$0Ht$8H|$HH A^   Q
  H\$WH0@ 3H\$@H0_   D$ = u3;  	    %    3@  I     	  HHX L@PHHVWAVH@ILu9L 3   BwDHl Hu
D$0    K D$0   LID$0   LI  D$0u7u3L3I~  L3IQH*l HtL3IJ tu?LI"D$0t(Hk Hu	X\$0LIfJ D$03\$0H\$xH@A^_^H\$Ht$WH IHu  LHH\$0Ht$8H _ff     H; uHfuH"  H(  t!eH%0   HHH;t3H u2H(H({  t	  _    t2  H(H(3Y  H(H(7  u2*  u!  H(H(    H(H\$Hl$Ht$WH IIH
  uuL3HHH HT$XL$PH\$0Hl$8Ht$@H _  H(o
  tH| H(  v  u
  H(H(3I  H(@  H(u^ P    u2  u	3  H(@SH =  ugwj	  t(u$H w
  uH g
  t.23foi H H  H  H [     HLMZ  f95uxHchH%H9PE  u_  f9AuTL+QHHAHLH$I;tJL;r
BL;rH(3Hu2z$ }2
22H@SH   3tuH H [@SH =  tu~  w  H [@SH H=^ Hu  HHH 	  3HDHH [H(HH(  @SH H3[ H[ \ H	 H [H%\ HL$H8   \ t   )Hz   HD$8Ha HD$8HH HJ H HD$@H  	            Hk H H      Hk H HL    HkH$ HL HT H8H(      H(L$H(   \ tD$0)H y   HD$(Hm HD$(HH HV H  	            Hk H T$0HHT 5H(HHX WH@H` HH` H` [ H   HT$PHE3[ Ht2Hd$8 HL$XHT$PLHL$0LHL$`HL$(3H\$ }[ H\$hH@_@SVWH@Hd$h HHd$` Hd$p 9[ H   3E3HT$`H'[ Ht9Hd$8 HL$hHT$`LHL$0LHL$pHL$(3H\$ Z |H@_^[H\$UHH0H H2-+  H;uyHe HMHe a[ HEHEZ H1EY HMH1EZ EHMH H3EH3EH3H  H#H3-+  H;HDH\ H\$PHH H0]H(uH=c  uX    H(H H%X H j  H('H$.HH(H %  H\$UH$@H     X t)   3HMA    HM1Y H   H  H   HE3Y HtLHd$8 H  H   LH   LH  HL$0H  HL$(HMHL$ 3X H  HL$PH   3H  A   HH     H  HD$`D$P  @D$T   V 3HD$PHD$@HEHD$HV HL$@V utHH$  H  ]H\$WH H H= HHt)@ HH;rH\$0H _H\$WH Hs H=l HHt? HH;rH\$0H _H\$Ht$WH33DE3DAntelAineID3ACEAGenu$E\$L$T$u[H %?H    = t(=` t!=p t w$H     HsD AD D    DH;|&3$D\$L$T$	s
ED     D    D     syss3H HHT$ HD$ ":uW      A t8        D#D;uHD$ $<up @f H\$(3Ht$0H_   39P      %W %XW %DW %W %V %V %V %V %V %V %,V %(V %$V %V %V %
V %V %V %V %V H\$Hl$Ht$WH0IIHHH\$(LHd$  LHHHH\$@Hl$HHt$PHH0_HL$HT$LD$LL$ HhfD$ fL$0fT$@f\$PHH 0 foD$ foL$0foT$@fo\$PHL$pHT$xL$   L$   Hh H+ uH+ cH+ QH+ ?HL$HT$LD$LL$ HhfD$ fL$0fT$@f\$PHH Z/ foD$ foL$0foT$@fo\$PHL$pHT$xL$   L$   Hh Hc+ uHL$HT$LD$LL$ HhfD$ fL$0fT$@f\$PHH . foD$ foL$0foT$@fo\$PHL$pHT$xL$   L$   Hh H* uH* cH* QH(N t8t/HT$0D$0 HCJ <   xD$0 2H(H-* %O 3H(9 tHQ H   {/  H(H(9 tHQ HHN/  H(H\$WH : HtIHZ(HHQ D  H\$8H   HCH+HrHU  HHCHL$8G@ 
  H\$0H _H\$WH : Ht.HZ HH8Q D  HL$8H\$8GA P
  H  H\$0H __/  HHH#  LHXIc H$   ICH$   ICH$   IC  HXHXH$   HD$0H$   HD$(	  H\$Ht$WH`H$   Ln^ Ht$(H  ~  D$PP!  d$X L<^ D$THD$PHHD$0Ht$(gHHXHhHpWH`H$   L\ HhH  ~	  \$P   d$X D$THHD$PHD$0Hl$(L\$`I[IkIs I_HhLD$   L$Pz   d$X AD$TIHD$PHD$0H$   HD$(?HhHhLD$   L$P&   d$X AD$TIHD$PHD$0H$   HD$(H$   HD$ HhHhLD L$P  d$X AD$TIHD$PHD$0H$   HD$(H\$ UVW   R+ H+H$h  IH3H$   A   H$   E3HD$pLH$   HD$`HH$   HD$PHd$@ H$p  HD$8D$0   H\$(Hd$  M#  H$   K  H\$Ht$ W0  * H+H) H3H$   H$h  H3H$   A   4H$   E3HD$pL%Z H$   HD$`HH$   HD$PHd$@ H$p  HD$8D$0   H\$(Hd$  "  $   tH$    K  H$   H3L$0  I[ Is(I_@SUVWATAUAVAW8  ) H+H3 H3H$   H$  MH$  DH$  LH$  H$   3A   MH$   MHD$pMHD$h   H$   HD$`AHD$X   H$   HD$PID$H H\$@H|$8D$0   Ht$(Hl$ l!  $   tH$   J  H$   H3tH8  A_A^A]A\_^][H\$Ht$WH IHH;t7Mt2A8 t,I78  H+HH;rLHQ  HtH;H>HtI! HH\$0Ht$8H _H(HH" HT$0HD$0&HH(HHD$pLfDAE3fAfDIL$xAJft)L$"WHL$ fD$ D$0DD$$fDD$(u  IIBIMBMB MB(MB0fEB8EB:HH@SH E33HHJ D  3HC(HC0HC8HC@HH [H\$WH0   3D@|$(3f\$ ALDD$(3f\$ IK@DDL$(3f|$ I   H\$@IH0_H(LJHIH|IH(@SH HHHG D  CH H [@SH0HYHttX)  t
aHKHT$@I  u=HK  3HL$@{L  HW   H$G D  L3HH G D  HL$@  H0[H(HIHt4  H(@SH HH(   HK  HKH [s  @SH HH   HK  HKH [C  H\$Hl$Ht$WH HiPHH;t=H7'HHvHAF D  L3HHF D  HuH7HH;uH\$0Hl$8Ht$@H _H\$Hl$Ht$WH HiPHH;tFH70HHvHK  HE D  L3HHE D  HuH7HH;uH\$0Hl$8Ht$@H _H(HIpHtHH@. H(H(H	HtGB  H(H(H	HtD  H(H(H	HtHF D  H(H(H	HtHUF D  H(H(H	HtHF D  H(H(H	Ht  H(@SH HHt,H# HuHS J  H HtH- H [H(H	Ht  H(H(H	Ht2  H(H\$WH H H3}H  H (  HKhHch Ht  HKHHcH Ht  HK(wHK nHKH\$0H _@SH H%  H      HKH [  H\$Ht$WH H H03G  3HK8G  H   H    Ht  H   H   p   H   hHKH[   HK86HK0-HKH\$0Ht$8H _@SH HHbHH [U@SH HHI@Hc@ Hth  HH [H%)D @SH HH   H    Ht*  HKpHcp Ht  HK0Hc0 Ht  H [H(9 uIHA D  H(@SH HHH" H	HHt
  HH [@SH0HAHLQH I9r2HD$hM	M HDHD$`HID\$(LLT$ *  2tHK   HH0[@SH H; HHt
   HH [@SH H: HHt
    bHH [H\$H|$ UH$Hp  H H3H`  H" HHHHA D  H\$(LQ DD$ x     HL$P5  Hd$0 HT$PA  E33HB D  HHL$0E  H|$0 u	Q  lHT$8HL$0zB  Hd$@ HT$@HL$P9:  y +  Hx  Dc/  HL$8"HL$@HtIH	HHL$83HL$0gH`  H3.L$p  I[ I{(I]LHT$0HL$P  y4  pH\$H|$ UH$Hp  H H3H`  H" HHH? D  H\$(LO DD$ 0    HL$PY4  Hd$0 HT$PA  E33H@ D  HHL$0C  H|$0 u	  lHT$8HL$0A  Hd$@ HT$@HL$P8  y +  Hx  D-  HL$8I"HL$@HtIH	HHL$8'3HL$0H`  H3L$p  I[ I{(I]LHT$0HL$P  y4  pHHXHhHpHx AVH HyE3A HH4HHH;t;H@HH= D  L3HH{= D  L7LwHPHGH;uH]Hg= D  L3HHC= D  H\$0Ht$@H|$HDu LuHl$8H A^H(H< D  uHL$(	  ?  H(H(ALL;uHQI DD+AH(H\$UVWH`  H* H3H$P  H       IHLtu>  LHL$@  1  LL HL$@-1  HLL$@H   DHDG?  y   H$x  D+  8LkL HL$@0  HMLL$@ED>  y   3H$P  H3rH$  H`  _^]H%; @SH E3E33HH= D     HH= D  HH [H%= @SH 3H4@  HK3H [$@  @SH H	HHt*IiAHT$0EHD$0E3H== D  H [H\$Ht$ WH Hy H   HL$8	H t3@H u(HOHT$0Hd$0 CxH u	HD$0HGHGHH HHH#H_ HHH< D  H H\$0uHwHL$0YHL$8CH H\$@Ht$HH _H( uH    H(H\$WH 9 HtwHYHH; D  H\$0H_ H; t_AH# H[ HuH HtLHxH# H; u3	   _HL$0{3H\$8H _HHHD$HLPI 7  HD$(iH\$Ht$H|$ UATAUAVAWHHPA3fEAWAMEMLH}f}EH9yv|HA 3I+HqHAGH;vI5  EGML}PAH^IL|$ HIi  LH;   LF HU0HMHE0  MHMIaDJA;_sBLF HU0HMLu0W  tLEPHMI+D~Lu0IB5  Eu.@8}tUHMUX(5  HF8	HF8@88t@@83IL\$PI[8Is@I{HIA_A^A]A\]@SH H  u%HtHSH     HK  H [H\$Ht$WH@AHD=  Hd$0 H\$(A   DH|$    H7 D  H\$PHt$XH@_@SH HH6 D  L3HH [H%6 H\$Hl$Ht$WAVAWH 3MLH= H@H   H]7 D  DDHIHHHL+J<HtD9tHHHHtBH9t=AMHMH  tLvHH?HOHHH  H@
HuH Ht@uFtHp H\$@Hl$HHt$PH A_A^_@SH HH{6 D  ( ;t@   7 }%
 Y  HtHHi(        H [H( u"A@   L 3H     H H(H\$ UVWAVAWHP  Hb H3H$@  E3IHLH]  HT  H fD9Ht!D8= tLHH" fE9>#  H5eA @t@t#tu8H5A /HuA H5fA HQA H5:A @kHDH5A 3HL$@A   @kt#H kHtJA   HT$@ 6kHD$@L|$0DD$(   A   3HD$    H=4 D  LK8I<~H   HH   Mt"HD$0L@ C@HL$(ID$   LHD$ IL@   L   LMtL@ HH  LH4 D  KDHT$@HT$8L@ l$0LD$(HL$ I  L9{uL9{Hu
L9{0   L@ HH_  LKMtL@ HHD  LKHMtL@ HH)  HK(HLK0HtHL$ L@ H  "HMtL@   L@   3H$@  H3H$  HP  A_A^_^]H\$Ht$WH@IHH1 D  u-HD$xE3D$0LHD$(Hd$  H  H\$PHt$XH@_H8HD$8E33HD$(3z~  H8H\$ VWAVHP  H H3H$@  HI3IHL$ LHt,LD$ H   H1 D  u
Mt=A!8HL$ Mt
Ht+A>H   A  HT$0Hl1 D  u2yHL$0HH< uHL$0H	y\tHHD$0H;wHtCHv 5AL+H+I0HttHHuHHKHE H$@  H3H$  HP  A^_^f9 u
AHQuHHHHDH\$Hl$Ht$WH 2A  IIHHH   HRHV H   : u    {P uCPJK`H/ChJKxHHH< uHHH+H~4\HLBHA< uH+HH;HHCHL7  D; H\$0Hl$8Ht$@H _H\$WH H 3H   H9{u%HHT$8H!|$84xH9{u	HD$8HCHCHH HHH#tZH/ D  DDHIHHHL+JLHt#D9	tHIHHtHy uHCHAH\$0HH _Ht$WH HH3H/ D  u   HL$(  /  t=  t
     d$@    Hu[LD$@H/ D  u   D$@E3HAPHb/ D  uHb- D  =*           d$H LD$HH'/ D  u
   L|$H t   gE3HAPH. D  uHH, D  =*  u53HH. D  u
   t   D$@3   HL$(A    Ht$0H _ ;      W ;jt^@ tL t: t( t     p  :  f  4  \    R    H    >  p t:z t({ t~    5   3    #               ~;ctZtH>t6Ft$GtruUs    c    a    %          Y  |toOt`tQtIsT  #=   u  E1#=  	 u~"  	3   + H\$Hl$VWAVH@EAH H LHEDA$<u2   A   H$   LL$xd$x D   I{3  L$x@|$x uqum=H  tdH-G HHE, D  F Hl$ t.;u*d$, HT$(d$( HW A   H\$0-  u#HL$ "@H$   DE3    2  H\$`Hl$hH@A^_^H\$UVWAVAWHl$H   HAWH
HHEwE3AHfEAEAfEAED}fD}ED}fD}ELC HUwHMw     Lu'A;}sLC HUwHMR  tEHNpEgEHEHEHEEHELuHt>HHUgHT$(LMHUHT$ LEH@ HUe tHQ2   )H>H$   H   A_A^_^]H\$T$HL$UVWATAUAVAWH@H$   ML$   E3H$   L$   ML$   AfED A?{AGCtit[tuc  Xx;H$   |$0MHD$(IH$   HD$ {CA  X  ?  3+{AuC      / CH$   Htf98uHHCH:( D  Lk8WC $   C@H$   HC(H$   H   H$   H   3sDLc0H{HChHCxCPHC`HS Ht HH   H HtHi H HtH$   A   HG H HtH3 H HtCuH 9{|tj(   KC@8=2 u%H Ht	 H% D  tCt$H Htc@8= uZE33H KH    Ht@8= uDIHy fA9>uLHIIH;% D  Cu	@8= tH Ht6 H$   H@A_A^A]A\_^]LMCMK SVWH@HIC H+3HHtHwMICa  f1H;tHHf94CuHCHH@_^[LI[IkIs WAVAWH@AE3fD$ WAMD$"IE{HfE{HD$0Mt[LE HT$`HHL$ HHHEHHD$`  L$   HL$ I~Ht$`HH+HHHuH\$hHHt$xHl$pH@A_A^_H\$Ht$H|$AVH0I  Lx   HIJ  HHuHL$8 DH       WD$ t%  LHL$ IHy(HL$8DK  G  HL$ Hf   HK";3IHCHD$ DGUI& Hd$  HCHD$(Hd$( HCfC X HK(3{$DGOHL$ H3H\$@Ht$HH|$PH0A^H\$Ht$H|$AVH0I  LH0     I  HHuHL$8 DH  \     WD$ t$  LHL$ IHy(HL$8DK    HL$ Hwj   HK(I3HCA  HD$ I& Hd$  HCHD$(Hd$( HC3HK(HC H   HL$ H_3H\$@Ht$HH|$PH0A^H\$H|$UHHPA3EHHAHEE fEA@fEHA8HEH   HEH }@}}f}}H}HuHp0 &  H HtLE3HU
 MECttuK
KKH\$hH|$pHP]@SH x3?  u 0H: Hth
 t==  t~  H [H\$UVWAVAWH HHHHd" D  H~0HL$PH+~(HHl$P3H   Ht$XHl$PHE3E3H" D  HH " D  HHH;s4HV(HKL94u	HHHHfofI~fsfI~HL$PMtIIi	 HL$XH;oH\$`H A_A^_^]H\$WH 9 HtgHYHHt! D  HGPLGXH\$0I;tHH:  !HHGPHGX   OEHL$0GKH\$8H _H\$Ht$WH HH D  LHHH D  HH HuR8L uUH- H D  HtH- HH D  H H  HtHH Ht$8HH\$0H _@SH   HHL$ HT$ HA  HL$ C  HL$ H   [@SH 38J uH! Ht tH [H\$Hl$Ht$ WAVAWH@E3AADHD89      H_(HH| D  H   H\$ EGfD|$.HT$(Dt$(fl$,t$0   H_8D8@uOL9;u8HL$`E3H^HHt D  HH!  HL$`&A  HW@HHL$ H\$hHl$pHt$xH@A_A^_HHXHhVWATAVAWH E3IyLLHu3IhH;   At$LADfD`HH$  D$PC'   @8quIhH;wLVLADH$  LLsfAfuIhH;wLHIt$  LAIH;v2	LCIH\$XHl$`H A_A^A\_^H\$UHH`H\ H3HEy8 Ht2H, LHEHMH,    HEH, HE~  {x t3H, LC@HEHMHZ,    HEHz, HEE      tWH, L   HEHMH,    HEH[, HEH, HEH, HEHB, HE  HMH3H\$xH`]H\$Ht$WH Hq8HHY0HH+Hr-H;tHSn&  HHG0E3   HG83  H\$0Ht$8H _         H\$Hl$Ht$WH0IAHA   t{   r   |   r2fH D  H|$ w
   r  vHOHDD  DHO  _@HL$   H\$@Hl$HHt$PH0_H\$Hl$Ht$ WH09 IAH   g   HOLD   	u|H_ HH D  A H\$ H_0uPH; u8HL$@;E3HqHH D  HHg  HL$@A HWAHHL$ H\$HHl$PHt$XH0_          ?  HD@PH8DHHPA   LHL@   H8HD@PH8A   @   LHL@HPx   H8@SH   HHL$ RHH D  HT$ H$   H  H$   HL$ HL$ H   [HHXHhHpWAVAWHPD$   IH$   IDxLHpH   t   HV HHKH9 u_WHL$0WH
D$0L$@#  t*HT$0E3LL$@HL+  HK0HT$HC:HL$HHt{: t  D|$(LLHt$ IH"   L\$PI[ Ik(Is0IA_A^_H\$Ht$H|$ UATAUAVAWHH   HyE3MMLHH  AH
fEWAAEH}DufDuELF HUHMtqMHMIxMLEHUtH	  HHEMXML$(HMPHL$ HjHEHHu3  H}MtDu,H}H~ He HMA   fD}DuLeLNEXHe fMNEHEPMHMfELmLN(IM< LF I+M;HH#I;   M+I?L+L+tDHt(Ht#M;r
H +H D   "   H D      LF MLF uHUHMm  } tAVHM  LF HUHMG  F82L$   I[8Is@I{HIA_A^A]A\]H\$UVWAVAWH$P   H+Ht H3H@  3L<H!t$PMHAFHMENEFAD$(AFfD$ d$D HD$@HD$(LL$DHE@D$@   HHD$ D  st3!D$DD$@D$@DHU@A   HMA  }    Hd$H HD$HHD$`HUHD$PIHD$hHE(D$`HD$pH L$pHEHEHE0EM%} tRL$DDEHUD$0   D+L$(H  =  uH2/tDEHHUd$0 D+d$(   HD$HHHD$PHMHe Htvu$I;sH2HMHe HtNH@  H3H$  HP  A_A^_^]@SH0HtuoHK H0[HKHT$HZ  u=HK3HL$H  HH D  L3HH D  HL$H{H0[H(H1 D  uHL$(	  a  H(HHuAHH< u   H3HuBHHf9AuHE   H\$WH y@ HHtHQH~
      tHSHHO@h
      tH   H   L
  H\$0H _H8HD$8HD$(H8HHHD$HDL$0HD$(HH@SH H 3HuH h  H Ht H [H\$WH H 3HuH   H Ht	W H\$0H _H\$Hl$Ht$WATAUAVAWH DAHY BHq8AE3LyHB@LfAAL;H   HA(H   HA0L>HJIL$8LI$   LLH}HL9}@tL97sGI   LHt/H]@H D  L3HH D  L}@H] L7E3HM@H   H?LMMD$8HHM$   LHHIL$HH;t9Ht4fD99t.NHHH+H;rLLH  HtHHHtL>H+3LHH\$PHl$XHt$`H A_A^A]A\_HHXHhHpHx AVH IIHHI
sHL$(  HI0E3Ls0HtH{H/HC H7HC(Ds9H
rLHOfD97wf9AvC9fD97u,f9u$Cf9GuC8GuCf9GuC8G	t3fD7fGCfGCGCfGCG	HCH
HC H\$0Hl$8Ht$@H|$HH A^HHXHhHpHx AVH y3HHDuPH9iu6t2  MHCHtC    H  fD0IH;uLCMtnt0C IHHHIHAH;tC9AvF9t?IC"3K fS"HHCHIA   D AHyH\$0Hl$8Ht$@H|$HH A^H\$Hl$LD$VWAVH@E3IHHL9qv-HA 3H+AHqOH;v
H  GHEHZWAAfD$ AD$"Dt$$fDt$(D$0D9rv#LE HT$pHL$ t;wrH\$pH  Hl$hHH\$`H@A^_^@SH0  MDLH3f9t
HIuHII+HIML#H%W MtI+KBM   H0[H8HBH=vE3W HtfDMY   H8LD$LL$ HHHBMH=vE3W HtfDHD$hHD$ i   HHE3LHt(L+HtCftfAHIHuHIHH%z HIEfDH\$Ht$WH HzMLL$PHH3xHH;wuf~	f~z Ht$8H\$0H _H\$Hl$VWAVH09 EAHHtfHYHH? D  EH\$PEt+D;u&d$$ HMPA   |$ HT$ Ht$(  u%:  !HL$PH\$XHl$`H0A^_^EDHH CH\$Hl$VWAVH0H" I9 MHH   HY HHs
 D  H\$PH   H; uHH# H HuH   H Hu9 LH+E3H uHOHLMH"  HL$P(H\$XHl$`H0A^_^H\$Hl$ VWAVH H" I9 HH      H   H_ HH	 D  L   H\$HI> uDH_Ht;I& HH[	 D  H   H\$@LLIX   HL$@^H   E3LH9   HHt   HHHL$H,H\$PHl$XH A^_^H\$WH0H" HY(HMLK3L+MIHE3I;s%I< HPt	HIHLLTH/A   L\$ HT$ LT$(H	  tHCH+HHH\$@H0_H\$Ht$WH@HHHQHL$ UWHN0HW0VG(F(JD$ HT$8L$0HO0GO((HL$8HtN8G8H\$PF8O8N9G9F9Ht$XO9H@_H\$WH H" LD$8Hd$8 HO   y(HL$(Dd   HL$(Dm   HD$8HH3H\$0H _HHXHpHx UHH`  H H3HP  I3I  LHL$@7LH HL$@LD$@3  H D  HD$0Hu-Hm D     Hh        HT$$\$$H\$ 2yHh  D      L HL$@$LD$@3  HE D  HD$(HuHh     HL$(THT$ Hy#Hh  D   |HL$(qHL$(HcT$ HcL$$HHHHL$0HP  H3HL$`  I[IsI{(I]M   H\$Ht$WH IHHH  D  HH\$HH4 D  HK(HWHC0H+Ht$@HH;sHWHL$@-HL$HH\$0Ht$8H _H(LHtHQ HtH   HH(H(LAA9t7AA<uA   fT$8LD$8A<u   DHI
  H(HXDMAALT$ WD$0BHL$0A3HD$@ 3EL$0|$@ t|$D t@HXuEuuH; 6sEDH  Eu   tD  EDH &IuLHH MLHH H(Hs=  t5IL#H =w  tLH H H(H8H] HuH HtE3d H8Ht5H\$WH HHYDCKH[HuH\$0H _H(H HuH Ht H(H\$Ht$WH HAH HHb  D  HH Hl  D  HtDHH H\$0Ht$8H _@SH   H4 HHtW H HtHC 3HL$ A   YH   A   DD$8D$ 	 DD$$HD$@   HuHL$ 6   HcCE3HD$HC@HL$0HL$ HD$PD$8   
   H(Hq Ht3    )H(LI[IsI{ ATAVAWH yIHLHu!LsM;w~AMCA   fD$@Ayu LsL;wW   LADH  If> u)L{L;w1LvHH+MA   H  ILvEIH;v2LFH+HH  AHI$H\$HHt$PH|$XH A_A^A\   )H8HD$8HD$(yHHHD$HLD {  HD$(Hy HABIJH\$WH HHHE3Hd D  =  ttHL$(3HHH\$0H _HHXHpWH0H@  33XH D  HHtH D  HH  Ht$HH\$@H0_  HAH+LAHL+I;sK H;HBj   H\$Ht$WH HIIHt&HKLHCLH+H;KHH#  H{H\$0Ht$8H _LI[IsI{ AVH HAHH+HH;sxIK@H3H@HHHuHL$02ILsHL+3HLM  HKHsHtI6H3HCHL$0H>HCH\$8Ht$@H|$HH A^H\$Ht$WH H9HHHtHL$0HHL$03H3H\$8Ht$@H _H\$Ht$WH H9HHHtHL$05HHL$0H3H\$8Ht$@H _H\$Ht$WH H9HHHtHL$0HHL$0H3H\$8Ht$@H _H\$WH H 3HHuH Hs D  H HtHHHu D  HHH\$0H _H(H} HuH9 H D  H^ H(@SH HHHH [H%  HHXHpHxUATAVH`  g H+H H3HP  HA3H+3LHX  3I3HL$PA   d$D HD$@HD$(LL$DHD$PD$@   Hm
 HD$      DL$@IIHHRHL;tE3DL$@MIAHINILI+HIHHRMjAH@HHL$PH;t&A 9uA@f9AtHA@ADL$@+AHH=   wA AAA@BDL$@IHT$PM;uD$DH	 D$0   ED$(D    ud}DHP  H3}L$`  I[ Is(I{0IA^A\]H\$Ht$WH IIHMu3dHuH D     CHtH;rLH L3HtH;sHD D  "      H\$0Ht$8H _H\$UVWAVAWHPH H3HD$H3MEH\$0D@H3HD$8D$@Hx HuH H` Hu9 kLL$8LD$0A( u9L$<z$?FD$@FF#F=  uL$<   #NMt"  AHL$HH3H$   HPA_A^_^]HH(H`  H fP$EtfH&Hx HuH H` Hu9 
HL$HB H(H\$Ht$WH H AHuHG H HtD H\$0Ht$8H _H\$WH@L IHMu"H PH LHu9 'HD$xLHD$(E3HD$p3HD$ HIk H\$PH@_H\$Ht$WH@L AHHMu"H H LHu9 -$   E3D$0DD$xHD$(HHd$  I H\$PHt$XH@_HhH H3HD$PLD
DA@DutAIAADDEAu#   LD$ DHAtDT$ LD$(D$$  tEA@  ItEA@  IrEA@  IA  At"fA#EfAHfA#ffA@It$ffA#EffAfA@fAPIHD$ L+IM~IHL$ BHL$PH3HhH\$Ht$ UWATAVAWH$H`  HH H3HP  Hd$( MHd$  LH3A  HL$0OHT$(HL$ 8; H\$ ]  d$8 D$0   D$@  D$4  D$H   HHt*H D  L$8HDLL$8HHHD`/L%K IHy D  L$8HDLD$8HLd`D$8L  A   AD$8HDdHD$8HTLD$8HLD`D$8AD$8HDH   D$8HDL   L$8HD$(HHDPD$8AD$8HDdHD$8HTLD$8HLD`D$8AD$8HDdHD$8z HLLHz D$8HHL`D$8AD$8HDdHD$8HLLD$8HHt`At$D$8AHD$8tHIHT D  L$8HDLD$8HLt`Et$D$8HLtPD$8AHD$8tHIH D  L$8E3H3DLHL$0D$8HL|`D$8HLtPDd$8  u HtHH D  HP  H3L$`  I[0IsHIA_A^A\_]HHXHpHx UAVAWHH`  H#~ H3HP  L5 HHd$( HL$0Hd$  3A  )HT$(HL$ 8 H\$   d$8 D$0   D$@  D$4k  D$H   HHt*H D  L$8HDLL$8HHHD`/L=% IHS D  L$8HDLD$8HL|`D$8A   \ D$8HDH   D$8HLLH4 D$8HHL`D$8D$8HDH   D$8HDL   L$8HD$(HHDPD$8HD$8D|HHH D  L$8HDLD$8HHt`AwD$8HHtPD$8HD$8D|HIH D  L$8E3H3DLHL$0D$8HLt`D$8HHtPD$8    HtHHB D  HP  H3L$`  I[(Is0I{8IA_A^]H\$Ht$ UWAVHl$H   H{ H3HE7e De @2W@}W@:3HEMH D  H D    H H D  u
        HUfE  HE@HE/G    H HMH+ D  HE3HD$PLMHEHD$HLEHEHD$@H D$8 Hv HD$0Hz Dt$(HD$ H D  x	} |@>H. D  H( D  @tH H D  HM7H3mL$   I[0Is8IA^_]@USWHl$H   3E0   H!EgLEH!EHMo!E'3H!}oWH!}w   !}!}+H!EEHEEE/eL%0   I@H D     HMoLEwWH D  xuWHMH D  x\H HH   HJ D  Ht HH  H+ D  HX D  HHuw  H}g teH%`   3LEgHI0H D  HtHH! D  HMoHtH| D  HMwHtHg D  H   _[]A   HHr D  mH    AZ  HLM   HE D  8Ho    AZ  HLM  H D  H: HME3HH  H D  E3HMLH D  H E3HD$(LEgHEwHU3HD$ H` D  {HEgHV HHXHhVWAVHPH`  HH` HPLIHH }1 H$   x/HT$@   LHl$8Lt$0HT$(DA0  Ht$ @  HtHH9 D  y  H\$pHl$xHPA^_^E3LHt5Lq A<s(AHAD;tAI 3A  HHXUVWAVAWH@3LH9-6 HhD}uZEH 3H% D  HHu!HY D  H; D     3H tH D  H H$   Hl$0A   l$(D 	  HD$ H D  u
        J0H@ D  HHu  hf@   fA+fPfA+fH D  HGHuHH D  DHH$    HGHf,HI>H$   HtH D  H\$pH@A_A^_^]H\$ UVWHHPHe( 3H!]0W!] WHHEMHk  Ht D  u
x  ,  H HE0HELMHE E   H}0LE(H	HUHD$(D$    H D     }     }    HM(H   9    HEAtquoH# HHH  H D  uHH HHH  H D  u$H HHH`  H D  t >t$H HHH  H D  t  HM(HtH D  HMH D  H$   HP_^]H\$Ht$WH 3AD$0@u	uEtVH H =a  uA@u<tHT$0L$0xu u@tH 	 ya  H\$8Ht$@H _HHXWH`3WH!X!XH9 @u
    3HL$PH{ D  H H` D  HL$pE3HL$HLD$PHL$xHL$@H D$8   H!\$0H!\$(!\$ H D  uH	 D  H D  `D$pH Hh A   D$(E3HD$xHD$ HZ D  t%H D  H H D  HL$xHtH D  H$   H`_H\$UVWATAUAVAWHH`Hq H3HEE33HELEHAEH%  EL$IED$HUH& D    u  fD9%} uHb H} H D  fD9%} uHN H} H D  HtLE3H} HH D  u	L=p &E3Hv} HHt D  L=p MEA;   LELeIH+ D  +  HE8t	8  MtHHIH D  HE`HED8`tD9`uIH D  w  EFD;  LELeAIH D    AD;sLELeIHc D  c  HMHU:   <   <<  LaLjLeILmH D  IEH D  HULEEJA8HtJA9H   IIH D  E3toLmLeUDMAMAD$+A+;uCHUDAHM/ u,AEAD$HEHUH	JIH4 D  E3B8AtB9AuHHH* D  tHEHUHJHEHUH	JIH D  w  HMH3~H$   H`A_A^A]A\_^]L     L+E3HHtAftfHHuHHAHEHfD%  @UHpHl$PH]0Hu8H}@H"m H3HEHz 3!] 3H!]!]HufHEE3HD$@H> Hz E3HD$8H  H!\$0D$(   !\$ HP D  tH D    HKz HE E3HD$(Hx H!\$ E3H D  =   t   E   H;3 wXH0 HHH;rEw t<HFHHH;w
HHH H+H\$PHtStckHu'HNH;rH  HHt
 HeapHHu
    Hjy HE HD$(H E3H\$ E3H8 D     tH D     U HE HD$HE3HEE3HD$@HH!|$8D$0A   H!|$(H!|$ Hw D  u4HO D  t= 	tH% D     QM H D  Hx Hu
     DE HHU xH=xx  t!H D     E3LI 3APH D  HuYH D  =   uL 3   @Hp D  Hu%HM D  H' Hx D  HHW D  HtHK9HeapuH  HMHtHm D  HMH3zH]0Hu8H}@He ]H\$WH HHHt& tHwi  H\$0H _@SH d$8 Hd$@ d$H HtL tCE3HT$8u x7L$8LD$HHT$@b> x L$@H0L$HH [s  H [@SVATAUAVAWHH  Hh H3H$0  MMDL3A   H$   Hd$H W3D$hHD$x$   f$   $   D$03Ht$`F D$P!D$8!D$4M	  M   E  3T$<A;s$HI u  \$@  IKH@   H D  HHu
    EtA MH@$Hu$   t~H$   H4 D  \  E3E;5  KLLD$8HT$4I ,  D$4D   ACD$8HiD$PD$PACAHT$HIHf D  u!H> D  H  D     HD$0HD$ E3E3HT$hI     |$0 u
4     H$   HL$h2  xsE3E;sPKLLD$8HT$4I xKD$4D   ACD$8HiD$PD$PACAIu   \$@Ht$`  HL$HHtH D  yHtHH D  H$0  H3wHH  A_A^A]A\^[@UVWATAUAVAWH   Hl$0H  He H3H  33MH]DHE LE(WfE,3E.A  ]HM0] EEE]IA       H9%} rBH$} H   H;r/k 3t&$H   H|$0HtStckHu'3H|     HHt
 HeapHHu
  ^  HM0 E   Hc  DE;sDAHUE3HL    MI   MACff	DOAHH D  E3   H$ LE0A  x     3Ld$ H D     HUIHJ D  uH" D  H D  tHv Hk D  u  THE E3E3HD$ HUI  3xD0  8E    E   s  Hu H D  HMHtH D  HtHO9HeapuH:{ M HtHN9HeapuH{ 0 H  H3/tH  H  A_A^A]A\_^]HHMh  \   H9z rAHz H   H;r. E3t"$H   Ht$0HtStckHu&Hxz     E3HHt
 HeapHHu
     EONG F O0N0G@F@OPNPG`F`GpDHDHDE;sTAHUE3HL    MI# OACUt	BfDDGACJff	DOALME3HI  E3]t	EHPs H D  u
  Hs H D  HMHA!  x^MHH   H D  MH|  D   H~ D  H LE0A  Ld$ 3H D  Hr FH83f9t"H9AtHL$ D$ H* D    H8HHXUVWHxHp  )pHM` H3HP  13HMHHE3)t$@3EA  Ht$8t$0K~HG97ucHucfH~f  fofsfH~H  LD$8ft$PHT$0HL$P   u!4  tw    Hu    HWHL$@Ok  HOHtA   HUEA
HC D  tUHL$P(D$@ULGfD$PH D    HOHT$8Hu	H   DMDMD;L$0uDD$0    3HMWHEWHEEPEL$`L$pH D     HL$`H D  LD$8HMME3H| D  LGHL$`ME3H\ D  LD$`HUHL$@HMH$ LEA       3Ht$ H D    HL$8HtH D  HP  H3oL$p  I[0A(sI_^]HHXHhHp WAVAWH 33!pLHu
  r  tHj H D  u
  J  H6k H D  DH~ D  HHuHj   H D    Hj MH Hcj H D  !u!uu	  f!Uu	  f!ELD$H3HH, D  =#  uoT$HA@   AHJ D  HHu  PLD$HHHH D  x3   AH
 D  HHtD$HHw3	x  HH| D  HtHH D  Hl$PH\$@Ht$XI>H A_A^_H\$UVWAVAWHH@E3fD}HD}Hu
    LrMttDIH3 D  tLEIHUHH D  ;  UH   f@t?LM8D}@LED}8HU@L}IH D     L9}YUHf@?H`h H D  u
     Hh H D  H  D  HHu  OHh LH Lch L|$ Lgh IH D  xxH)Hg H D  HtHH D  H\$pH@A_A^_^]H,  Hq^ ,  H\$Ht$WH 9 HHtTHYHHL D  HO(H\$0H9 u(H! He HuHaf HtIH HL$06H\$8Ht$@H _@USVWAVHH0H" HH<   e0 LE0HU8  D}0 AHE8DtAu>	  Au
%   AtDAug=>]  t^L5=] IH; D  <] Lu@t-;u)e HUA   E   HH] H}u'HM@uE8>%	  HH0A^_^[]@USVWAVHH0H" HH<   e0 LE0HU8  D}0 AHE8DtAu>	  Au
%   AtDAug=\  t^L5\ IH D  \ Lu@t-;u)e HUA   E   H\ H}gu'HM@uE8>%	  HH0A^_^[]@USVWAVHH0H" HH<   pe0 LE0HU8  D}0 AHE8DtAu>	  Au
%   AtDAug=Z  t^L5Z IH D  Z Lu@t-;u)e HUA   E   HZ H};u'HM@uE8>%	  HH0A^_^[]@USVWAVHH0H" HH<   De0 LE0HU8  D}0 AHE8DtAu>	  Au
%   AtDAug=Y  t^L5Y IH D  Y Lu@t-;u)e HUA   E   HY H}u'HM@uE8>%	  HH0A^_^[]@USVWAVHH0H" HH<   e0 LE0HU8  D}0 AHE8DtAu>	  Au
%   AtDAug=X  t^L5X IH D  X Lu@t-;u)e HUA   E   HX H}u'HM@nuE8>%	  HH0A^_^[]@USVWAVHH0H" HH<   e0 LE0HU81  D}0 AHE8DtAu>	  Au
%   AtDAug=bW  t^L5aW IH_ D  `W Lu@t-;u)e HUA   E   HlW H}u'HM@BuE8>%	  HH0A^_^[]@USVWAVHH0H" HH<   e0 LE0HU8  D}0 AHE8DtAu>	  Au
%   AtDAug=6V  t^L55V IH3 D  4V Lu@t-;u)e HUA   E   H@V H}u'HM@~uE8>%	  HH0A^_^[]H\$Ht$WH 0;H<*  H# DDA?A   @   #H   A%   AEu	3ADA   A#2   A;t@tHlg W$  Hg O%  @@tu3Ht$8HH\$0H _@SH );He)  DDE3A?LA   EQ@A#   A%   AEtAEDEAHH [@SH ihH(  DDE3A?LA   EY@A#   A%   AEtAAADA   A#AA;uAu	At
tA   AHH [@SH 4H5(  DDE3A?LA   EQ@A#   A%   AEtAEDEAHH [@SH 4H'  DDE3A?LA   EQ@A#   A%   AEtAEDEAHH [H\$Hl$Ht$WH |fH'  H# DDA?A   @   #H   A%   AEu	3ADA   A#2   A;u@@2@t0H7d &  tHGd "  @2@tu3
@tu3Hl$8Ht$@HH\$0H _H\$Hl$Ht$WH .ZH&  H# DDA?A   @   #H   A%   AEu	3ADA   A#2   A;u@@2@t&Hc .&  @tu
@tu3Hl$8Ht$@HH\$0H _HHXHpHx UATAUAVAWHH  HL H3H  Hd$0 LHd$P 3ID$8   HMHL$XDBhj3HMA   jE3Er  D!mHck E2E  E   A}}Ht/HHt D  ML-k HDEHH\-HHE D  MLj HDEHLDE   EHTE9Y HLH'Y EHHLEHEMt)D   EHD   MI$HHDD   EHED   Ht(HHz D  MHDEHH\-IHR D  MHDHj EHHLE   EHt(HTEHLEHHtEEMt)AHTEHLEHL|EA   EHEAD   EHD   MH@  HHDEEHDLEH  HDDEHHLH@  EEHHD$HDLEHDDEHHTEEDILd$@FL%EHDDLD$0EHHTD}AL|$ D}H D  y=|  =  L!l$03o  3D~;sqHL$0HR L|$PLk8MMe    LD$ HUDI"    IA   Htx EEEFl$xAE  MMB)dr  &EHM3    =  m  MHT$|LHBHt@H8M+uE3Apd+E`LL$(DAHL$PErg  3HML)AQ! HI8M+uuHL$|HHAHt@H8I+uLL$(DAHL$Pg  HL$@E;L|$ AD   D   HD   Dd$8Ll$HAHMb  A3BD-   BD-   JD-;s%E7Hk8HD$PHHU!!  xTE3HM3  x<Ad   LL$(D+EHL$P   ef  AE;qL|$ yL|$ p  L|$ H|$0 t(Ht$PHb  H8HuHL$0H D  AHMb  H  H3\WL$  I[8Is@I{HIA_A^A]A\]A   Ht;9  uy u3D
A;u!29  uy u3EA;AH\$Ht$H|$UATAUAVAWHHPHe 3!uMLLELMVHMPH1 D  y=|  8  3F  HMHEE3HD$ E3AQH6 D     HR D    H= D  H- D  z    MH D  HHu
     DMHEHML   HD$ H D  u3H D  H D  KH D  8HEXMHD$8H7 HEPMHD$0HLt$(L|$ !  HtHHh D  HMHtH D  L\$PI[0Is8I{@IA_A^A]A\]@SH M3LL$XMHA9u$HB HB H;tLADtFHI8e  ;xMIH'  %[ uILD$PHA9Yt_	  $  H [HLH L@HUSVWATAUAVAWHHxHMhWAL)pW	HMp)xWW}H! HMxD2E(u! H   C<.Dm! H   ! A;   3  }PEtdADuHK@AHI D  HELHu
    }PEt#3}PL@ID$HHRIM@Hu}fsfI~fA~EtcIDmH@   IH D  HEHHu
  N  Et#LMXL@3IAHHRIM@Huufof~ufsfH~UP@   HH` D  HELHt33EXA  D`E   EHEIHHEHILH D    LEAA;CA#A;|  LUt!FA;CA#A ;Q  UH;wEXM;vAMA;bEXUHE3D9m   EDIAHHEHHLH D     LMAE  A	A;DC#E;   LUAt#FAAAA;C#AA;   MH;wEXA;vADAD;mUEXHM`WHUxWfsfsfI~9HMhfH~1HMpHep LMP
H   H   D   L}H}HMpHS D  HHD D  IH5 D  (t$`(|$PHxA_A^A]A\_^[]HLH D@HPHHSUVWATAUAVAWHh` L` A)L$   E(A;}  9$   t
  o  $   E33DE3EB  A3DT$0Et	A;ABAE3D++tEt
A;EDBE+|$HtHHIAHD$PHd$P Dt$8EtHHI@HD$@Hd$@ D$   HD$8HD$ LL$HH$   AIm    D$   FL$   D+D$       EtrD$   A+;sAA+A;sD;t!AA+AA+A;sA;rL$   DT$0L$   L$   3  HhA_A^A]A\_^][H\$ UVWHpH= H3HD$`LI3IHMtm	t]t=ttttt	L FM	L,     HL$ :E	L     HL$ L L      HL$     HL$ H D  HHtf/H;wL HHT$  HL$`H3MH$   Hp_^]H\$Hl$VWAVH HB3!\$@HHIMAHHtHtDGH
 u   H   HGLD$@3HD$@LD$@3HiD$@M   ;   LGHIM@L_L A+I^nLD$@H+D$@I^\$@L +I^:LD$@+Ht$@I^\$@H) ;     I^HD$`Hl$PH\$HH A^_^HHXHhHp WATAUAVAWH03EHXH+MLHEt-EHD$pE3H>HD$ E3HOl$pH(IuHH D  IE HHtVt<Et2HD$pl$pJ>HD$ DLID$pI(H<GIufL}    H  Hl$hH\$`Ht$xH0A_A^A]A\_HHXHpHxUATAUAVAWHhH   AA$WELME3WLELxMDELpELEIEIHEMIMDEDEDEhAAMDEEDEA;e  UuA[  HEhHD$0LMHEHD$(LEHEHUHD$  A %  HV(HMH[ D  LMHELt L$p3L$hL$`HD$XHX L$PHMLd$HLl$@HD$8HEH|$0HD$(HEHD$ H D  t
     MHEHD$@LMHEMHD$8IHEHD$0HEHD$(HEHD$ xXELMDEHUD$@H#  ED$8ED$0HEHD$(HEHD$ H}LmLeHu   HMH D  HMH D  HMHz D  3@8}htHMH
 D  @8}tHMH D  @8}tHMH D  L$   I[0Is8I{@IA_A^A]A\]H\$UVWATAUAVAWHl$H@  E3W3LmHE WA@HE LmMMDmL`ELmLxMIHE(MIEMDmDmA$DmADmD   D   MDmEDmA;  UuA  HEHD$0LM HEHD$(LEHEHUHD$ A> j  H   HHD$0LMHEHD$(LEH   HUHD$ > +  IVHM(H] D  LMHE(L L$x3L$pL$hHD$`HEL$XHMH|$PHD$HHEHD$@HEHD$8HEHt$0HD$(HE HD$ H D  t
     MHEHD$@LMHEMHD$8IHEHD$0HEHD$(HEHD$ xTELMDEHUD$@H{  ED$8ED$0HEHD$(HEHD$ HuH}Lu   HMH D  HMH D  HMHv D  D8   tHMH D  D8   tHMH D  D8mtHMH D  D8mtHMH D  D8mtHMH D  D8mtHMH D  H$  H@  A_A^A]A\_^]@SUVWATAVAWH@  H4 H3H$0  H$  HQWLI$   H$   AHR(H D  3H$  A  QINAt   H IH$   EL$L ET$AD$$   H$   $   A $   D$   $   D$   $   H$   D$   H$   AAL$D$   $   IFD$   EH$   IFD$   HD$xHR DT$pHD$hHQL$`HD$XH@ D$P   HD$HI  A  DT$@HD$8L$0H$  fD$( fD$    xE3H$  3j  H$0  H3CH@  A_A^A\_^][@SVWAVH  H<2 H3H$  HLIQH$   WI$   IH7 D  3H$   A  %PH At   HEAC AQ$   H$   $   H$   CD$   $   HKQ $   AQH$   D$   Ht$xDD$pHD$hIT$`HD$XH~? D$P   HD$HH  H$   DD$@A  HD$8T$0AQfD$(	 fD$  '  xE3H$   3  H$  H3BH  A^_^[@SUVWATAVAWH   H0 H3H$  H$  ADHWH$   3A  $   INHWH$   HRH D  HOAt   Hk HWLH$   ET$LE\$AD$$   H$   $   A$   D$   D$   D$   $   H$   D$   H$   AAL$D$   D$xHQDT$pHD$hI A  L$`HD$XH= L$PH$   HD$HI  ED\$@HD$8D$0   fD$( fD$  f  xE3H$   30  H$  H3P@H   A_A^A\_^][LH   H$   E3MSESMSMSMSMSMSICH$   IC$   ESD$0H$   ICH$   ICG  H   LH   3ICD$xICICICICICH$   ICH$   IC$   D$8$   D$0H$   ICH$   IC}F  H   H\$WH 9 Ht.HYHHT D  HH\$0zHL$0G dZH\$8H _H\$UVWH09 IH      H_HH D  3H\$hHO0l$ HT$ D$$Ht$(D@Q H_uPH; u8HL$PWE3HHH D  HH7HL$P\A HWHScHL$hYH\$XH0_^]H\$LL$ WHPDHAuHT$@0L LD$xEfD$d 3AT$0HD$`A
HKT$`AA|$(0;HD$   H\$hHP_LL$ SHPDHAuHT$@HHT$xDEfD$d 3AT$0HD$`A
HKT$`AAD$(   );HD$   HP[H\$LL$ WHPDHAuHT$@L LD$xED$0   3AD$`HKA
HD$`A|$(AHD$ ihfD$d   H\$hHP_LL$ SHPDHAuHT$@4HHT$xDEfD$d 3AT$0HD$`A
HKT$`AAD$(   4HD$   HP[LL$ SHPDHAuHT$@HHT$xDEfD$d 3AT$0HD$`A
HKT$`AAD$(   4HD$   HP[H\$LL$ WHPDHAuHT$@L LD$xEfD$d 3AT$0HD$`A
HKT$`AA|$(|fHD$    H\$hHP_H\$LL$ WHPDHAuHT$@4L LD$xED$0   3AD$`HKA
HD$`A|$(AHD$ .ZfD$d    H\$hHP_HHXWHPLEH8tt$   N  H$   IDGDD$8ED$ [   tBH$6 Ht6D$   H$   HD$8   E3D$0 HHd$( HL$  H\$`HP_HHXHhHpWAVAWHp$   HEEHHHE3D|L     @Hl4 D$PL$0HttK1wDD L$0f~tLHu, ^L$0fofsfA~Etfsf~vt$PuHH0, EtEDE3@uH3 HtD$    3L\$pI[ Ik(Is0IA_A^_LD$LL$ SVWAVH8H3LHBH=v  Ht1f,HrHLL$xkExHH;wu  fAvH8A^_^[H3 Ht
    H3 HuH\$WH HT$@H1\$@HH\$0H _H\$WH HT$8HM\$8HH\$0H _H\$WH HT$@H\$@HH\$0H _H\$WH HT$8H\$8HH\$0H _H\$DD$UVWATAUAVAWHHP3W!]@AE3LDEXHEEH  H     Di0E  HHs  DHED+y,DMC/D;s1AAHE;uHGHGHAHD HuDEXAAHEH. D  HHu
    EO0AD;   HAHEHH
EL
MD;mt*HOf~B;tHEH EBEHGHGBHVLE@M@HMH D  x;E@uHHA^  HtQHHl D  @H+uEXMPHBD1    BD1Jt10G0Jd1( JD1 G0)G,g0   H$   HPA_A^A]A\_^]H\$UVWATAUH$0H  H# H3H  AHH3A  HMAe LMHe WA   EA   EAHE     }    HUHM     HHMHC D  H' E3H@AHA   M$   HML  AT$$      HL$xHMD$p   HL$hHMD$`   HD$XH0 D$P   HD$HD$@   LL$8ED$0   fD$( fDd$ u  xE3HM3C  *  H  H3[3H$   H  A]A\_^]@USVWAUAVH$(H(  H! H3H  IH3A  HME@e LMHe WA   EEH   E-  .  } +  HUHM    HHMH D  H| AUA   A  HE$   HE$   H$   8  $      $   0  $   $   $      $   HE$   Dt$xT$pAUHD$hHD$`   HD$XH. D$P   HD$HH  HMD$@   HD$8D$0   fD$(
 fDl$   xE3HM3Y  @  H  H3q1H(  A^A]_^[]HHXHpHx UATAUAVAWHHP  H  H3H@  ILH3A  HL$ I>d$( L%? D$    A   D$0s  D$$  Dl$8Ht*HH D  L$(HD<D$(HH\P(IH[ D  L$(HD<D$(HLdPD$(A   d- AD$(HD|8D$(HL<H>- D$(HHLPD$(AHD$(Mt*D8   D$(HD<   L$(IHHD@D8   D$(AHD$(Dl8Ht*HH D  L$(HD<D$(HH\P(IHb D  L$(HD<D$(HLdPD$(D$(Ht,HD|8D$(HL<D$(HHtPD$(D$(Ht,HD|8D$(HL<D$(HH|PD$(AE3D$(HD8   D$(HD<   T$(H  HHHL@   D$(AD$(HT8D$(HDl<H  D$(HHL@D$(AD$(HT8D$(  HDl<D$(HHL@D$(AD$(HT8D$(H    HDl<D$(HHL@D$(AD$(HD|8D$(
HL<HL$ D$(HHTP3D|$(  H@  H3-L$P  I[8Is@I{HIA_A^A]A\]@SUVWATAVAWH   Hg H3H$  H$  EH$  LH$  H3H$   A  M[:H< A   H$   HEA$  APD$   $   $  $   H$   D$   $   $  $   H$   D$   $   H) $   L$   D$   D|$xT$pAPLd$hT$`H\$XD$P   HD$HH  H$   D$@   HD$8T$0APA  fD$( fD$  0  xE3H$   3}  y  H$  H3,H   A_A^A\_^][H\$WH  H H3H$  H3H$   A  8H   H      L   $   j   HCp$      H$   Ht( $      DOHT$xWDL$pLD$hA  DL$`HL$XT$PHD$HDL$@DHL$8H$   T$0WfD$( fD$    xE3H$   3|    H$  H3*H$  H  _LH   Ic $p  ACH$h  ICH$`  ICH$X  ICH$P  ICH$H  ICH$@  IC$8  D$p$0  D$hH$(  ICH$   ICH$  ICd$H $  D$@H$  HD$8H$   HD$0H$   HD$(H$   HD$    H   H\$ UVWATAUAVAWH$pH  Hz H3H  H  EH  DH   E3HE3H0  A  HEAHP  HD$HHX  HEH`  HEH  DHM HD$xDL$<H}Ht$h&6ADt$pWD$3WD$43D$8A  D$5H`  D$0D$6AD$1D$2HT$PEDt$DMEM5H`  D$@  HE3HEW3HMHP  fX  H@  HMHHD$`@  HD$X       HM  v  H    b  HM  Q  H     =  8  4 A~kGfEAFPfD;   DH(  LL$48  3  D$4D$3   YDKjLL$5H(    L$5LL$63DHH(  L$8Kk  3yD$6D$0H- 3t.H9L$xt'DAAHlLL$2H(    3yL$1@I  jD$2D$1`fD;  l  @Hr- -3t=@  H9L$xtPDAAHdLL$2H(    3y'L$18L$3u#@u3@8t$8u@8t$0  
D$2D$13A  u(L1, H&, H(  |  \$0@@t$8\$03HM A  ?3H(  De f}0D}$fDm2u(H D  LHt*HHx9l4 uP|9e4 tHx D  HD$PD|$3L%R4 D$8EuuuHH  3NHH  3HuNfD;uMtI  EuutH\$hH  Euu@8|$0uIH\$hE(HD8   Ht(HH D  M(HD<E(HH\P&IH D  M(HD<E(HLdPE(A   ! AHT$HE(HDd8E(HL<H! E(HHLPE(AHE(Ht)D8   AL$E(HL<M(HHHD@D8   E(AHE(D8   Ht(HH D  M(HD<E(HH\P1H2 H D  M(HD<H2 E(HHLPH HHH`  H D  DU(DHEEH DU(HtSEtf98uHp   |$<   EfD;u 		  uHEHMH  fELm|$<Et=L+Ip  t5AHDd8E(AM HL<E(HLlPDU(LmHEEE3DU(HtGEtfD9 uH   EHEHMHF  E3fEfLeMDEtIL#I  A   Mt=AHD8   E(A$HAL<E(HLdPDU(	MA   AA
   DU(E   D8D$8   D8D$0   8  AQAHDL8E(HT<E(HHL@E(E(HD8   E(HT<E(HHL@E(E(HDL8E(@  HT<E(HHL@7   AH   D8   E(HL<M(H(  HHD@E(  E(HD8   E(HT<E(H   HH|@E(E(Ht,
HAD8   E(HL<E(HHTPE(H  E(Ht,
HAD8   E(HL<E(HHTPE(DPHEDU(Ht_ fH~EHfsfH~	  fEft4AHD8   E(AHL<HME(HHLPDU(ABE(Ht,HD8   E(HD\<E(HHtPE(E(H]3Ht+HHD\8   M(HD<E(HH\PE(Hp  E(HuHz HMH D  E(HU
A   HAD8   E(HL<E(HHTPE(E(HD8   E(x  HD<   E(HHL@E(HMDE(IBD8   E(HHt<D<     DE(HIJD@LE  HUA   HUD$@   H`  L<E(HHt@M(M(9t$@|.HD8   E(
HAL<E(HHTPM(Hh  M(Ht9   HL8E(Hf9
u
D<   DL<E(HHTPM(M(E     tt   A0  A)  A(  T$ZL2 HL$`hx&T$ZHL$`HH D  HffL$XL$XE(A   HAD8   E(HL<HL$XE(HHLPM(3  M(DCE   
u|   Mt	A8  uHD$PHt38  t+HD8   E(HD<   E(HLD@)HD8   E(HD<   E(HH\@M(M(E   
u|   Mt	A8  uHD$PHt38  t+HD8   E(HD<   E(HLD@)HD8   E(HD<   E(HH\@M(AE(Et{	uvMtqHI   D8   
E(AHL<E(HHTPI0  E(E(HD8   E(
HAL<E(HHTPE(E(Etx   Mt	A8  uHL$PHt18  t)HD8   E(HD<   E(HLD@'HD8   E(HD<   E(HH\@E(E(Et;H   D8   E(HL<IFxM(HMuH) H HD@E(EtrLE   H(  Hy D  xRHMHtILD$pHT$D  x6E(HD8   E(HD<   D$DE(HHHHT@E(HM E33_l  H! tD   L|$H@8t$1t9HD$xHt/8  L(  HD$(MILd$ 1L|$Hxm@8t$0Ht$ht+H(  M|$(MIHD$ H#3x838T$8t5H(  M|$(MIHD$ Hpy  |  HMHtH4 D  HD$PHtHH;x D  MtIH'x D  HEHtH`  H;tHHsw D  H  H3GH$  H  A_A^A]A\_^]H\$ UVWATAWH$Hp  H H3H`  A   D$  ILL$ HWEHAO]D$(7|    |$  }  HHL$(H} D  Z  3HL$@A  %HAd$H |$@D$Pe  D$D  D$X   Ht*H~ D  L$HHD\L$HHHHDp/H& HH} D  L$HHD\D$HHH\pD$HE33D$HH|XD$H HL\H D$HHHLpD$HD$HHDX   D$HHD|\L$HHHHD`D$HD$HH|XD$HL$(HL\HL$(D$HHHLpHL$@|$Hi    H`  H3(H$  Hp  A_A\_^]H\$Ht$UWAVH$HP  H H3H@  HP  S     J]3|  H  3HL$ A  #d$( Ht D$    D$0e  |$$D$8   HH  Ht8H#| D  L$(HD<L$(H?t HH H  HDP/H=$ HH{ D  L$(HD<D$(HH|PD$(E33D$(HD8   D$( HL<H D$(HHLPD$(D$(HD8   D$(HL<HL$ D$(HH\PD$(?g  
  #  H@  H3TL$P  I[ Is0IA^_]H\$WH  H H3H$  3H$   A  "Hd$p HL$pHx D  uGHt D  Hr D  yz  H$  H3H$  H  _      z  tA   Hrr # HHD$pHD$hHT D$`   L  fT$XfD$P   fHD$H   D$@   LD$8A&  DL$0fDL$(DfL$ H$     'E3H$   3e  HHXHpHx UATAUAVAWHxH`  Hs H3HP  H  ML  HHE3HL$0A  u d$8 L-! HJq WD$ D$0   D$@i  HD$4C  D$H   H  Ht8Hx D  L$8HDLL$8Hp HH H  HD`(IHx D  L$8HDLD$8HLl`D$8A    AD$8HDlHD$8HLLH| D$8HHL`D$8AHD$8DH   Ht1HHx D  L$8HDLD$8HH|`H=  /H=  HHw D  L$8HDLD$8HH|`D$8AD$8Hu!H HL$ Hw D  D$8H\$ HDlHD$8HLLD$8HH\`D$8AD$8Mu!H- HL$ Hw D  D$8Lt$ A   HDBDlHD$8HLLD$8HLt`D$8AD$8HTHD$8HDDLD$8HLdPD$8AD$8HTHD$8  HDDLD$8HHLPD$8AD$8HTHD$8  HDDLD$8HHLPD$8AHD$8DDHHt*HH?v D  L$8HDLD$8HHt`(HHv D  L$8HDLD$8HH|`D$8AHD$8DH   I  L$8E3H3DLHL$0D$8HL|`Dl$8a  HP  H3L$`  I[8Is@I{HIA_A^A]A\]@SUVWAVAWH  Hi H3H$  L$@  MHH$   H3A  H$   I3c$   H  9>  H    I    L$   DGH$   Omfr  t  @8$     L H H$   ^  t@      Hl D  HHu
      39  3LRs4Lh MA B9DuA@B9DtH@I HD;r?    H$   H A   D$   H$   $      Lt$xAHD$p   QHl$hEHeD$`   L|$XL$PHD$HD$@   L|$8L$0H$   fD$( fDD$ A@    xE3H$   3Q_    3  HtHH|k D  H$  H3OH  A_A^_^][H\$UVWATAUAVAWH$ H  H H3H  MDLM3HMA  E3HT$xWL}HML|$xEAL}D|$p  Lu   t      Ai     Aj  ELL$pHT$xo     @8t$p   D@  LMHUIHu   HHMH4r D     DHEEHD$hHD$xJL$`HD$XH D$P   HD$HIL$@HD$8T$0fT$(QHMfDd$   xE3HM3z]  a~  MtIHi D  HHi D  H  H3mH$   H  A_A^A]A\_^]HHXHhHpWAVAWHpH` IH` A@  DMtA9Cr
     HT$`HL$h  H|$h   L7o  t-L$   A   HT$`   &n  xy$    toH$   A   HD$XMH$   AHD$PH$   HD$H$   D$@H$   HD$8$   D$0HD$`Ht$(HD$ I   HtHH@h D  y|  L\$pI[ Ik(Is0IA_A^_HHMD   o  ;u;H$   EBHD$8H$   AHD$0HD$pHD$(Hd$    Cw8HD$xA   HD$8H$   HHD$pHL$0AHD$(L\$ &  3HH@SUVWATAVAWH  H H3H$  H$   DH$0  3H$8  EEA  H$   WH$   H$   Hn D  A   H$   HD$xH$(  EADD$pAIH|$hL$`HD$XH DL$PHD$HDD$@EHl$8L$0H$   fDL$(EfDd$ 9  xE3H$   3Z  z  H$  H3H  A_A^A\_^][@USVWATAVAWH$H`  H H3H  McLDHM3A  He WHe WEE MHG H@ H;t%@DtHh D  H" DHI8  H "tMu
    HUHMJ  Hu  H]  u
} ~  ELMHUy   qj  _  } U  AF8IN@fH~HEG  fEHMHa JHl D  H$    A   H$    H$    AFpIcNXAP$   EHu$   
   D$   $   HE$      L$   $      H$   HE$   H$   H $   HHd HL$xHMT$pHD$hH T$`H\$XD$P   HD$HHT$@APHD$8DD$0A6  fD$( fD|$   xE3HM3hW  HA HtHHc D  y2x  H H;t)@Dt#Hf D  H D|$ HI8  H  H3,H`  A_A^A\_^[]3<    H\$WH  H H3H$  3H$   A  Hb Af   \$xL AI
 QL$pD$hH L$`H$   |$XD$P
   HD$HI  A	  T$@HD$8D$0   fD$( fD$  *  $   H$   E33U  H$  H3H$  H  _@SUVWATAUAVAWH   H H3HD$pH$   EL$   3L$  3H$   DLpLL$PLD$XL+AC7f;   FdD$@fT$8AfL$0H\$(LD$ E   xouMWHT$`NdD$`>{x2LD$`HL{ Hit Ha D  t	  LD$XLL$PI<Syu  HL$pH3H   A_A^A]A\_^][@USVWATAUAVAWH$H  H] H3H  HP  EDD3HL$pA  Idh  3WD$TDD$dD$<D$0D$4  HD$Hf9`  3  Dt$p   E3fEDd$tfD}Dt$xE   Ht1HHg D  L$xHDD$xHH\HE /H< HHjg D  L$xHDD$xHH\D$xA   s AD$xHD|D$xHLHM D$xHHLD$xAD$xHD   D$xHD   L$xHX  HHDD$xD$xAo  thHD   Ht*HHf D  L$xHDD$xHHt(HHsf D  L$xHDD$xHH\D|$xp  LD$4HT$0    \$0H   HT$PD$P   HD$XP   ;  ^  D$xHT$`L$PHD$`   D|D$xHLHL$PD$xHHLK0D|$xH@  L$4HD$h    D$xHL$`T$`   HD|D$xHTH  D$xHHLD|$xp  w  D$xH  `  H3D$8  p D   D$xHtD$xHHLH`  D|$xHD$@Ao  uEAt!HT$8fA# !         fB     At!HT$8fA#!      t#HT$8fB      t$HT$8f   f    t$fP HT$8=  `  3H  DBpCH       3  Hk] D  ukD  3E   H:_ D  HHtFA   Lt$ LD$HHAQTHoc D  x%H0H	L$HHH] D  D$xE3L$83HD|D$xHLHL$8D$xHHLD$xAD$xHD   D$xHAD   D$xHHLD$xAD$xHD   D$xHD   L$xHD$HHHDHL$pD|$xN  H  H3H  A_A^A]A\_^[]H\$H|$UH$HP  Ho H3H@     J\a  	  3HL$ A  v	d$( HRZ D$    D$0d  D$$   D$8   HH  Ht8Ha D  L$(HD<L$(H Z HH H  HDP/Ht
 HHa D  L$(HD<D$(HH\PD$(E33D$(HD8   D$( HL<H D$(HHLPHL$ D$(7M  H@  H3XL$P  I[I{I]@USVWATAUAVAWH$HX  H H3H@  H  EH  EH  DDH  ;   3HL$ A  d$( fDd$0A   Dt$ L5.	 Dd$8D|$$fDl$2Ht*HHG` D  L$(HD<D$(HH|P(IH` D  L$(HD<D$(HLtPD$(A   & AD$(HAD|8D$(HL<H D$(HHLPD$(AD$(HD8   D$(H|<L$(H  HHD@D$(AHD$(Dd8Ht*HHY_ D  L$(HD<D$(HHtP(IH/_ D  L$(HD<D$(HLtPD$(AHD$(|8t
@<   D$(HL$ HE33|<D$(HH\PD|$(J  H@  H3HX  A_A^A]A\_^[]@USVWATAUAVAWHl$Hx  H H3HE H   HIW WHEWH   3HEMH   MHEH   HEH   HEH   HEH   HEH   HEH   ]EHEM	H!Y D  KHu
LufML   HV 	HX D  HHV D  H   E3LE 
 HEHEHEHHMHE   HUHUfEH[ D    UHM  fE  A   m     n  tz  t,[ tc tT tB$ t04 tt
 	       A      	     	     	     	  y	  ro  t;p  t,q  tr  t	   XE=	  6	  /	  (j  td  t 	   C
D		  HEMW0H$         D$   HEH$   HEL$   H$   HEH$   HEH$   HEHD$xHEt$p|$hHD$`HEH HD$XHEHD$P   D$H   D$@HELT$8HD$0Ll$(Ld$ Uh  HM H3Hx  A_A^A]A\_^[]H\$WH B;sC   HH0HHHtHFS D  H# WCc c H HuH\$0H _@SH HH	HtHR D  H# HKHtHR D  Hc H [H\$UVWATAUAVAWHH`3}XW}HM}LDDE!tt
    HEHA   LEHD$ HX D     H-T D  HT D  HT D    =z t
#  O  }Hs
  ?  MHHQ D  HHu
    DMHHEHLHD$ IHtW D  uAHS D  HS D  ^  HqS D    D  Hu9~b  NHHCQ D  LHu
    FL~ILHMMLELMD;n  AG      EWDUA9<uTLEX}X3IHX D  EX   A9<uAEXHM}X   vAGtAG<AGLEDULMAEWEt
AEAD]AAfAD]uAEAD]E9tBAHMAI   HH P D  MtdIHP D  SDmHLHLI6MfINMFMN En(HtNHAN,HF   HDt8A~0H$   H`A_A^A]A\_^]HHXHhVWH`  AH` DY,LYdMt"D;H8D;HHBDdBD,A	D;H8DAD;HHBtdA;rA+NA9Q,rD;HHFDh%M
;BD;H+H